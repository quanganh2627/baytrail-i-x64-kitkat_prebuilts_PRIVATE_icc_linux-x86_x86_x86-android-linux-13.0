<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- saved from url=(0014)about:internet -->
<html xmlns:MSHelp="http://www.microsoft.com/MSHelp/" lang="en-us" xml:lang="en-us"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<meta name="DC.Type" content="topic">
<meta name="DC.Title" content="formatOf General-Computational Operations Functions">
<meta name="DC.subject" content="Intel&reg; IEEE 754-2008 Binary Floating-Point Conformance Library, formatOf general-computational operations, add, sub, mul, div, sqrt, fma, from_int32, from_uint32, from_int64, from_uint64, to_int32_rnint, to_uint32_rnint, to_int64_rnint, to_uint64_rnint, to_int32_int, to_uint32_int, to_int64_int, to_uint64_int, to_int32_ceil, to_uint32_ceil, to_int64_ceil, to_uint64_ceil, to_int32_floor, to_uint32_floor, to_int64_floor, to_uint64_floor, to_int32_rninta, to_uint32_rninta, to_int64_rninta, to_uint64_rninta, to_int32_xrnint, to_uint32_xrnint, to_int64_xrnint, to_uint64_xrnint, to_int32_xint, to_uint32_xint, to_int64_xint, to_uint64_xint, to_int32_xceil, to_uint32_xceil, to_int64_xceil, to_uint64_xceil, to_int32_xfloor, to_uint32_xfloor, to_int64_xfloor, to_uint64_xfloor, to_int32_xrninta, to_uint32_xrninta, to_int64_xrninta, to_uint64_xrninta, binary32_to_binary64, binary64_to_binary32, from_string, to_string, from_hexstring, to_hexstring">
<meta name="keywords" content="Intel&reg; IEEE 754-2008 Binary Floating-Point Conformance Library, formatOf general-computational operations, add, sub, mul, div, sqrt, fma, from_int32, from_uint32, from_int64, from_uint64, to_int32_rnint, to_uint32_rnint, to_int64_rnint, to_uint64_rnint, to_int32_int, to_uint32_int, to_int64_int, to_uint64_int, to_int32_ceil, to_uint32_ceil, to_int64_ceil, to_uint64_ceil, to_int32_floor, to_uint32_floor, to_int64_floor, to_uint64_floor, to_int32_rninta, to_uint32_rninta, to_int64_rninta, to_uint64_rninta, to_int32_xrnint, to_uint32_xrnint, to_int64_xrnint, to_uint64_xrnint, to_int32_xint, to_uint32_xint, to_int64_xint, to_uint64_xint, to_int32_xceil, to_uint32_xceil, to_int64_xceil, to_uint64_xceil, to_int32_xfloor, to_uint32_xfloor, to_int64_xfloor, to_uint64_xfloor, to_int32_xrninta, to_uint32_xrninta, to_int64_xrninta, to_uint64_xrninta, binary32_to_binary64, binary64_to_binary32, from_string, to_string, from_hexstring, to_hexstring">
<meta name="DC.Relation" scheme="URI" content="GUID-BCBC835E-526E-4C9D-A82C-25CAF9108E0A.htm">
<meta name="DC.Relation" scheme="URI" content="http://www.intel.com/software/products/softwaredocs_feedback">
<meta name="DC.Format" content="XHTML">
<meta name="DC.Identifier" content="GUID-8EF74D30-D291-4997-9E58-3C2704EF8F43">
<meta name="DC.Language" content="en-US">
<link rel="stylesheet" type="text/css" href="intel_css_styles.css">
<title>formatOf General-Computational Operations Functions</title>
</head>
<body id="GUID-8EF74D30-D291-4997-9E58-3C2704EF8F43">
 <!-- ==============(Start:NavScript)================= -->
 <script src="NavScript.js" language="JavaScript1.2" type="text/javascript"></script>
 <script language="JavaScript1.2" type="text/javascript">WriteNavLink(0);</script>
 <!-- ==============(End:NavScript)================= -->
<p id="header_text" style="margin-bottom : 20pt"><em>Intel&reg; C++ Compiler XE 13.1 User and Reference Guides</em></p>



  <h1 class="topictitle1"><em>formatOf</em> General-Computational Operations Functions</h1>

  <div><p>Many routines in the libbfp754 library are more highly optimized for Intel&reg; microprocessors than for non-Intel microprocessors.</p>
<p>The Intel&reg; IEEE 754-2008 Binary Conformance Library supports the following functions for <em>formatOf</em> general-computational operations:</p>
<div class="section" id="ADD"><a name="ADD"><!-- --></a><h2 class="sectiontitle">  add</h2>

<p><strong>Description:</strong> The function computes the addition of two floating-point numbers; the result is then converted to the destination format.</p>


<p><strong>Calling interface:</strong><br><samp class="codeph">float __binary32_add_binary32_binary32(float x, float y);</samp><br><samp class="codeph">float __binary32_add_binary32_binary64(float x, double y);</samp><br><samp class="codeph">float __binary32_add_binary64_binary32(double x, float y);</samp><br><samp class="codeph">float __binary32_add_binary64_binary64(double x, double y);</samp><br><samp class="codeph">double __binary64_add_binary32_binary32(float x, float y);</samp><br><samp class="codeph">double __binary64_add_binary32_binary64(float x, double y);</samp><br><samp class="codeph">double __binary64_add_binary64_binary32(double x, float y);</samp><br><samp class="codeph">double __binary64_add_binary64_binary64(double x, double y);</samp></p>

</div>
<div class="section" id="SUB"><a name="SUB"><!-- --></a><h2 class="sectiontitle">  sub</h2>

<p><strong>Description:</strong> The function computes the subtraction of two floating-point numbers; the result is then converted to the destination format.</p>


<p><strong>Calling interface:</strong><br><samp class="codeph">float __binary32_sub_binary32_binary32(float x, float y);</samp><br><samp class="codeph">float __binary32_sub_binary32_binary64(float x, double y);</samp><br><samp class="codeph">float __binary32_sub_binary64_binary32(double x, float y);</samp><br>
<samp class="codeph">float __binary32_sub_binary64_binary64(double x, double y);</samp><br><samp class="codeph">double __binary64_sub_binary32_binary32(float x, float y);</samp><br><samp class="codeph">double __binary64_sub_binary32_binary64(float x, double y);</samp><br><samp class="codeph">double __binary64_sub_binary64_binary32(double x, float y);</samp><br><samp class="codeph">double __binary64_sub_binary64_binary64(double x, double y);</samp></p>

</div>
<div class="section" id="MUL"><a name="MUL"><!-- --></a><h2 class="sectiontitle"> mul</h2>

<p><strong>Description:</strong> The function computes the multiplication of two floating-point numbers; the result is then converted to the destination format.</p>


<p><strong>Calling interface:</strong><br><samp class="codeph">float __binary32_mul_binary32_binary32(float x, float y);</samp><br><samp class="codeph">float __binary32_mul_binary32_binary64(float x, double y);</samp><br><samp class="codeph">float __binary32_mul_binary64_binary32(double x, float y);</samp><br><samp class="codeph">float __binary32_mul_binary64_binary64(double x, double y);</samp>
<br><samp class="codeph">double __binary64_mul_binary32_binary32(float x, float y);</samp><br><samp class="codeph">double __binary64_mul_binary32_binary64(float x, double y);</samp><br><samp class="codeph">double __binary64_mul_binary64_binary32(double x, float y);</samp><br><samp class="codeph">double __binary64_mul_binary64_binary64(double x, double y);</samp></p>

</div>
<div class="section" id="DIV"><a name="DIV"><!-- --></a><h2 class="sectiontitle">  div</h2>

<p><strong>Description:</strong> The function computes the division of two floating-point numbers; the result is then converted to the destination format.</p>


<p><strong>Calling interface:</strong><br><samp class="codeph">float __binary32_div_binary32_binary32(float x, float y);</samp><br><samp class="codeph">float __binary32_div_binary32_binary64(float x, double y);</samp><br><samp class="codeph">float __binary32_div_binary64_binary32(double x, float y);</samp><br><samp class="codeph">float __binary32_div_binary64_binary64(double x, double y);</samp>
<br><samp class="codeph">double __binary64_div_binary32_binary32(float x, float y);</samp><br><samp class="codeph">double __binary64_div_binary32_binary64(float x, double y);</samp><br><samp class="codeph">double __binary64_div_binary64_binary32(double x, float y);</samp><br><samp class="codeph">double __binary64_div_binary64_binary64(double x, double y);</samp></p>

</div>
<div class="section" id="SQRT"><a name="SQRT"><!-- --></a><h2 class="sectiontitle">  sqrt</h2><p><strong>Description:</strong> The function computes the square root of floating-point number; the result is then converted to the destination format.</p>
<p><strong>Calling interface:</strong><br><samp class="codeph">float __binary32_sqrt_binary32(float x);</samp><br><samp class="codeph">float __binary32_sqrt_binary64(double x);</samp><br><samp class="codeph">double __binary32_sqrt_binary32(float x);</samp><br><samp class="codeph">double __binary32_sqrt_binary64(double x);</samp></p>
</div>
<div class="section" id="FMA"><a name="FMA"><!-- --></a><h2 class="sectiontitle">  fma</h2><p><strong>Description:</strong> The function computes the fused
multiply and add of three floating-point numbers x, y, and z as
(x×y) +z; the result is then converted to the destination
format.</p>



<p><strong>Calling interface:</strong><br><samp class="codeph">float __binary32_fma_binary32_binary32_binary32(float x, float y, float z);</samp><br><samp class="codeph">float __binary32_fma_binary32_binary32_binary64(float x, float y, double z);</samp><br><samp class="codeph">float __binary32_fma_binary32_binary64_binary32(float x, double y, float z);</samp><br><samp class="codeph">float __binary32_fma_binary32_binary64_binary64(float x, double y, double z);</samp><br><samp class="codeph">float __binary32_fma_binary64_binary32_binary32(double x, float y, float z);</samp><br><samp class="codeph">float __binary32_fma_binary64_binary32_binary64(double x, float y, double z);</samp><br><samp class="codeph">float __binary32_fma_binary64_binary64_binary32(double x, double y, float z);</samp><br><samp class="codeph">float __binary32_fma_binary64_binary64_binary64(double x, double y, double z);</samp><br><samp class="codeph">double __binary64_fma_binary32_binary32_binary32(float x, float y, float z);</samp><br><samp class="codeph">double __binary64_fma_binary32_binary32_binary64(float x, float y, double z);</samp><br><samp class="codeph">double __binary64_fma_binary32_binary64_binary32(float x, double y, float z);</samp><br><samp class="codeph">double __binary64_fma_binary32_binary64_binary64(float x, double y, double z);</samp><br><samp class="codeph">double __binary64_fma_binary64_binary32_binary32(double x, float y, float z);</samp><br><samp class="codeph">double __binary64_fma_binary64_binary32_binary64(double x, float y, double z);</samp><br><samp class="codeph">double __binary64_fma_binary64_binary64_binary32(double x, double y, float z);</samp><br><samp class="codeph">double __binary64_fma_binary64_binary64_binary64(double x, double y, double z);</samp></p>
</div>
<div class="section" id="FROM_INT32"><a name="FROM_INT32"><!-- --></a><h2 class="sectiontitle"> from_int32 / from_uint32 / from_int64 / from_uint64</h2><p><strong>Description:</strong> This function converts integral values in the specified integer format to floating-point number.</p>
<p><strong>Calling interface:</strong><br><samp class="codeph">float __binary32_from_int32(int n);</samp><br><samp class="codeph">double __binary64_from_int32(int n);</samp><br><samp class="codeph">float __binary32_from_uint32(unsigned int n);</samp><br><samp class="codeph">double __binary64_from_uint32(unsigned int n);</samp><br><samp class="codeph">float __binary32_from_int64(long long int n);</samp><br><samp class="codeph">double __binary64_from_int64(long long int n);</samp><br><samp class="codeph">float __binary32_from_uint64(unsigned long long int n);</samp><br><samp class="codeph">double __binary64_from_uint64(unsigned long long int n);</samp></p>
</div>
<div class="section" id="TO_INT32_RNINT"><a name="TO_INT32_RNINT"><!-- --></a><h2 class="sectiontitle"> to_int32_rnint / to_uint32_rnint / to_int64_rnint / to_uint64_rnint</h2><p><strong>Description:</strong> This function rounds floating-point number to the nearest integral value in the specified integer format, with halfway cases rounded to even, without signaling the inexact exception.</p>
<p><strong>Calling interface:</strong><br><samp class="codeph">int __binary32_to_int32_rnint(float x);</samp><br><samp class="codeph">int __binary64_to_int32_rnint(double x);</samp><br><samp class="codeph">unsigned int __binary32_to_uint32_rnint(float x);</samp><br><samp class="codeph">unsigned int __binary64_to_uint32_rnint(double x);</samp><br><samp class="codeph">long long int __binary32_to_int64_rnint(float x);</samp><br><samp class="codeph">long long int __binary64_to_int64_rnint(double x);</samp><br><samp class="codeph">unsigned long long int __binary32_to_uint64_rnint(float x);</samp><br><samp class="codeph">unsigned long long int __binary64_to_uint64_rnint(double x);</samp></p>
</div>
<div class="section" id="TO_INT32_INT"><a name="TO_INT32_INT"><!-- --></a><h2 class="sectiontitle"> to_int32_int / to_uint32_int / to_int64_int / to_uint64_int</h2><p><strong>Description:</strong> This function rounds floating-point number to the nearest integral value in the specified integer format toward zero, without signaling the inexact exception.</p>
<p><strong>Calling interface:</strong><br><samp class="codeph">int __binary32_to_int32_int(float x);</samp><br><samp class="codeph">int __binary64_to_int32_int(double x);</samp><br><samp class="codeph">unsigned int __binary32_to_uint32_int(float x);</samp><br><samp class="codeph">unsigned int __binary64_to_uint32_int(double x);</samp><br><samp class="codeph">long long int __binary32_to_int64_int(float x);</samp><br><samp class="codeph">long long int __binary64_to_int64_int(double x);</samp><br><samp class="codeph">unsigned long long int __binary32_to_uint64_int(float x);</samp><br><samp class="codeph">unsigned long long int __binary64_to_uint64_int(double x);</samp></p>
</div>
<div class="section" id="TO_INT32_CEIL"><a name="TO_INT32_CEIL"><!-- --></a><h2 class="sectiontitle"> to_int32_ceil/ to_uint32_ceil / to_int64_ceil / to_uint64_ceil</h2><p><strong>Description:</strong> This function rounds floating-point number to the nearest integral value in the specified integer format toward positive infinity, without signaling the inexact exception.</p>
<p><strong>Calling interface:</strong><br><samp class="codeph">int __binary32_to_int32_ceil(float x);</samp><br><samp class="codeph">int __binary64_to_int32_ceil(double x);</samp><br><samp class="codeph">unsigned int __binary32_to_uint32_ceil(float x);</samp><br><samp class="codeph">unsigned int __binary64_to_uint32_ceil(double x);</samp><br><samp class="codeph">long long int __binary32_to_int64_ceil(float x);</samp><br><samp class="codeph">long long int __binary64_to_int64_ceil(double x);</samp><br><samp class="codeph">unsigned long long int __binary32_to_uint64_ceil(float x);</samp><br><samp class="codeph">unsigned long long int __binary64_to_uint64_ceil(double x);</samp></p>
</div>
<div class="section" id="TO_INT32_FLOOR"><a name="TO_INT32_FLOOR"><!-- --></a><h2 class="sectiontitle"> to_int32_floor/ to_uint32_floor / to_int64_floor / to_uint64_floor</h2><p><strong>Description:</strong> This function rounds floating-point number to the nearest integral value in the specified integer format toward negative infinity, without signaling the inexact exception.</p>
<p><strong>Calling interface:</strong><br><samp class="codeph">int __binary32_to_int32_floor(float x);</samp><br><samp class="codeph">int __binary64_to_int32_floor(double x);</samp><br><samp class="codeph">unsigned int __binary32_to_uint32_floor(float x);</samp><br><samp class="codeph">unsigned int __binary64_to_uint32_floor(double x);</samp><br><samp class="codeph">long long int __binary32_to_int64_floor(float x);</samp><br><samp class="codeph">long 
long int __binary64_to_int64_floor(double x);</samp><br><samp class="codeph">unsigned long long int __binary32_to_uint64_floor(float x);</samp><br><samp class="codeph">unsigned long long int __binary64_to_uint64_floor(double x);</samp></p>
</div>
<div class="section" id="TO_INT32_RNINTA"><a name="TO_INT32_RNINTA"><!-- --></a><h2 class="sectiontitle"> to_int32_rninta / to_uint32_rninta / to_int64_rninta / to_uint64_rninta</h2><p><strong>Description:</strong> This function rounds floating-point number to the nearest integral value in the specified integer format, with halfway cases rounded away from zero, without signaling the inexact exception.</p>
<p><strong>Calling interface:</strong><br><samp class="codeph">int __binary32_to_int32_rninta(float x);</samp><br><samp class="codeph">int __binary64_to_int32_rninta(double x);</samp><br><samp class="codeph">unsigned int 
__binary32_to_uint32_rninta(float x);</samp><br><samp class="codeph">unsigned int __binary64_to_uint32_rninta(double x);</samp><br><samp class="codeph">long long int __binary32_to_int64_rninta(float x);</samp><br><samp class="codeph">long long int __binary64_to_int64_rninta(double x);</samp><br><samp class="codeph">unsigned long long int __binary32_to_uint64_rninta(float x);</samp><br><samp class="codeph">unsigned long long int __binary64_to_uint64_rninta(double x);</samp></p>
</div>
<div class="section" id="TO_INT32_XRNINT"><a name="TO_INT32_XRNINT"><!-- --></a><h2 class="sectiontitle"> to_int32_xrnint / to_uint32_xrnint / to_int64_xrnint / to_uint64_xrnint</h2><p><strong>Description:</strong> This function rounds floating-point number to the nearest integral value in the specified integer format, with halfway cases rounded to even, signaling if inexact.</p>
<p><strong>Calling interface:</strong><br><samp class="codeph">int __binary32_to_int32_xrnint(float x);</samp><br><samp class="codeph">int __binary64_to_int32_xrnint(double x);</samp><br><samp class="codeph">unsigned int __binary32_to_uint32_xrnint(float x);</samp><br><samp class="codeph">unsigned int __binary64_to_uint32_xrnint(double x);</samp><br><samp class="codeph">long long int __binary32_to_int64_xrnint(float x);</samp><br><samp class="codeph">long long int __binary64_to_int64_xrnint(double x);</samp><br><samp class="codeph">unsigned long long int __binary32_to_uint64_xrnint(float x);</samp><br><samp class="codeph">unsigned long long int __binary64_to_uint64_xrnint(double x);</samp></p>
</div>
<div class="section" id="TO_INT32_XINT"><a name="TO_INT32_XINT"><!-- --></a><h2 class="sectiontitle"> to_int32_xint / to_uint32_xint / to_int64_xint / to_uint64_xint</h2><p><strong>Description:</strong> This function rounds floating-point number to the nearest integral value in the specified integer format toward zero, signaling if inexact.</p>
<p><strong>Calling interface:</strong><br><samp class="codeph">int __binary32_to_int32_xint(float x);</samp><br><samp class="codeph">int __binary64_to_int32_xint(double x);</samp><br><samp class="codeph">unsigned int __binary32_to_uint32_xint(float x);</samp><br><samp class="codeph">unsigned int __binary64_to_uint32_xint(double x);</samp><br><samp class="codeph">long long int __binary32_to_int64_xint(float x);</samp><br><samp class="codeph">long long int __binary64_to_int64_xint(double x);</samp><br><samp class="codeph">unsigned long long int __binary32_to_uint64_xint(float x);</samp><br><samp class="codeph">unsigned long long int __binary64_to_uint64_xint(double x);</samp></p>
</div>
<div class="section" id="TO_INT32_XCEIL"><a name="TO_INT32_XCEIL"><!-- --></a><h2 class="sectiontitle"> to_int32_xceil / to_uint32_xceil / to_int64_xceil / to_uint64_xceil</h2><p><strong>Description:</strong> This function rounds floating-point number to the nearest integral value in the specified integer format toward positive infinity, signaling if inexact.</p>
<p><strong>Calling interface:</strong><br><samp class="codeph">int __binary32_to_int32_xceil(float x);</samp><br><samp class="codeph">int __binary64_to_int32_xceil(double x);</samp><br><samp class="codeph">unsigned int __binary32_to_uint32_xceil(float x);</samp><br><samp class="codeph">unsigned int __binary64_to_uint32_xceil(double x);</samp><br><samp class="codeph">long long int __binary32_to_int64_xceil(float x);</samp><br><samp class="codeph">long long int __binary64_to_int64_xceil(double x);</samp><br><samp class="codeph">unsigned long long int __binary32_to_uint64_xceil(float x);</samp><br><samp class="codeph">unsigned long long int __binary64_to_uint64_xceil(double x);</samp></p>
</div>
<div class="section" id="TO_INT32_XFLOOR"><a name="TO_INT32_XFLOOR"><!-- --></a><h2 class="sectiontitle"> to_int32_xfloor / to_uint32_xfloor / to_int64_xfloor / to_uint64_xfloor</h2><p><strong>Description:</strong> This function rounds floating-point number to the nearest integral value in the specified integer format toward negative infinity, signaling if inexact.</p>
<p><strong>Calling interface:</strong><br><samp class="codeph">int __binary32_to_int32_xfloor(float x);</samp><br><samp class="codeph">int __binary64_to_int32_xfloor(double x);</samp><br><samp class="codeph">unsigned int __binary32_to_uint32_xfloor(float x);</samp><br><samp class="codeph">unsigned int __binary64_to_uint32_xfloor(double x);</samp><br><samp class="codeph">long long int __binary32_to_int64_xfloor(float x);</samp><br><samp class="codeph">long long int __binary64_to_int64_xfloor(double x);</samp><br><samp class="codeph">unsigned long long int __binary32_to_uint64_xfloor(float x);</samp><br><samp class="codeph">unsigned long long int __binary64_to_uint64_xfloor(double x);</samp></p>
</div>
<div class="section" id="TO_INT32_XRNINTA"><a name="TO_INT32_XRNINTA"><!-- --></a><h2 class="sectiontitle">  to_int32_xrninta / to_uint32_xrninta / to_int64_xrninta / to_uint64_xrninta</h2><p><strong>Description:</strong> This function rounds floating-point number to the nearest integral value in the specified integer format, with halfway cases rounded away from zero, signaling if inexact.</p>
<p><strong>Calling interface:</strong><br><samp class="codeph">int __binary32_to_int32_xrninta(float x);</samp><br><samp class="codeph">int __binary64_to_int32_xrninta(double x);</samp><br><samp class="codeph">unsigned int __binary32_to_uint32_xrninta(float x);</samp><br><samp class="codeph">unsigned int __binary64_to_uint32_xrninta(double x);</samp><br><samp class="codeph">long long int __binary32_to_int64_xrninta(float x);</samp><br><samp class="codeph">long long int __binary64_to_int64_xrninta(double x);</samp><br><samp class="codeph">unsigned long long int __binary32_to_uint64_xrninta(float x);</samp><br><samp class="codeph">unsigned long long int __binary64_to_uint64_xrninta(double x);</samp></p>
</div>
<div class="section" id="BINARY32_TO_BINARY64"><a name="BINARY32_TO_BINARY64"><!-- --></a><h2 class="sectiontitle"> binary32_to_binary64</h2><p><strong>Description:</strong> This function converts floating-point number in binary32 format to binary64 format.</p>
<p><strong>Calling interface:</strong><br><samp class="codeph">double __binary32_to_binary64(float x);</samp></p>
</div>
<div class="section" id="BINARY64_TO_BINARY32"><a name="BINARY64_TO_BINARY32"><!-- --></a><h2 class="sectiontitle"> binary64_to_binary32</h2><p><strong>Description:</strong> This function rounds floating-point number in binary64 format to binary32 format.</p>
<p><strong>Calling interface:</strong><br><samp class="codeph">float __binary64_to_binary32(double x);</samp></p>
</div>
<div class="section" id="FROM_STRING"><a name="FROM_STRING"><!-- --></a><h2 class="sectiontitle"> from_string</h2><p><strong>Description:</strong> This function converts decimal character sequence to floating-point number.</p>
<p><strong>Calling interface:</strong><br><samp class="codeph">float __binary32_from_string(char * s);</samp><br><samp class="codeph">double __binary64_from_string(char * s);</samp></p>
</div>
<div class="section" id="TO_STRING"><a name="TO_STRING"><!-- --></a><h2 class="sectiontitle"> to_string</h2><p><strong>Description:</strong> This function converts floating-point number to decimal character sequence.</p>
<p><strong>Calling interface:</strong><br><samp class="codeph">char *__binary32_to_string(float x);</samp><br><samp class="codeph">char *__binary64_to_string(double x);</samp></p>
</div>
<div class="section" id="FROM_HEXSTRING"><a name="FROM_HEXSTRING"><!-- --></a><h2 class="sectiontitle"> from_hexstring</h2><p><strong>Description:</strong> This function converts hexadecimal character sequence to floating-point number.</p>
<p><strong>Calling interface:</strong><br><samp class="codeph">float __binary32_from_hexstring(char * s);</samp><br><samp class="codeph">double __binary64_from_hexstring(char * s);</samp></p>
</div>
<div class="section" id="TO_HEXSTRING"><a name="TO_HEXSTRING"><!-- --></a><h2 class="sectiontitle"> to_hexstring</h2><p><strong>Description:</strong> This function converts floating-point number to hexadecimal character sequence.</p>
<p><strong>Calling interface:</strong><br><samp class="codeph">char *__binary32_to_hexstring(float x);</samp><br><samp class="codeph">char *__binary64_to_hexstring(double x);</samp></p>
</div>
</div>


<div class="familylinks">
<div class="parentlink"><strong>Parent topic:</strong>&nbsp;<a href="GUID-BCBC835E-526E-4C9D-A82C-25CAF9108E0A.htm">Function List</a></div>
</div>
<div><br clear="all">
<div class="docfeedback">
<div><a href="http://www.intel.com/software/products/softwaredocs_feedback" target="_blank">Submit feedback on this help topic 
		  </a></div></div></div>
</body>
</html>
