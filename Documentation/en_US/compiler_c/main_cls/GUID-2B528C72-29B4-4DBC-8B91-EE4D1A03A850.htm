<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<!-- saved from url=(0014)about:internet -->
<html xmlns:MSHelp="http://www.microsoft.com/MSHelp/" lang="en-us" xml:lang="en-us"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<meta name="DC.Type" content="OptionRef">
<meta name="DC.Title" content="vector">
<meta name="abstract" content="Indicates to the compiler that the loop should be vectorized according to the argument keywords always/aligned/assert/unaligned/nontemporal/temporal.">
<meta name="description" content="Indicates to the compiler that the loop should be vectorized according to the argument keywords always/aligned/assert/unaligned/nontemporal/temporal.">
<meta name="DC.subject" content="pragma vector, always, aligned, assert, unaligned, nontemporal, temporal">
<meta name="keywords" content="pragma vector, always, aligned, assert, unaligned, nontemporal, temporal">
<meta name="DC.Relation" scheme="URI" content="GUID-C2D70038-AED3-4E15-9B1A-0D9C24D9D714.htm">
<meta name="DC.Relation" scheme="URI" content="http://www.intel.com/software/products/softwaredocs_feedback">
<meta name="DC.Format" content="XHTML">
<meta name="DC.Identifier" content="GUID-2B528C72-29B4-4DBC-8B91-EE4D1A03A850">
<meta name="DC.Language" content="en-US">
<link rel="stylesheet" type="text/css" href="intel_css_styles.css">
<title>vector</title>
<xml>
<MSHelp:Attr Name="DocSet" Value="Intel"></MSHelp:Attr>
<MSHelp:Attr Name="Locale" Value="kbEnglish"></MSHelp:Attr>
<MSHelp:Keyword Index="F" Term="cppref_pragma_vector"></MSHelp:Keyword>
<MSHelp:Attr Name="TopicType" Value="kbReference"></MSHelp:Attr>
</xml>
</head>
<body id="GUID-2B528C72-29B4-4DBC-8B91-EE4D1A03A850">
 <!-- ==============(Start:NavScript)================= -->
 <script src="NavScript.js" language="JavaScript1.2" type="text/javascript"></script>
 <script language="JavaScript1.2" type="text/javascript">WriteNavLink(0);</script>
 <!-- ==============(End:NavScript)================= -->
<p id="header_text" style="margin-bottom : 20pt"><em>Intel&reg; C++ Compiler XE 13.1 User and Reference Guides</em></p>



<h1 class="topictitle1"><span>vector </span></h1>

<!--Indicates to the compiler that the loop should be vectorized according to the argument keywords always/aligned/assert/unaligned/nontemporal/temporal.-->
<div><p>Indicates to the compiler that the loop should be vectorized according to the argument keywords always/aligned/assert/unaligned/nontemporal/temporal.</p>

<div class="section" id="GUID-0812F737-DF06-4064-B8E0-A37521D16AA6"><h2>Syntax</h2>
  <table cellspacing="0" cellpadding="1" border="0" width="85%" class="syntaxdiagramtbl" style="border-spacing:0; border-collapse:collapse"><tr><td valign="top" class="noborder" width="100%"><p><span class="kwd">#pragma vector {always[assert]|aligned|unaligned|temporal|nontemporal|[no]vecremainder}</span></p></td></tr></table>
<table cellspacing="0" cellpadding="1" border="0" width="85%" class="syntaxdiagramtbl" style="border-spacing:0; border-collapse:collapse"><tr><td valign="top" class="noborder" width="100%"><p><span class="kwd">#pragma vector nontemporal</span><span class="delim">[</span><span class="delim">(</span><span class="var">var1</span><span class="sep">[, </span><span class="var">var2</span><span class="sep">,</span><span class="var"> ...</span><span class="delim">])</span><span class="delim">]</span></p></td></tr></table></div>


<div class="section" id="GUID-7525C79A-3329-48CC-844B-24B7D3790CE0"><h2>Arguments</h2>
  <table cellspacing="0" cellpadding="4" border="0" width="90%" style="border-spacing:0; border-collapse:collapse">
    <tr>
      <td valign="top" width="30%" class="noborder"><p><var>always</var></p></td>

      <td valign="top" class="noborder"><p>instructs the compiler to override any efficiency heuristic during the decision to vectorize or not, and vectorize non-unit strides or very unaligned memory accesses; controls the vectorization of the subsequent loop in the program; optionally takes the keyword assert</p>
</td>

    </tr>
    <tr>
      <td valign="top" width="30%" class="noborder"><p><var>aligned</var></p></td>

      <td valign="top" class="noborder"><p>instructs the compiler to use aligned data movement instructions for all array references when vectorizing</p>
</td>

    </tr>
    <tr>
      <td valign="top" width="30%" class="noborder"><p><var>unaligned</var></p></td>

      <td valign="top" class="noborder"><p>instructs the compiler to use unaligned data movement instructions for all array references when vectorizing</p>
</td>

    </tr>
    <tr>
      <td valign="top" width="30%" class="noborder"><p><var>nontemporal</var></p></td>

      <td valign="top" class="noborder"><p>directs the compiler to use non-temporal (that is, streaming) stores on systems based on all supported architectures, unless otherwise specified; optionally takes a comma separated list of variables</p>
<p>On systems based on Intel&reg; MIC Architecture, directs the compiler to generate <samp class="codeph">clevict</samp> (cache-line-evict) instructions after the stores based on the non-temporal pragma when the compiler knows that the store addresses are aligned; optionally takes a comma separated list of variables</p>
</td>

    </tr>
    <tr>
      <td valign="top" width="30%" class="noborder"><p><var>temporal</var></p></td>

      <td valign="top" class="noborder"><p>directs the compiler to use temporal (that is, non-streaming) stores on systems based on all supported architectures, unless otherwise specified</p>
</td>

    </tr>
<tr>
      <td valign="top" width="30%" class="noborder"><p><var> vecremainder</var></p></td>

      <td valign="top" class="noborder"><p> instructs the compiler to vectorize the remainder loop when the original loop is vectorized</p>
</td>

    </tr>
  <tr>
      <td valign="top" width="30%" class="noborder"><p><var> novecremainder</var></p></td>

      <td valign="top" class="noborder"><p> instructs the compiler not to vectorize the remainder loop when the original loop is vectorized</p>
</td>

    </tr>
</table>

</div>


<div class="section" id="GUID-E069ACEC-5489-4C90-8947-7C27939E27B5"><h2>Description</h2>
<p>The <span class="keyword">vector</span> pragma indicates that the loop should be vectorized, if it is legal to do so, ignoring normal heuristic decisions about profitability. The <span class="keyword">vector</span> pragma takes several argument keywords to specify the kind of loop vectorization required. These keywords are aligned, unaligned, always, temporal, and nontemporal. The compiler does not apply the vector pragma to nested loops, each nested loop needs a preceding pragma statement. Place the pragma before the loop control statement.</p>



<p><strong>Using <samp class="codeph"><span class="keyword">aligned/unaligned</span></samp> keywords</strong></p>

<p>When the <span class="keyword">aligned/unaligned</span> argument keyword is used with this pragma, it indicates that the loop should be vectorized using aligned/unaligned data movement instructions for all array references. Specify only one argument keyword: <span class="keyword">aligned </span>or <span class="keyword">unaligned.</span></p>

<div class="Note"><h3 class="NoteTipHead">Caution</h3><p>If you specify <span class="keyword">aligned</span> as an argument, you must be sure that the loop is vectorizable using this pragma. Otherwise, the compiler generates incorrect code.</p>
</div>
<p><strong>Using <samp class="codeph">always</samp>
 keyword</strong></p>

<p>When the <span class="keyword">always</span> argument keyword is used, the pragma controls the vectorization of the subsequent loop in the program. If <samp class="codeph">assert</samp> is added, the compiler will generate an
error-level assertion test to display a message saying that the compiler efficiency
heuristics indicate that the loop cannot be vectorized.</p>


<p><strong>Using <samp class="codeph">nontemporal/temporal</samp>
 keywords</strong></p>

<p>The <span class="keyword">nontemporal</span> and <span class="keyword">temporal</span> argument keywords are used to control how the "stores" of register contents to storage are performed (streaming versus non-streaming) on systems based on IA-32 and Intel&reg; 64 architectures. </p>

<p> On systems based on Intel&reg; MIC Architecture, <span class="keyword">#pragma vector nontemporal</span> directs the compiler to generate <samp class="codeph">clevict</samp> (cache-line-evict) instructions after the stores based on the non-temporal pragma when the compiler knows that the store addresses are aligned; optionally takes a comma separated list of variables</p>
<p>By default, the compiler automatically determines whether a streaming store should be used for each variable.</p>

<p>Streaming stores may cause significant performance improvements over non-streaming stores for large numbers on certain processors. However, the misuse of streaming stores can significantly degrade performance.</p>

<p><strong>Using  <samp class="codeph">[no]vecremainder</samp></strong></p>
<p> If #pragma <samp class="codeph">vector
always</samp> is specified, the following
occurs:</p>
<p> If the vecremainder clause is specified, the compiler vectorizes both the main and remainder loops.</p>


<p> If the novecremainder clause is specified, the compiler vectorizes the main
loop, but it does not vectorize the remainder loop.</p>





<div class="Note"><h3 class="NoteTipHead">Note</h3><p>The pragma <span class="keyword">vector{always|aligned|unaligned}</span> should be used with care. Overriding the efficiency heuristics of the compiler should only be done if the programmer is absolutely sure that vectorization will improve performance. Furthermore, instructing the compiler to implement all array references with aligned data movement instructions will cause a run-time exception in case some of the access patterns are actually unaligned.</p>
</div></div>


<div class="section" id="GUID-E094687D-9371-4258-92B0-D88A8835F1CD"><h2>Example</h2>
<p><strong>Example 1: Using pragma vector aligned</strong></p>

<p>The loop in the following example uses the <span class="keyword">aligned</span> argument keyword to request that the loop be vectorized with aligned instructions, as the arrays are declared in such a way that the compiler could not normally prove this would be safe to do so.</p>


<pre>void vec_aligned(float *a, int m, int c)</pre>
<pre>{</pre>
<pre>&nbsp;&nbsp;int i;</pre>
<pre>&nbsp;&nbsp;// Instruct compiler to ignore assumed vector dependencies.</pre>
<pre>&nbsp;&nbsp;#pragma vector aligned</pre>
<pre>&nbsp;&nbsp;for (i = 0; i &lt; m; i++)</pre>
<pre>&nbsp;&nbsp;&nbsp;&nbsp;a[i] = a[i] * c;</pre>
<pre>&nbsp;&nbsp;// Alignment unknown but compiler can still align.</pre>
<pre>&nbsp;&nbsp;for (i = 0; i &lt; 100; i++)</pre>
<pre>&nbsp;&nbsp;&nbsp;&nbsp;a[i] = a[i] + 1.0f;</pre>
<pre>}</pre>

<p><strong>Example 2: Using pragma
vector always </strong></p>

<p>The following example illustrates how to use the <span class="keyword">vector always</span> pragma. </p>


<pre>void vec_always(int *a, int *b, int m)</pre>
<pre>{</pre>
<pre>&nbsp;&nbsp;#pragma vector always</pre>
<pre>&nbsp;&nbsp;for(int i = 0; i &lt;= m; i++)</pre>
<pre>&nbsp;&nbsp;&nbsp;&nbsp;a[32*i] = b[99*i];</pre>
<pre>}</pre>

<p><strong>Example 3a: Using pragma
vector nontemporal </strong></p>

<p>A float-type loop together with the generated assembly is shown in the following example. For large <var>N</var>, significant performance improvements result on Pentium 4 systems over a non-streaming implementation.</p>


<pre>float a[1000];</pre>
<pre>void foo(int N){</pre>
<pre>&nbsp;&nbsp;int i;</pre>
<pre>&nbsp;&nbsp;#pragma vector nontemporal</pre>
<pre>&nbsp;&nbsp;for (i = 0; i &lt; N; i++) {</pre>
<pre>&nbsp;&nbsp;&nbsp;&nbsp;a[i] = 1;</pre>
<pre>&nbsp;&nbsp;}</pre>
<pre>}</pre>

<p><strong>Example 3b: Using ASM code for the loop body</strong></p>


<pre>&nbsp;&nbsp;.B1.2:</pre>
<pre>movntps XMMWORD PTR _a[eax], xmm0 </pre>
<pre>movntps XMMWORD PTR _a[eax+16], xmm0 </pre>
<pre>add eax, 32 </pre>
<pre>cmp eax, 4096 </pre>
<pre>jl .B1.2</pre>

<p><strong>Example 4: Using pragma vector nontemporal with variables</strong></p>

<p>The following example illustrates how to use the <samp class="codeph">#pragma vector nontemporal</samp> with variables for implementing streaming stores.</p>


<pre>double A[1000];</pre>
<pre>double B[1000];</pre>
<pre>void foo(int n){</pre>
<pre>&nbsp;&nbsp;int i;</pre>
<pre>#pragma vector nontemporal (A, B)</pre>
<pre>&nbsp;&nbsp;for (i=0; i&lt;n; i++){</pre>
<pre>&nbsp;&nbsp;&nbsp;&nbsp;A[i] = 0;</pre>
<pre>&nbsp;&nbsp;&nbsp;&nbsp;B[i] = i;</pre>
<pre>&nbsp;&nbsp;}</pre>
<pre>}</pre>

</div>


</div>


<div class="familylinks">
<div class="parentlink"><strong>Parent topic:</strong>&nbsp;<a href="GUID-C2D70038-AED3-4E15-9B1A-0D9C24D9D714.htm">Intel-Specific Pragma Reference</a></div>
</div>
<div><br clear="all">
<div class="docfeedback">
<div><a href="http://www.intel.com/software/products/softwaredocs_feedback" target="_blank">Submit feedback on this help topic 
		  </a></div></div></div>

</body>
</html>
