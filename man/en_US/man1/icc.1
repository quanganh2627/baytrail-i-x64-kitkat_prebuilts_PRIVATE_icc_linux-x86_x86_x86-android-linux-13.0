Intel Compiler Man Page Content
.\" .\" *********************************************************************
.\" .\" *                                                                   *
.\" .\" *             Copyright 2005\-2012, Intel Corporation               *
.\" .\" *                                                                   *
.\" .\" *                       All Rights Reserved.                        *
.\" .\" *                                                                   *
.\" .\" *********************************************************************
.TH  ICC 1 "Intel Corporation" "Copyright(C) 1996 \- 2013" "Intel(R) C++ Compiler XE Options"
.PP
icc \- invokes the Intel(R) C Compiler 
.NL
.PP
icpc \- invokes the Intel(R) C++ Compiler 
.NL
.SH SYNOPSIS
.PP
ic<p>c [options] file1 [file2 ...] 
.NL
.PP
where: 
.IP \(bu 2
options represents zero or more compiler options. 
.IP \(bu 2
fileN represents a C/C++ source (.C, .c, .cc, .cp, .cpp, .cxx, .c++, .i), assembly (.s), object (.o), static library (.a), or other linkable file. 
.NL
.PP
.B NOTE:
The icpc command uses the same compiler options as the icc command. Invoking the compiler using icpc compiles .c and .i files as C++. Invoking the compiler using icc compiles .c and .i files as C. Using icpc always links in C++ libraries. Using icc only links in C++ libraries if C++ source is provided on the command line. 
.SH Description \- icc
.PP
The Intel(R) C++ Compiler XE is designed to process C and C++ programs on Intel(R) architecture based systems. You can preprocess, compile, assemble, and link these programs. 
.PP
This document explains how information and instructions apply differently to 
Intel(R) Many Integrated Core Architecture (Intel(R) MIC Architecture), 
Intel(R) 64 architecture, and IA\-32 architecture. If a description does not explicitly state a specific architecture, assume the description is applicable to all. See the Intel(R) C++ Compiler XE Documentation for more detailed information than what is presented here. 
.PP
This man page is intended for Linux* OS and OS X* users. 
.PP
Most language features are available on all supported systems; however, some language features are only available on certain processors or a certain operating system. Such language features are labeled within parenthesis as follows: 
.PP
.TP 18
i32 
.NL
Means the feature is available on IA\-32 architecture. 
.TP 18
i64em 
.NL
Means the feature is available on systems using Intel(R) 64 architecture and Intel(R) MIC Architecture. . 
.TP 18
L*X 
.NL
Means the feature is available on Linux* OS systems. 
.TP 18
M*X 
.NL
Means the feature is available on all Intel(R)\-based systems running OS X*. In a few circumstances, the underlying architecture has bearing, so in those cases: 
.RS
.TP 15
M*X32 
\-\- Means the feature is available on systems based on IA\-32 architecture that are running OS X*. 
.TP 15
M*X64 
\-\- Means the feature is available on systems using Intel(R) 64 architecture that are running OS X*. 
.RE
.PP
If a labeled feature is only available on one processor or one operating system, you will see the word "only" within the label. If no label appears, the language feature is available on all supported systems. 
.PP
For example, option 
\-Bstatic is labeled (L*X only), which means the option is not available on OS X* systems; it is only available on Linux* OS systems. 
.SS  GNU* gcc Interoperability
.PP
C++ compilers are interoperable if they can link object files and libraries generated by one compiler with object files and libraries generated by the second compiler, and the resulting executable runs successfully. Some GNU* gcc versions are not interoperable, some versions are interoperable. By default, the Intel compiler will generate code that is interoperable with the version of gcc it finds on your system. 
.NL
.PP
The Intel(R) C++ Compiler options that affect GNU* gcc interoperability include: 
.IP \(bu 2
\-cxxlib
.IP \(bu 2
\-gcc\-name
.IP \(bu 2
\-gcc\-version
.IP \(bu 2
\-gxx\-name
.IP \(bu 2
\-fabi\-version
.IP \(bu 2
\-no\-gcc (see gcc Predefined Macros for more information) 
.NL
.PP
The Intel(R) C++ Compiler is interoperable with GNU* gcc compiler versions greater than or equal to 3.2. See the Intel(R) C++ Compiler Documentation for more information. 
.NL
.SH OPTIONS
.SS Option Alphabetic Summary
.PP
This section includes an alphabetic listing of available Intel(R) C++ Compiler options. 
.NL
.PP
After each listing is a reference to the Functional area where a detailed description of the option appears. See Deprecated and Removed Options for additional information. 
.NL
.TP
.B
\-Aname[(value)]
.RS
.TP
Specifies an identifier for an assertion. 
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.TP 18
name
.NL
Is the identifier for the assertion.
.TP 18
value
.NL
Is an optional value for the assertion. If a value is specified, it must be within quotes, including the parentheses delimiting it.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
Assertions have no identifiers or symbol names.
.TP
\fBDescription:\fR 
.PP
This option specifies an identifier (symbol name) for an assertion. It is equivalent to an #assert preprocessing directive.
.NL
.PP
Note that this option is not the positive form of the C++ /QA\- option.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-alias\-const
.TP
.B
\-no\-alias\-const
.RS
.TP
Determines whether the compiler assumes a parameter of type pointer\-to\-const does not alias with a parameter of type pointer\-to\-non\-const.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-no\-alias\-const 
.NL
The compiler uses standard C/C++ rules for the interpretation of const.
.TP
\fBDescription:\fR 
.PP
This option determines whether the compiler assumes a parameter of type pointer\-to\-const does not alias with a parameter of type pointer\-to\-non\-const. It implies an additional attribute for const. 
.NL
.PP
This functionality complies with the input/output buffer rule, which assumes that input and output buffer arguments do not overlap.  This option allows the compiler to do some additional optimizations with those parameters.
.NL
.PP
In C99, you can also get the same result if you additionally declare your pointer parameters with the restrict keyword.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-align
.TP
.B
\-noalign
.RS
.TP
Determines whether variables and arrays are naturally aligned. 
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
Variables and arrays are aligned according to the gcc model, which means they are aligned to 4\-byte boundaries.
.TP
\fBDescription:\fR 
.PP
This option determines whether variables and arrays are naturally aligned. Option \-align forces the following natural alignment:
.NL
.TP 18
\fBType\fR
.NL
.NL
\fBAlignment\fR
.NL
.NL
.TP 18
double
.NL
8 bytes
.NL
.TP 18
long long
.NL
8 bytes
.NL
.TP 18
long double
.NL
16 bytes
.NL
.PP
If you are not interacting with system libraries or other libraries that are compiled without \-align, this option can improve performance by reducing misaligned accesses. 
.NL
.PP
.B CAUTION:
If you are interacting with system libraries or other libraries that are compiled without \-align, your application may not perform as expected.
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-ansi
.TP
.B
.RS
.TP
Enables language compatibility with the gcc option ansi.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
GNU C++ is more strongly supported than ANSI C.
.TP
\fBDescription:\fR 
.PP
This option enables language compatibility with the gcc option \-ansi and provides the same level of ANSI standard conformance as that option.
.NL
.PP
This option sets option fmath\-errno.
.NL
.PP
If you want strict ANSI conformance, use the \fI\-strict\-ansi\fR option.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-ansi\-alias
.TP
.B
\-no\-ansi\-alias
.RS
.TP
Enable use of ANSI aliasing rules in optimizations.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-no\-ansi\-alias
.NL
Disable use of ANSI aliasing rules in optimizations.
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to assume that the program adheres to ISO C Standard aliasability rules.
.NL
.PP
If your program adheres to these rules, then this option allows the compiler to optimize more aggressively. If it doesn\[aq]t adhere to these rules, then it can cause the compiler to generate incorrect code. 
.NL
.PP
When you specify \-ansi\-alias or /Qansi\-alias, the ansi\-alias checker is enabled by default. 
To disable 
the ansi\-alias checker, you must specify 
\-no\-ansi\-alias\-check  (Linux OS and OS X)
or /Qansi\-alias\-check\- (Windows OS).
.NL
.TP
\fBAlternate Options:\fR 
.PP
Linux and OS X: \-fstrict\-aliasing
.NL
.PP
Windows: None
.NL
.RE
.TP
.B
\-ansi\-alias\-check
.TP
.B
\-no\-ansi\-alias\-check
.RS
.TP
Enables or disables the ansi\-alias checker.
.NL
.TP
\fBArchitectures:\fR IA\-32, Intel(R) 64 architecture
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-no\-ansi\-alias\-check
.NL
The ansi\-alias checker is disabled unless option \-ansi\-alias\-check or  /Qansi\-alias\-check
has been specified.
.TP
\fBDescription:\fR 
.PP
This option enables or disables the ansi\-alias checker.  The ansi\-alias checker checks the source code 
for potential violations of ANSI aliasing rules and disables unsafe optimizations related to the code 
for those statements that are identified as potential violations.
.NL
.PP
You can use option –Wstrict\-aliasing to identify potential violations.
.NL
.PP
If option \-ansi\-alias  (Linux OS and OS X)
or /Qansi\-alias  (Windows OS) 
has been specified, the ansi\-alias checker is enabled by default. 
You can use option \-no\-ansi\-alias\-check or /Qansi\-alias\-check\- to disable the 
checker.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-auto\-ilp32
.RS
.TP
Instructs the compiler to analyze the program to determine if there are 64\-bit pointers that can be safely shrunk into 32\-bit pointers  and if there are 64\-bit longs (on Linux* OS) that can be safely shrunk into 32\-bit longs.
.NL
.TP
\fBArchitectures:\fR Intel(R) 64 architecture
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The optimization is not attempted.
.TP
\fBDescription:\fR 
.PP
This option instructs the compiler to analyze the program to determine if there are 64\-bit pointers that can be safely shrunk into 32\-bit pointers  and if there are 64\-bit longs (on Linux* OS) that can be safely shrunk into 32\-bit longs.
.NL
.PP
For this option to be effective, the compiler must be able to optimize using the \-ipo  (Linux OS and OS X)
or /Qipo (Windows OS) option and must be able to analyze all library calls or external calls the program makes. This option has no effect on Linux* systems unless you specify setting SSE3 or higher for option \-x (Linux and OS X).
.NL
.PP
This option requires that the size of the program executable never exceeds 232 bytes and all data values can be represented within 32 bits. If the program can run correctly in a 32\-bit system, these requirements are implicitly satisfied. If the program violates these size restrictions, unpredictable behavior may occur.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-auto\-p32 (L*X only)
.RS
.TP
Instructs the compiler to analyze the program to determine if there are 64\-bit pointers that can be safely shrunk to 32\-bit pointers.
.NL
.TP
\fBArchitectures:\fR Intel(R) 64 architecture
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The optimization is not performed.
.TP
\fBDescription:\fR 
.PP
This option instructs the compiler to analyze
and transform the program so that 64\-bit pointers are shrunk to
32\-bit pointers, wherever it is legal and safe to do so.
.NL
.PP
For this option to be effective, the compiler
must be able to optimize using the \-ipo  option and it must be able to analyze all
library calls or external calls the program makes. This option has no effect unless you specify setting SSE3 or higher for option \-x.
.NL
.PP
The application cannot exceed a 32\-bit address
space; otherwise, unpredictable results can occur.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-axcode
.RS
.TP
Tells the compiler to generate multiple, feature\-specific auto\-dispatch code paths for Intel(R) processors if there is a performance benefit. 
.NL
.TP
\fBArchitectures:\fR IA\-32, Intel(R) 64 architecture
.TP
\fBArguments:\fR 
.TP 18
\fIcode\fR
.NL
Indicates to the compiler a feature set that it may target, including which instruction sets it may generate. The following descriptions refer to Intel(R) Streaming SIMD Extensions (Intel(R) SSE) and Supplemental Streaming SIMD Extensions (SSSE). Possible values are:
.RS
.TP 15
CORE\-AVX2
May generate Intel(R) Advanced Vector Extensions 2 (Intel(R) AVX2), Intel(R) AVX, SSE4.2, SSE4.1, SSE3, SSE2, SSE, and SSSE3 instructions for Intel(R) processors.
.TP 15
CORE\-AVX\-I
May generate Float\-16 conversion instructions and the RDRND instruction, Intel(R) Advanced Vector Extensions (Intel(R) AVX), Intel(R) SSE4.2, SSE4.1, SSE3, SSE2, SSE, and SSSE3 instructions for Intel(R) processors. 
.TP 15
AVX
May generate Intel(R) Advanced Vector Extensions (Intel(R) AVX), Intel(R) SSE4.2, SSE4.1, SSE3, SSE2, SSE, and SSSE3 instructions for Intel(R) processors. 
.TP 15
SSE4.2
May generate Intel(R) SSE4.2, SSE4.1, SSE3, SSE2, SSE, and SSSE3 instructions for Intel processors.
.TP 15
SSE4.1
May generate Intel(R) SSE4.1, SSE3, SSE2, SSE, and SSSE3 instructions for Intel(R) processors.
.TP 15
SSSE3
May generate SSSE3 instructions and  Intel(R) SSE3, SSE2, and SSE instructions for Intel(R) processors. For OS X* systems, this value is only supported on Intel(R) 64
architecture.
This replaces value T, which is deprecated.
.TP 15
SSE3
May generate Intel(R) SSE3, SSE2, and SSE instructions for Intel(R) processors. For OS X* systems, this value is only supported on IA\-32 architecture.
This replaces value P, which is deprecated.
.TP 15
SSE2
May generate Intel(R) SSE2 and SSE instructions for Intel(R) processors. This value is not available on OS X*  systems. This replaces value N, which is  deprecated.
.RE
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
No auto\-dispatch code is generated. Feature\-specific code is generated and is controlled by the setting of compiler options \-m and \-x (Linux* OS) or compiler option \-x (OS X*).
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to generate multiple, feature\-specific auto\-dispatch code paths for Intel(R) processors if there is a performance benefit. It also generates a baseline code path. The Intel feature\-specific auto\-dispatch path is usually more optimized than the baseline path. Other options, such as O3, control how much optimization is performed on the baseline path. 
.NL
.PP
The baseline code path is determined by the architecture specified by options \-m or \-x (Linux* OS and OS X*) or options /arch or /Qx (Windows* OS). While there are defaults for the \-x or /Qx option that depend on the operating system being used, you can specify an architecture and optimization level for the baseline code that is higher or lower than the default. The specified architecture becomes the effective minimum architecture for the baseline code path. 
.NL
.PP
If you specify both the \-ax and \-x options (Linux OS and OS X) or the /Qax and /Qx options (Windows OS), the baseline code will only execute on Intel(R)
processors compatible with the setting specified for the \-x or /Qx option. 
.NL
.PP
If you specify both the \-ax and \-m options (Linux OS) or the /Qax and /arch options (Windows OS), the baseline code will execute on non\-Intel processors compatible with the setting specified for the \-m or /arch option.
.NL
.PP
The \-ax and /Qax options tell the compiler to find opportunities to generate separate versions of functions that take advantage of features of the specified instruction features. 
.NL
.PP
If the compiler finds such an opportunity, it first checks whether generating a feature\-specific version of a function is likely to result in a performance gain. If this is the case, the compiler generates both a feature\-specific version of a function and a baseline version of the function. At run time, one of the versions is chosen to execute, depending on the Intel(R) processor in use. In this way, the program can benefit from performance gains on more advanced Intel processors, while still working properly on older processors  and non\-Intel processors. A non\-Intel processor always executes the baseline code path.
.NL
.PP
You can use more than one of the feature values by combining them. For example, you can specify \-axSSE4.1,SSSE3 (Linux OS and OS X) or /QaxSSE4.1,SSSE3 (Windows OS). You cannot combine the old style, deprecated options and the new options. For example, you cannot specify \-axSSE4.1,T (Linux OS and OS X) or /QaxSSE4.1,T (Windows OS). 
.NL
.PP
Previous values W and K are deprecated.  The details on replacements are as follows:
.NL
.IP \(bu 2
OS X systems: On these systems, there is no exact replacement for W or K. You can upgrade to the default option \-msse3 (IA\-32 architecture) or option \-mssse3 (Intel(R) 64 architecture).
.IP \(bu 2
Windows and Linux systems: The replacement for W is \-msse2 (Linux OS) or /arch:SSE2 (Windows OS). There is no exact replacement for K. However, on Windows systems, /QaxK is interpreted as /arch:IA32; on Linux systems,
\-axK is interpreted as \-mia32. You can also do one of the following:  
.RS
.IP \(bu 2
Upgrade to option \-msse2 (Linux OS) or option /arch:SSE2 (Windows OS). This will produce one code path that is specialized for Intel(R) SSE2. It will not run on earlier processors
.IP \(bu 2
Specify the two option combination \-mia32 \-axSSE2 (Linux OS) or /arch:IA32 /QaxSSE2 (Windows OS). This combination will produce an executable that runs on any processor with IA\-32 architecture
but with an additional specialized Intel(R) SSE2 code path.
.RE
.PP
.TP 18
\fBOptimization Notice 
\fR
.NL
.NL
.TP 18
= = = = = = = = = = 
.TP 18
Intel\[aq]s compilers may or may not optimize to the same degree for non\-Intel microprocessors for optimizations that are not unique to Intel microprocessors. These optimizations include SSE2, SSE3, and SSSE3 instruction sets and other optimizations. Intel does not guarantee the availability, functionality, or effectiveness of any optimization on microprocessors not manufactured by Intel. Microprocessor\-dependent optimizations in this product are intended for use with Intel microprocessors. Certain optimizations not specific to Intel microarchitecture are reserved for Intel microprocessors. Please refer to the applicable product User and Reference Guides for more information regarding the specific instruction sets covered by this notice. 
.TP 18
Notice revision #20110804 
.TP 18
= = = = = = = = = = 
.NL
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-Bdir
.RS
.TP
Specifies a directory that can be used to find include files, libraries, and executables.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.TP 18
\fIdir\fR
.NL
Is the directory to be used. If necessary, the compiler adds a directory separator character at the end of \fIdir\fR.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler looks for files in the directories specified in your PATH environment variable.
.TP
\fBDescription:\fR 
.PP
This option specifies a directory that can be used to find include files, libraries, and executables.
.NL
.PP
The compiler uses \fIdir\fR as a prefix.
.NL
.PP
For include files, the \fIdir\fR is converted to \-I/\fIdir\fR/include. This command is added to the front of the includes passed to the preprocessor.
.NL
.PP
For libraries, the \fIdir\fR is converted to \-L/\fIdir\fR. This command is added to the front of the standard \-L inclusions before system libraries are added.
.NL
.PP
For executables, if \fIdir\fR contains the name of a tool, such as ld or as, the compiler will use it instead of those found in the default directories.
.NL
.PP
The compiler looks for include files in \fIdir\fR /include while library files are looked for in \fIdir\fR.
.NL
.PP
Another way to get the behavior of this option is to use the environment variable GCC_EXEC_PREFIX.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-Bdynamic (L*X only)
.RS
.TP
Enables dynamic linking of libraries at run time.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
Limited dynamic linking occurs.
.TP
\fBDescription:\fR 
.PP
This option enables dynamic linking of libraries at run time. Smaller executables are created than with static linking.
.NL
.PP
This option is placed in the linker command line corresponding to its location on the user command line. It controls the linking behavior of any library that is passed using the command line.
.NL
.PP
All libraries on the command line following option \-Bdynamic are linked dynamically until the end of the command line or until a \-Bstatic option is encountered. The \-Bstatic option enables static linking of libraries. 
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-Bstatic (L*X only)
.RS
.TP
Enables static linking of a user\[aq]s library.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
Default static linking occurs.
.TP
\fBDescription:\fR 
.PP
This option enables static linking of a user\[aq]s library.
.NL
.PP
This option is placed in the linker command line corresponding to its location on the user command line. It controls the linking behavior of any library that is passed using the command line.
.NL
.PP
All libraries on the command line following option \-Bstatic are linked statically until the end of the command line or until a \-Bdynamic option is encountered. The \-Bdynamic option enables dynamic linking of libraries.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-Bsymbolic (L*X only)
.RS
.TP
Binds references to all global symbols in a program to the definitions within a user\[aq]s shared library.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
When a program is linked to a shared library, it can override the definition within the shared library.
.TP
\fBDescription:\fR 
.PP
This option binds references to all global symbols in a program to the definitions within a user\[aq]s shared library.
.NL
.PP
This option is only meaningful on Executable Linkage Format (ELF) platforms that support shared libraries.
.NL
.PP
.B CAUTION:
This option can have unintended side\-effects of disabling symbol preemption in the shared library.
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-Bsymbolic\-functions (L*X only)
.RS
.TP
Binds references to all global function symbols in a program to the definitions within a user\[aq]s shared library.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
When a program is linked to a shared library, it can override the definition within the shared library.
.TP
\fBDescription:\fR 
.PP
This option binds references to all global function symbols in a program to the definitions within a user\[aq]s shared library.
.NL
.PP
This option is only meaningful on Executable Linkage Format (ELF) platforms that support shared libraries.
.NL
.PP
.B CAUTION:
This option can have unintended side\-effects of disabling symbol preemption in the shared library.
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-c
.RS
.TP
Prevents linking.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
Linking is performed.
.TP
\fBDescription:\fR 
.PP
This option prevents linking. Compilation stops after the object file is generated.
.NL
.PP
The compiler generates an object file for each C or C++ source file or preprocessed source file. It also takes an assembler file and invokes the assembler to generate an object file.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-C
.RS
.TP
Places comments in preprocessed source output. 
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
No comments are placed in preprocessed source output.
.TP
\fBDescription:\fR 
.PP
This option places (or preserves) comments in preprocessed source output.
.NL
.PP
Comments following preprocessing directives, however, are not preserved.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-check=keyword[, keyword...]
.TP
.B
/check:keyword[, keyword...]
.RS
.TP
Checks for certain conditions at run time.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.TP 18
\fIkeyword\fR
.NL
Specifies the conditions to check. Possible values are:
.RS
.TP 15
[no]conversions
Determines whether checking occurs for converting to smaller types. Keyword conversions enables this checking.
.TP 15
[no]stack
Determines whether checking occurs on the stack frame. Keyword stack enables this checking. If stack is specified, the stack is checked for buffer overruns and buffer underruns. This option also enforces local variables initialization and stack pointer verification.
.TP 15
[no]uninit
Determines whether checking occurs for uninitialized variables. Keyword uninit enables this checking. If a variable is read before it is written, a run\-time error routine will be called.
.RE
.TP
\fBDefault:\fR 
.TP 18
noconversions nostack nouninit
.NL
No checking is performed for the above run\-time conditions.
.TP
\fBDescription:\fR 
.PP
This option checks for certain conditions at
run time.
.NL
.PP
On Windows* OS, this option disables any
default or specified optimizations and applies the /Od level of
optimization. If you specified optimizations, the compiler emits
warning diagnostics for the disabled optimizations.
.NL
.PP
On Linux* OS and OS X*, this option may
disable some optimizations.
.NL
.PP
.B NOTE:
This option requires library support. Depending on the platform, the required library is either in your operating system run\-time environment or in your compiler package.
.TP
\fBAlternate Options:\fR 
.TP 18
check conversions
.NL
Linux and OS X: None
.TP 18
check stack
.NL
Linux and OS X: None
.TP 18
check uninit
.NL
Linux and OS X: None
.RE
.TP
.B
\-check\-pointers=keyword (L*X only)
.RS
.TP
Determines whether the compiler checks bounds for memory access through pointers.
.NL
.TP
\fBArchitectures:\fR IA\-32, Intel(R) 64 architecture
.TP
\fBArguments:\fR 
.TP 18
keyword
.NL
Specifies what type of bounds checking occurs. Possible values are:
.RS
.TP 15
none
Disables bounds checking. This is the default.
.TP 15
rw
Checks bounds for reads and writes through pointers.
.TP 15
write
Checks bounds for only writes through pointers.
.RE
.TP
\fBDefault:\fR 
.TP 18
\-check\-pointers=none or
/Qcheck\-pointers:none
.NL
No bounds checking occurs for memory access through pointers.
.TP
\fBDescription:\fR 
.PP
This option determines whether the compiler checks bounds for memory access through pointers. It enables checking of all indirect accesses through pointers, and all array accesses.
.NL
.PP
The compiler may optimize these checks away when it can determine that an access is safe.
.NL
.PP
When rw or write is specified, option \-check\-pointers\-undimensioned (Linux* OS) or /Qcheck\-pointers\-undimensioned (Windows* OS) is set and dimensioned and undimensioned arrays are checked.  
.NL
.PP
If you do not want undimensioned arrays checked, you must specify option \-no\-check\-pointers\-undimensioned (Linux* OS) or /Qcheck\-pointers\-undimensioned\-\- (Windows* OS).
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-check\-pointers\-dangling=keyword (L*X only)
.RS
.TP
Determines whether the compiler checks for dangling pointer references.
.NL
.TP
\fBArchitectures:\fR IA\-32, Intel(R) 64 architecture
.TP
\fBArguments:\fR 
.TP 18
keyword
.NL
Specifies what type of dangling pointer checking occurs. Possible values are:
.RS
.TP 15
none
Disables checking for dangling pointer references. This is the default.
.TP 15
heap
Checks for dangling pointer references on the heap.
.TP 15
stack
Checks for dangling pointer references on the stack.
.TP 15
all
Checks for dangling pointer references on the heap and the stack.
.RE
.TP
\fBDefault:\fR 
.TP 18
\-check\-pointers\-dangling=none or
/Qcheck\-pointers\-dangling:none
.NL
No checking occurs for dangling pointer references.
.TP
\fBDescription:\fR 
.PP
This option determines whether the
compiler checks for dangling pointer references.
.NL
.PP
To use this option, you must also specify
option \-check\-pointers (Linux* OS) or
/Qcheck\-pointers (Windows* OS). You
must also have Composer XE 2013 and Parallel Studio XE 2013 (or C++
Studio XE 2013) installed on your system.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-check\-pointers\-undimensioned (L*X only)
.TP
.B
\-no\-check\-pointers\-undimensioned (L*X only)
.RS
.TP
Determines whether the compiler checks bounds for memory access through arrays that are declared without dimensions.
.NL
.TP
\fBArchitectures:\fR IA\-32, Intel(R) 64 architecture
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-check\-pointers\-undimensioned or /Qcheck\-pointers\-undimensioned
.NL
Bounds checking occurs for memory access through arrays that are declared without dimensions. This checking occurs for both dimensioned and undimensioned arrays.
.TP
\fBDescription:\fR 
.PP
This option determines whether the compiler checks bounds for memory access through arrays that are declared without dimensions. 
.NL
.PP
To use this option, you must also specify option \-check\-pointers (Linux* OS) or /Qcheck\-pointers (Windows* OS). You must also have Composer XE 2013 and Parallel Studio XE 2013 (or C++ Studio XE 2013) installed on your system.
.NL
.PP
The default setting, \-check\-pointers\-undimensioned (Linux* OS) and /Qcheck\-pointers\-undimensioned (Windows* OS ), can cause link time errors for multiple definitions for non\-standard code and it can cause linker warnings for undefined symbols when linking library code that has not been compiled with pointer checking enabled. In both of these cases, the symbols will contain the string cp_array_end.
.NL
.PP
To prevent these issues, disable the checking of undimensioned arrays, by specifying \-no\-check\-pointers\-undimensioned (Linux OS) or /Qcheck\-pointers\-undimensioned\- (Windows OS).
.NL
.PP
Note that even if you specify \-no\-check\-pointers\-undimensioned or /Qcheck\-pointers\-undimensioned\-, dimensioned arrays are always checked.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-check\-uninit
.TP
.B
\-no\-check\-uninit
.RS
.TP
Determines whether checking occurs for uninitialized variables. This option is deprecated.  It has been replaced with option \-check=uninit.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-no\-check\-uninit
.NL
No checking occurs for uninitialized variables.
.TP
\fBDescription:\fR 
.PP
This option determines whether checking occurs for uninitialized variables. Option \-check\-uninit enables this checking.
.NL
.PP
If a variable is read before it is written, a run\-time error routine will be called. 
.NL
.PP
Run\-time checking of undefined variables is only implemented on local, scalar variables. It is not implemented on dynamically allocated variables, extern variables or static variables. It is not implemented on structs, classes, unions or arrays.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-cilk\-serialize
.RS
.TP
Causes serialization of Intel(R) Cilk(TM) Plus code.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The Intel(R) Cilk(TM) Plus language extensions are recognized.
.TP
\fBDescription:\fR 
.PP
This option causes serialization of code that
contains Intel(R) Cilk(TM) Plus language extensions. This means that the
compiler will run the program as if it were a C/C++ serialized
program.
.NL
.PP
This option forces inclusion of a special
header file (cilk_stub.h) that includes preprocessor macros that
make certain specific keywords that are related to those language
extensions invisible to the compiler.
.NL
.PP
The serialization of a program containing these
special language extensions is described in Using Intel(R) Cilk(TM) Plus.
.NL
.PP
.B NOTE:
Vector parallelism, which is generated by
the array notations within Intel(R) Cilk(TM) Plus, is not affected by this
compiler option.
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-clang\-name=name (M*X only)
.RS
.TP
Specifies the name of the Clang compiler that should be used to set up the environment for C compilations.
.NL
.TP
\fBArchitectures:\fR IA\-32, Intel(R) 64 architecture
.TP
\fBArguments:\fR 
.TP 18
\fIname\fR
.NL
Is the name of the Clang compiler to use. It can include the path where the Clang compiler is located.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler uses the PATH setting to find the Clang compiler and resolve environment settings.
.TP
\fBDescription:\fR 
.PP
This option specifies the name of the Clang compiler that should be used to
set up the environment for C compilations. If you
do not specify a path, the compiler will search the PATH settings
for the compiler name you provide.
.NL
.PP
This option is helpful when you are referencing
a non\-standard Clang installation.
.NL
.PP
The C++ equivalent to option \-clang\-name is
\-clangxx\-name.
.NL
.PP
This option has no effect unless option
\-use\-clang\-env has been specified.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-clangxx\-name=name (M*X only)
.RS
.TP
Specifies the name of the Clang++ compiler that should be used to set up the environment for C++ compilations.
.NL
.TP
\fBArchitectures:\fR IA\-32, Intel(R) 64 architecture
.TP
\fBArguments:\fR 
.TP 18
\fIname\fR
.NL
Is the name of the Clang++ compiler to use. It can include the path where the Clang++ compiler is located.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler uses the PATH setting to find the Clang++ compiler and resolve environment settings.
.TP
\fBDescription:\fR 
.PP
This option specifies the name of the Clang++ compiler that should be used
to set up the environment for C++ compilations. If
you do not specify a path, the compiler will search the PATH
settings for the compiler name you provide.
.NL
.PP
The C equivalent to option \-clangxx\-name is
\-clang\-name.
.NL
.PP
This option has no effect unless option
\-use\-clang\-env has been specified.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-complex\-limited\-range
.TP
.B
\-no\-complex\-limited\-range
.RS
.TP
Determines whether the use of basic algebraic expansions of some arithmetic operations involving data of type COMPLEX is enabled.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-no\-complex\-limited\-range 
.NL
Basic algebraic expansions of some arithmetic operations involving data of type COMPLEX are disabled.
.TP
\fBDescription:\fR 
.PP
This option determines whether the use of basic algebraic expansions of some arithmetic operations involving data of type COMPLEX is enabled. 
.NL
.PP
When the option is enabled, this can cause performance improvements in programs that use a lot of COMPLEX arithmetic. However, values at the extremes of the exponent range may not compute correctly. 
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-cxxlib[=dir]
.TP
.B
\-cxxlib\-nostd
.TP
.B
\-no\-cxxlib
.RS
.TP
Determines whether the compiler links using the C++ run\-time libraries and header files provided by gcc.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.TP 18
\fIdir\fR
.NL
Is an optional top\-level location for the gcc binaries and libraries.
.TP
\fBDefault:\fR 
.TP 18
C++: \-cxxlib C: \-no\-cxxlib
.NL
For C++, the compiler uses the run\-time libraries and headers provided by gcc. For C, the compiler uses the default run\-time libraries and headers and does not link to any additional C++ run\-time libraries and headers. However, if you specify compiler option \-std=gnu++98, the default is \-cxxlib.
.TP
\fBDescription:\fR 
.PP
This option determines whether the compiler links using the C++ run\-time libraries and header files provided by gcc.
.NL
.PP
Option \-cxxlib\-nostd prevents the compiler from linking with the standard C++ library. 
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-Dname[=value]
.RS
.TP
Defines a macro name that can be associated with an optional value.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.TP 18
\fIname\fR
.NL
Is the name of the macro.
.TP 18
\fIvalue\fR
.NL
Is an optional integer or an optional character string delimited by double quotes; for example, D\fIname=string\fR.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
Only default symbols or macros are defined.
.TP
\fBDescription:\fR 
.PP
Defines a macro name that can be associated with an optional value. This option is equivalent to a #define preprocessor directive.
.NL
.PP
If a \fIvalue\fR is not specified, \fIname\fR  is defined as "1".
.NL
.PP
If you specify noD, all preprocessor definitions apply only to fpp and not to Intel(R) Fortran conditional compilation directives. To use this option, you must also specify option fpp. 
.NL
.PP
.B CAUTION:
On Linux* and OS X* systems, if you are not specifying a \fIvalue\fR, do not use D for \fIname\fR, because it will conflict with the \-DD option.
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-dD
.RS
.TP
Same as  option \-dM, but outputs #define directives in preprocessed source.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler does not output #define directives.
.TP
\fBDescription:\fR 
.PP
Same as \-dM, but outputs #define directives in preprocessed source. To use this option, you must also specify the E option.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-debug [keyword]
.RS
.TP
Enables or disables generation of debugging information.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.TP 18
\fIkeyword\fR
.NL
Is the type of debugging information to be generated. Possible values are:
.RS
.TP 15
none
Disables generation of debugging information.
.TP 15
full or all
Generates complete debugging information.
.TP 15
minimal
Generates line number information for debugging.
.TP 15
[no]emit_column
Determines whether the compiler generates column number information for debugging.
.TP 15
[no]expr\-source\-pos
Determines whether the compiler generates source position information at the expression level of granularity.
.TP 15
[no]inline\-debug\-info
Determines whether the compiler generates enhanced debug information for inlined code.
.TP 15
[no]macros
Determines whether the compiler emits debugging information for C/C++ macros.
.TP 15
[no]pubnames
Determines whether the compiler generates a DWARF debug_pubnames section.
.TP 15
[no]semantic\-stepping
Determines whether the compiler generates enhanced debug information useful for breakpoints and stepping.
.TP 15
[no]variable\-locations
Determines whether the compiler generates enhanced debug information useful in finding scalar local variables.
.TP 15
extended
Sets keyword values semantic\-stepping and variable\-locations.
.TP 15
[no]parallel (Linux only)
Determines whether the compiler generates parallel debug code instrumentations useful for thread data sharing and reentrant call detection. 
.RE
.PP
For information on the non\-default settings for these keywords, see the Description section.
.NL
.TP
\fBDefault:\fR 
.TP 18
varies
.NL
Normally, the default is \-debug none and no debugging information is generated. However, on Linux* OS, the \-debug inline\-debug\-info option will be enabled by default if you compile with optimizations (option \-O2 or higher) and debugging is enabled (option \-g).
.TP
\fBDescription:\fR 
.PP
This option enables or disables generation of debugging information.
.NL
.PP
Note that if you turn debugging on, optimization is turned off.
.NL
.PP
Keywords semantic\-stepping, inline\-debug\-info, variable\-locations, and extended can be used in combination with each other. If conflicting keywords are used in combination, the last one specified on the command line has precedence.
.NL
.TP 18
\fBOption\fR
.NL
.NL
\fBDescription\fR
.NL
.NL
.TP 18
\-debug none
.NL
Disables generation of debugging information.
.NL
.TP 18
\-debug full or \-debug all
.NL
Generates complete debugging information. It is the same as specifying \-debug with no keyword.
.NL
.TP 18
\-debug minimal
.NL
Generates line number information for debugging.
.NL
.TP 18
\-debug emit_column
.NL
Generates column number information for debugging.
.NL
.TP 18
\-debug expr\-source\-pos
.NL
Generates source position information at the statement level of granularity.
.NL
.TP 18
\-debug inline\-debug\-info
.NL
Generates enhanced debug information for inlined code. 
.TP 18
On inlined functions, symbols are (by default) associated with the caller. This option causes symbols for inlined functions to be associated with the source of the called function.
.NL
.TP 18
\-debug macros
.NL
The compiler emits debugging information for C/C++ macros. This provides a means to describe the macros for a given compilation unit.
.NL
.TP 18
\-debug pubnames
.NL
The compiler generates a DWARF debug_pubnames section. This provides a means to list the names of global objects and functions in a compilation unit.
.NL
.TP 18
\-debug semantic\-stepping
.NL
Generates enhanced debug information useful for breakpoints and stepping. It tells the debugger to stop only at machine instructions that achieve the final effect of a source statement. 
.TP 18
For example, in the case of an assignment statement, this might be a store instruction that assigns a value to a program variable; for a function call, it might be the machine instruction that executes the call. Other instructions generated for those source statements are not displayed during stepping.
.TP 18
This option has no impact unless optimizations have also been enabled.
.NL
.TP 18
\-debug variable\-locations
.NL
Generates enhanced debug information useful in finding scalar local variables. It uses a feature of the Dwarf object module known as "location lists". 
.TP 18
This feature allows the run\-time locations of local scalar variables to be specified more accurately; that is, whether, at a given position in the code, a variable value is found in memory or a machine register. 
.NL
.TP 18
\-debug extended
.NL
Sets keyword values semantic\-stepping and variable\-locations. It also tells the compiler to include column numbers in the line information.
.NL
.TP 18
\-debug parallel
.NL
Generates parallel debug code instrumentations needed for the thread data sharing and reentrant call detection. For shared data and reentrancy detection, option \-openmp must be set.
.NL
.PP
On Linux* systems, debuggers read debug information from executable images. As a result, information is written to object files and then added to the executable by the linker. 
.NL
.PP
On OS X* systems, debuggers read debug information from object files. As a result, the executables don\[aq]t contain any debug information. Therefore, if you want to be able to debug on these systems, you must retain the object files.
.NL
.TP
\fBAlternate Options:\fR 
.TP 18
For \-debug full, \-debug all, or \-debug
.NL
Linux and OS X: \-g
.TP 18
For \-debug variable\-locations
.NL
Linux and OS X: \-fvar\-tracking
.TP 18
For \-debug semantic\-stepping
.NL
Linux and OS X: \-fvar\-tracking\-assignments
.RE
.TP
.B
\-diag\-type diag\-list
.RS
.TP
Controls the display of diagnostic information.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.TP 18
\fItype\fR
.NL
Is an action to perform on diagnostics. Possible values are:
.RS
.TP 15
enable
Enables a diagnostic message or a group of messages.
.TP 15
disable
Disables a diagnostic message or a group of messages.
.TP 15
error
Tells the compiler to change diagnostics to errors.
.TP 15
warning
Tells the compiler to change diagnostics to warnings.
.TP 15
remark
Tells the compiler to change diagnostics to remarks (comments).
.RE
.TP 18
\fIdiag\-list\fR
.NL
Is a diagnostic group or ID value. Possible values are:
.RS
.TP 15
driver
Specifies diagnostic messages issued by the compiler driver.
.TP 15
port\-linux
Specifies diagnostic messages for language features that may cause errors when porting to Linux* systems. This diagnostic group is only available on Windows* systems.
.TP 15
port\-win
Specifies diagnostic messages for GNU extensions that may cause errors when porting to Windows. This diagnostic group is only available on Linux and OS X* systems.
.TP 15
thread
Specifies diagnostic messages that help in thread\-enabling a program.
.TP 15
vec
Specifies diagnostic messages issued by the vectorizer.
.TP 15
par
Specifies diagnostic messages issued by the auto\-parallelizer (parallel optimizer).
.TP 15
openmp
Specifies diagnostic messages issued by the OpenMP* parallelizer.
.TP 15
sc[n]
Enables static analysis and determines which diagnostics to emit based on severity. \fIn\fR can be any of the following: 1, 2, 3. For more details on these values, see below. This value is equivalent to deprecated value sv[n]. This setting is not available on OS X* systems.
.TP 15
sc\-\fImode\fR
Enables static analysis diagnostics and lets you specify the analysis mode. The \fImode\fR can be any of the following: full, concise, or precise. For more details on these values, see below. This setting is not available on OS X* systems.
.TP 15
warn
Specifies diagnostic messages that have a "warning" severity level.
.TP 15
error
Specifies diagnostic messages that have an "error" severity level.
.TP 15
remark
Specifies diagnostic messages that are remarks or comments.
.TP 15
cpu\-dispatch
Specifies the CPU dispatch remarks for diagnostic messages. These remarks are enabled by default.
.TP 15
id[,id,...]
Specifies the ID number of one or more messages. If you specify more than one message number, they must be separated by commas. There can be no intervening white space between each "id".
.TP 15
tag[,tag,...]
Specifies the mnemonic name of one or more messages. If you specify more than one mnemonic name, they must be separated by commas. There can be no intervening white space between each "tag".
.RE
.IP
The diagnostic messages generated can be affected by certain
options, such as /arch or /Qx (Windows) or \-m or \-x (Linux and OS X).
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler issues certain diagnostic messages by default.
.TP
\fBDescription:\fR 
.PP
This option controls the display of diagnostic information. Diagnostic messages are output to stderr unless compiler option \-diag\-file (Linux* OS and OS X*) or /Qdiag\-file (Windows* OS) is specified.
.NL
.PP
When \fIdiag\-list\fR value "warn" is used with static analysis
diagnostics, the following behavior occurs:
.NL
.IP \(bu 2
Option \-diag\-enable warn (Linux OS) and /Qdiag\-enable:warn (Windows OS) enable all 
diagnostics except those that have an "error" severity level. They enable all static analysis
warnings, cautions, and remarks. 
.IP \(bu 2
Option \-diag\-disable warn (Linux OS) and /Qdiag\-disable:warn (Windows OS) disable all  static analysis
diagnostics except those that have an "error" severity level. They suppress all static analysis
warnings, cautions, and remarks. 
.PP
The following table shows more information on values you can specify for \fIdiag\-list\fR item sc and sc\-\fImode\fR. These items are not available on OS X* systems.
.NL
.PP
To disable  static analysis, specify /Qdiag\-disable:sc (Windows* OS) or
option  \-diag\-disable sc (Linux* OS).
.NL
.PP
To control the diagnostic information reported by the vectorizer, use the \-vec\-report (Linux OS and OS X) or /Qvec\-report (Windows OS) option.
.NL
.PP
To control the diagnostic information reported by the auto\-parallelizer, use the \-par\-report (Linux OS and OS X) or /Qpar\-report (Windows OS) option.
.NL
.TP
\fBAlternate Options:\fR 
.TP 18
enable vec
.NL
Linux and OS X: \-vec\-report
.TP 18
disable vec
.NL
Linux and OS X: \-vec\-report0
.TP 18
enable par
.NL
Linux and OS X: \-par\-report
.TP 18
disable par
.NL
Linux and OS X: \-par\-report0
.RE
.TP
.B
\-diag\-dump
.RS
.TP
Tells the compiler to print all enabled diagnostic messages and stop compilation.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler issues certain diagnostic messages by default.
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to print all enabled diagnostic messages and stop compilation. The diagnostic messages are output to stdout.
.NL
.PP
This option prints the enabled diagnostics from all possible diagnostics that the compiler can issue, including any default diagnostics.
.NL
.PP
If \-diag\-enable\fIdiag\-list\fR (Linux OS and OS X) or /Qdiag\-enable\fIdiag\-list\fR (Windows OS) is specified, the print out will include the \fIdiag\-list\fR diagnostics.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-diag\-enable sc\-enums (L*X only)
.RS
.TP
Tells static analysis to treat enumeration variables as known values equal to any one of the associated enumeration literals.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
If static analysis is enabled, it treats unknown enumeration variables as unknown integer values.
.TP
\fBDescription:\fR 
.PP
This option tells static analysis to treat enumeration variables as known values equal to any one of the associated enumeration literals.  By default, static analysis treats unknown enumeration variables as unknown integer values.  Setting this option may find additional errors but tends to create more false positives.
.NL
.PP
This option is ignored unless static analysis diagnostics are enabled by providing one or more of the following options:
.NL
.IP \(bu 2
\-diag\-enable sc[n] or \-diag\-enable sc\-mode (Linux* OS)
.IP \(bu 2
/Qdiag\-enable:sc[n] or /Qdiag\-enable:sc\-mode (Windows* OS)
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-diag\-enable sc\-include (L*X only)
.RS
.TP
Tells a source code analyzer to process include files and source files when issuing diagnostic messages.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler issues certain diagnostic messages by default. If the static analysis is enabled, include files are not analyzed by default.
.TP
\fBDescription:\fR 
.PP
This option tells the static security analyzer to process include files and source files when issuing diagnostic messages. Normally, when static analysis diagnostics are enabled, only source files are analyzed. 
.NL
.PP
This option is ignored unless static analysis diagnostics are enabled by providing one or more of the following options:
.NL
.IP \(bu 2
\-diag\-enable sc[n] or \-diag\-enable sc\-mode (Linux* OS)
.IP \(bu 2
/Qdiag\-enable:sc[n] or /Qdiag\-enable:sc\-mode (Windows* OS)
.TP
\fBAlternate Options:\fR 
.PP
Linux and OS X: \-diag\-enable sv\-include (this is a deprecated option)
.NL
.RE
.TP
.B
\-diag\-enable sc\-single\-file (L*X only)
.RS
.TP
Tells static analysis to process each file individually.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
If static analysis is
enabled, it analyzes the whole program.
.TP
\fBDescription:\fR 
.PP
This option tells static analysis to process each file individually.  Skipping the usual whole\-program analysis reduces memory requirements and analysis time on large programs but often finds fewer real errors. 
.NL
.PP
This option is ignored unless static analysis diagnostics are enabled by providing one or more of the following options: 
.IP \(bu 2
\-diag\-enable sc[n] or \-diag\-enable sc\-mode (Linux* OS)
.IP \(bu 2
/Qdiag\-enable:sc[n] or /Qdiag\-enable:sc\-mode (Windows* OS)
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-diag\-error\-limitn
.TP
.B
\-no\-diag\-error\-limit
.RS
.TP
Specifies the maximum number of errors allowed before compilation stops.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.TP 18
\fIn\fR
.NL
Is the maximum number of error\-level or fatal\-level compiler errors allowed.
.TP
\fBDefault:\fR 
.TP 18
30
.NL
A maximum of 30 error\-level and fatal\-level messages are allowed.
.TP
\fBDescription:\fR 
.PP
This option specifies the maximum number of errors allowed before compilation stops. It indicates the maximum number of error\-level or fatal\-level compiler errors allowed for a file specified on the command line. 
.NL
.PP
If you specify \-no\-diag\-error\-limit (Linux OS and OS X) or /Qdiag\-error\-limit\- (Windows OS) on the command line, there is no limit on the number of errors that are allowed.
.NL
.PP
If the maximum number of errors is reached, a warning message is issued and the next file (if any) on the command line is compiled.
.NL
.TP
\fBAlternate Options:\fR 
.PP
Linux and OS X: \-wn (this is a deprecated option)
.NL
.RE
.TP
.B
\-diag\-file[=filename] (L*X only)
.RS
.TP
Causes the results of diagnostic analysis to be output to a file.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.TP 18
\fIfilename\fR
.NL
Is the name of the file for output.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
Diagnostic messages are output to stderr.
.TP
\fBDescription:\fR 
.PP
This option causes the results of diagnostic analysis to be output to a file. The file is placed in the current working directory.
.NL
.PP
You can include a file extension in \fIfilename\fR. For example, if \fIfile.txt\fR is specified, the name of the output file is 
\fIfile.txt\fR. If you do not provide a file extension, the name of the file is \fIfilename.diag\fR. 
.NL
.PP
If \fIfilename\fR is not specified, the name of the file is \fIname\-of\-the\-first\-source\-file.diag\fR. This is also the name of the file if the name specified for file conflicts with a source file name provided in the command line.
.NL
.PP
.B NOTE:
If you specify \-diag\-file (Linux OS) or /Qdiag\-file (Windows OS) and you also specify \-diag\-file\-append (Linux OS) or /Qdiag\-file\-append (Windows OS), the last option specified on the command line takes precedence.
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-diag\-file\-append[=filename] (L*X only)
.RS
.TP
Causes the results of diagnostic analysis to be appended to a file.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.TP 18
\fIfilename\fR
.NL
Is the name of the file to be appended to. It can include a path.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
Diagnostic messages are output to stderr.
.TP
\fBDescription:\fR 
.PP
This option causes the results of diagnostic analysis to be appended to a file. If you do not specify a path, the driver will look for \fIfilename\fR in the current working directory. 
.NL
.PP
If \fIfilename\fR is not found, then a new file with that name is created in the current working directory. If the name specified for file conflicts with a source file name provided in the command line, the name of the file is \fIname\-of\-the\-first\-source\-file.diag\fR.
.NL
.PP
.B NOTE:
If you specify \-diag\-file\-append (Linux OS) or /Qdiag\-file\-append (Windows OS) and you also specify \-diag\-file (Linux OS) or /Qdiag\-file (Windows OS), the last option specified on the command line takes precedence.
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-diag\-id\-numbers
.TP
.B
\-no\-diag\-id\-numbers
.RS
.TP
Determines whether the compiler displays diagnostic messages by using their ID number values.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-diag\-id\-numbers 
.NL
The compiler displays diagnostic messages by using their ID number values.
.TP
\fBDescription:\fR 
.PP
This option determines whether the compiler displays diagnostic messages by using their ID number values. If you specify \-no\-diag\-id\-numbers (Linux* OS and OS X*) or /Qdiag\-id\-numbers\- (Windows* OS), mnemonic names are output for driver diagnostics only.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-diag\-onceid[,id,...]
.RS
.TP
Tells the compiler to issue one or more diagnostic messages only once.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.TP 18
\fIid\fR
.NL
Is the ID number of the diagnostic message. If you specify more than one message number, they must be separated by commas. There can be no intervening white space between each \fIid\fR. 
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler issues certain diagnostic messages by default.
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to issue one or more diagnostic messages only once.
.NL
.TP
\fBAlternate Options:\fR 
.PP
Linux: \-wo (this is a deprecated option)
.NL
.PP
Windows: /Qwo (this is a deprecated option)
.NL
.RE
.TP
.B
\-diag\-sc\-dir[=dir] (L*X only)
.RS
.TP
Specifies a directory for static analysis results.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.TP 18
\fIdir\fR
.NL
Is the name of the directory where the results should be placed.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
If static analysis is enabled, analysis results are placed in the current working directory. For more details, see below.
.TP
\fBDescription:\fR 
.PP
This option specifies a directory for static analysis results. 
.NL
.PP
If you do not specify \fIdir\fR, the results are placed in the current working directory.  Results are placed in a subdirectory with the name r\fInnn\fRsc, where \fInnn\fR is replaced by the next available sequence number (001, 002, etc.).
.NL
.PP
This option is ignored unless static analysis diagnostics are enabled by providing one or more of the following options:
.NL
.IP \(bu 2
\-diag\-enable sc[n] or \-diag\-enable sc\-mode (Linux* OS)
.IP \(bu 2
/Qdiag\-enable:sc[n] or /Qdiag\-enable:sc\-mode (Windows* OS)
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-dM
.RS
.TP
Tells the compiler to output macro definitions in effect after preprocessing.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler does not output macro definitions after preprocessing.
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to output macro definitions in effect after preprocessing. To use this option, you must also specify option E.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-dN
.RS
.TP
Same as option \-dD, but output #define directives contain only macro names.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler does not output #define directives.
.TP
\fBDescription:\fR 
.PP
Same as \-dD, but output #define directives contain only macro names. To use this option, you must also specify option E.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-dryrun
.RS
.TP
Specifies that driver tool commands should be shown but not executed.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
No tool commands are shown, but they are executed.
.TP
\fBDescription:\fR 
.PP
This option specifies that driver tool commands should be shown but not executed. 
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-dumpmachine
.RS
.TP
Displays the target machine and operating system configuration.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler does not display target machine or operating system information.
.TP
\fBDescription:\fR 
.PP
This option displays the target machine and operating system configuration. No compilation is performed.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-dumpversion
.RS
.TP
Displays the version number of the compiler.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler does not display the compiler version number.
.TP
\fBDescription:\fR 
.PP
This option displays the version number of the compiler. It does not compile your source files.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-dynamic\-linker file (L*X only)
.RS
.TP
Specifies a dynamic linker other than the default. 
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.TP 18
\fIfile\fR
.NL
Is the name of the dynamic linker to be used.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The default dynamic linker is used.
.TP
\fBDescription:\fR 
.PP
This option lets you specify a dynamic linker other than the default.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-dynamiclib (M*X only)
.RS
.TP
Invokes the libtool command to generate dynamic libraries.
.NL
.TP
\fBArchitectures:\fR IA\-32, Intel(R) 64 architecture
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler produces an executable.
.TP
\fBDescription:\fR 
.PP
This option invokes the libtool command to generate dynamic libraries. 
.NL
.PP
When passed this option, the compiler uses the libtool command to produce a dynamic library instead of an executable when linking. 
.NL
.PP
To build static libraries, you should specify option \-staticlib or libtool \-static <objects>.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-E
.RS
.TP
Causes the preprocessor to send output to stdout.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
Preprocessed source files are output to the compiler.
.TP
\fBDescription:\fR 
.PP
This option causes the preprocessor to send output to stdout. Compilation stops when the files have been preprocessed.
.NL
.PP
When you specify this option, the compiler\[aq]s preprocessor expands your source module and writes the result to stdout. The preprocessed source contains #line directives, which the compiler uses to determine the source file and line number.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-early\-template\-check
.TP
.B
\-no\-early\-template\-check
.RS
.TP
Lets you semantically check template function template prototypes before instantiation.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-no\-early\-template\-check
.NL
The prototype instantiation of function templates and function members of class templates is deferred.
.TP
\fBDescription:\fR 
.PP
Lets you semantically check template function template prototypes before instantiation. On Linux* OS platforms, gcc 3.4 (or newer) compatibilty modes (i.e. \-gcc\-version=340 and later) must be in effect. For all OS X* platforms, gcc 4.0 (or newer) is required. 
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-EP
.RS
.TP
Causes the preprocessor to send output to stdout, omitting #line directives.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
Preprocessed source files are output to the compiler.
.TP
\fBDescription:\fR 
.PP
This option causes the preprocessor to send output to stdout, omitting #line directives. 
.NL
.PP
If you also specify option P or Linux* OS option F, the preprocessor will write the results (without #line directives) to a file instead of stdout.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-Fdir (M*X only)
.RS
.TP
Adds a framework directory to the head of an include file search path.
.NL
.TP
\fBArchitectures:\fR IA\-32, Intel(R) 64 architecture
.TP
\fBArguments:\fR 
.TP 18
\fIdir\fR
.NL
Is the name for the framework directory.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler does not add a framework directory to the head of an include file search path.
.TP
\fBDescription:\fR 
.PP
This option adds a framework directory to the head of an include file search path.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-Fa[filename|dir]
.RS
.TP
Specifies that an assembly listing file should be generated.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.TP 18
\fIfilename\fR
.NL
Is the name of the assembly listing file.
.TP 18
\fIdir\fR
.NL
Is the directory where the file should be placed. It can include \fIfilename\fR.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
No assembly listing file is produced.
.TP
\fBDescription:\fR 
.PP
This option specifies that an assembly listing file should be generated (optionally named \fIfilename\fR).
.NL
.TP
\fBAlternate Options:\fR 
.PP
Linux and OS X: \-S
.NL
.PP
Windows: /S
.NL
.RE
.TP
.B
\-fabi\-version=n
.RS
.TP
Instructs the compiler to select a specific ABI implementation. 
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.TP 18
\fIn\fR
.NL
Is the ABI implementation. Possible values are:
.RS
.TP 15
0
Requests the latest ABI implementation.
.TP 15
1
Requests the ABI implementation used in gcc 3.2 and gcc 3.3.
.TP 15
2
Requests the ABI implementation used in gcc 3.4 and higher.
.RE
.TP
\fBDefault:\fR 
.TP 18
Varies
.NL
The compiler uses the ABI implementation that corresponds to the installed version of gcc.
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to select a specific ABI implementation. This option is compatible with gcc option \-fabi\-version. If you have multiple versions of gcc installed, the compiler may change the value of \fIn\fR depending on which gcc is detected in your path.
.NL
.PP
.B NOTE:
gcc 3.2 and 3.3 are not fully ABI\-compliant, but gcc 3.4 is highly ABI\-compliant.
.PP
.B CAUTION:
Do not mix different values for \-fabi\-version in one link.
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-falias
.TP
.B
\-fno\-alias
.RS
.TP
Determines whether aliasing should be assumed in the program.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-falias
.NL
Aliasing is assumed in the program.
.TP
\fBDescription:\fR 
.PP
This option determines whether aliasing should be assumed in the program.
.NL
.PP
If you do not want aliasing to be assumed in the program, specify \-fno\-alias.
.NL
.TP
\fBAlternate Options:\fR 
.PP
Linux and OS X: None
.NL
.RE
.TP
.B
\-falign\-functions[=n]
.TP
.B
\-fno\-align\-functions
.RS
.TP
Tells the compiler to align functions on an optimal byte boundary. 
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.TP 18
\fIn\fR
.NL
Is the byte boundary for function alignment. Possible values are 2 or 16.
.TP
\fBDefault:\fR 
.TP 18
\-fno\-align\-functions
.NL
The compiler aligns functions on 2\-byte boundaries. This is the same as specifying \-falign\-functions=2 (Linux* OS and OS X*).
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to align functions on an optimal byte boundary. If you do not specify \fIn\fR, the compiler aligns the start of functions on 16\-byte boundaries.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-falign\-stack=mode (L*X only)
.RS
.TP
Tells the compiler the stack alignment to use on entry to routines. 
.NL
.TP
\fBArchitectures:\fR IA\-32 architecture
.TP
\fBArguments:\fR 
.TP 18
\fImode\fR
.NL
Is the method to use for stack alignment.  Possible values are:
.RS
.TP 15
assume\-4\-byte
Tells the compiler to assume the stack is aligned on 4\-byte boundaries. The compiler can dynamically adjust the stack to 16\-byte alignment if needed. 
.TP 15
maintain\-16\-byte
Tells the compiler to not assume any specific stack alignment, but attempt to maintain alignment in case the stack is already aligned. The compiler can dynamically align the stack if needed. This setting is compatible with gcc. 
.TP 15
assume\-16\-byte
Tells the compiler to assume the stack is aligned on 16\-byte boundaries and to continue to maintain 16\-byte alignment. This setting is compatible with gcc. 
.RE
.TP
\fBDefault:\fR 
.TP 18
\-falign\-stack=assume\-16\-byte
.NL
The compiler assumes the stack is aligned on 16\-byte boundaries and continues to maintain 16\-byte alignment.
.TP
\fBDescription:\fR 
.PP
This option tells the compiler the stack alignment to use on entry to routines.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-fargument\-alias
.TP
.B
\-fargument\-noalias
.RS
.TP
Determines whether function arguments can alias each other. 
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-fargument\-alias
.NL
Function arguments can alias each other and can alias global storage.
.TP
\fBDescription:\fR 
.PP
This option determines whether function arguments can alias each other. If you specify –fargument\-noalias or /Qalias\-args\-, function arguments cannot alias each other, but they can alias global storage.
.NL
.PP
On Linux and OS X systems, you can also disable aliasing for global storage, by specifying option \-fargument\-noalias\-global.
.NL
.RE
.TP
.B
\-fargument\-noalias\-global
.RS
.TP
Tells the compiler that function arguments cannot alias each other and cannot alias global storage.  
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
Function arguments can alias each other and can alias global storage.
.TP
\fBDescription:\fR 
.PP
This option tells the compiler that function arguments cannot alias each other and they cannot alias global storage.
.NL
.PP
If you only want to prevent function arguments from being able to alias each other, specify option \-fargument\-noalias.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-fasm\-blocks
.RS
.TP
Enables the use of blocks and entire functions of assembly code within a C or C++ file.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler allows a GNU*\-style inline assembly format.
.TP
\fBDescription:\fR 
.PP
This option enables the use of blocks and entire functions of assembly code within a C or C++ file.
.NL
.PP
It allows a Microsoft* MASM\-style inline assembly block not a GNU*\-style inline assembly block.
.NL
.PP
On OS X* systems, this option is provided for compatibility with the Apple* GNU compiler.
.NL
.TP
\fBAlternate Options:\fR 
.PP
\-use\-msasm
.NL
.RE
.TP
.B
\-fast
.RS
.TP
Maximizes speed across the entire program.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The optimizations that maximize speed are not enabled.
.TP
\fBDescription:\fR 
.PP
This option maximizes speed across the entire program.
.NL
.PP
It sets the following options:
.NL
.IP \(bu 2
On OS X* systems: \-ipo, \-mdynamic\-no\-pic, \-O3, \-no\-prec\-div, and \-xHost On Windows* systems: /O3, /Qipo, /Qprec\-div\-, and /QxHost On Linux* systems: \-ipo, \-O3, \-no\-prec\-div, \-static, and \-xHost
.PP
When option fast is specified, you can override the \-xHost or /QxHost setting by specifying a different processor\-specific \-x or /Qx option on the command line. However, the last option specified on the command line takes precedence.  
.NL
.PP
For example, if you specify \-fast \-xSSE3 (Linux) or /fast /QxSSE3 (Windows), option \-xSSE3 or /QxSSE3 takes effect. However, if you specify \-xSSE3 \-fast (Linux) or /QxSSE3 /fast (Windows), option \-xHost or /QxHost takes effect.
.NL
.PP
For implications on non\-Intel processors, refer to the xHost documentation.
.NL
.PP
.B NOTE:
Option fast sets some aggressive optimizations that may not be appropriate for all applications. The resulting executable may not run on processor types different from the one on which you compile. You should make sure that you understand the individual optimization options that are enabled by option fast.
.PP
.TP 18
\fBOptimization Notice 
\fR
.NL
.NL
.TP 18
= = = = = = = = = = 
.TP 18
Intel\[aq]s compilers may or may not optimize to the same degree for non\-Intel microprocessors for optimizations that are not unique to Intel microprocessors. These optimizations include SSE2, SSE3, and SSSE3 instruction sets and other optimizations. Intel does not guarantee the availability, functionality, or effectiveness of any optimization on microprocessors not manufactured by Intel. Microprocessor\-dependent optimizations in this product are intended for use with Intel microprocessors. Certain optimizations not specific to Intel microarchitecture are reserved for Intel microprocessors. Please refer to the applicable product User and Reference Guides for more information regarding the specific instruction sets covered by this notice. 
.TP 18
Notice revision #20110804 
.TP 18
= = = = = = = = = = 
.NL
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-fast\-transcendentals
.TP
.B
\-no\-fast\-transcendentals
.RS
.TP
Enables the compiler to replace calls to transcendental functions with faster but less precise implementations.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
depends on the setting of \-fp\-model (Linux* OS and OS X*)
.NL
If you do not specify option \-[no\-]fast\-transcendentals:
.RS
.IP \(bu 2
The default is ON if option \-fp\-model fast is specified or is in effect.
.IP \(bu 2
The default is OFF if a value\-safe setting is specified for \-fp\-model (such as "precise", "source", etc.).
.RE
.TP
\fBDescription:\fR 
.PP
This option enables the compiler to replace calls to transcendental functions with implementations that may be faster but less precise. 
.NL
.PP
It allows the compiler to perform certain optimizations on transcendental functions, such as replacing individual calls to sine in a loop with a single call to a less precise vectorized sine library routine. 
.NL
.PP
This option does not affect explicit Short Vector Math Library (SVML) intrinsics.  It only affects scalar calls to the standard math library routines.
.NL
.PP
You cannot use option –fast\-transcendentals with option –fp\-model strict. 
.NL
.PP
This option determines the setting for the
maximum allowable relative error for math library function results
(max\-error) if none of the following options are
specified:
.NL
.IP \(bu 2
\-fimf\-accuracy\-bits (Linux* OS and OS X*) or
/Qimf\-accuracy\-bits (Windows* OS)
.IP \(bu 2
\-fimf\-max\-error (Linux OS and OS X) or
/Qimf\-max\-error (Windows OS)
.IP \(bu 2
\-fimf\-precision (Linux OS and OS X) or
/Qimf\-precision (Windows OS)
.PP
This option enables extra optimization that only applies to Intel(R) processors.
.NL
.PP
.TP 18
\fBOptimization Notice 
\fR
.NL
.NL
.TP 18
= = = = = = = = = = 
.TP 18
Intel\[aq]s compilers may or may not optimize to the same degree for non\-Intel microprocessors for optimizations that are not unique to Intel microprocessors. These optimizations include SSE2, SSE3, and SSSE3 instruction sets and other optimizations. Intel does not guarantee the availability, functionality, or effectiveness of any optimization on microprocessors not manufactured by Intel. Microprocessor\-dependent optimizations in this product are intended for use with Intel microprocessors. Certain optimizations not specific to Intel microarchitecture are reserved for Intel microprocessors. Please refer to the applicable product User and Reference Guides for more information regarding the specific instruction sets covered by this notice. 
.TP 18
Notice revision #20110804 
.TP 18
= = = = = = = = = = 
.NL
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-fasynchronous\-unwind\-tables
.TP
.B
\-fno\-asynchronous\-unwind\-tables
.RS
.TP
Determines whether unwind information is precise at an instruction boundary or at a call boundary. 
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
Intel(R) 64 architecture: \-fasynchronous\-unwind\-tables
.NL
The unwind table generated is precise at  an instruction boundary, enabling accurate unwinding at any instruction.
.TP 18
IA\-32 architecture: \-fno\-asynchronous\-unwind\-tables
.NL
The unwind table generated is precise at call boundaries only.
.TP
\fBDescription:\fR 
.PP
This option determines whether unwind information is precise at an instruction boundary or at a call boundary. The compiler generates an unwind table in DWARF2 or DWARF3 format, depending on which format is supported on your system.
.NL
.PP
If \-fno\-asynchronous\-unwind\-tables is specified, the unwind table is precise at call boundaries only. In this case, the compiler will avoid creating unwind tables for routines such as the following:
.NL
.IP \(bu 2
A C++ routine that does not declare objects with destructors and does not contain calls to routines that might throw an exception.
.IP \(bu 2
A C/C++ or Fortran routine compiled without \-fexceptions, and on Intel(R) 64 architecture, without \-traceback.
.IP \(bu 2
A C/C++ or Fortran routine compiled with \-fexceptions that does not contain calls to routines that might throw an exception.
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-fblocks (M*X only)
.TP
.B
\-fno\-blocks (M*X only)
.RS
.TP
Determines whether Apple* blocks are enabled or disabled. 
.NL
.TP
\fBArchitectures:\fR IA\-32, Intel(R) 64 architecture
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-fblocks
.NL
Apple* blocks are enabled.
.TP
\fBDescription:\fR 
.PP
This option determines whether Apple* blocks
(block variable declarations) are enabled or disabled.
.NL
.PP
If you want to disable Apple* blocks, specify
\-fno\-blocks.
.NL
.PP
To use this feature, OS X* or Mac OS* X 10.6 or greater is
required.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-fbuiltin[\-func]
.TP
.B
\-fno\-builtin[\-func]
.RS
.TP
Enables or disables inline expansion of intrinsic functions.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.TP 18
\fIfunc\fR
.NL
A comma\-separated list of intrinsic functions.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
Inline expansion of intrinsic functions disabled.
.TP
\fBDescription:\fR 
.PP
This option enables or disables inline expansion of one or more intrinsic functions.  If \fI\-func\fR is not specified, \-fno\-builtin disables inline expansion for all intrinsic functions.
.NL
.PP
For a list of built\-in functions affected by \-fbuiltin, search for "built\-in functions" in the appropriate gcc* documentation.
.NL
.PP
For a list of built\-in functions affected by /Oi, search for "/Oi" in the appropriate Microsoft* Visual C/C++* documentation.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-fcode\-asm
.RS
.TP
Produces an assembly listing with machine code annotations.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
No machine code annotations appear in the assembly listing file, if one is produced.
.TP
\fBDescription:\fR 
.PP
This option produces an assembly listing file with machine code annotations.
.NL
.PP
The assembly listing file shows the hex machine instructions at the beginning of each line of assembly code. The file cannot be assembled; the file name is the name of the source file with an extension of .cod.
.NL
.PP
To use this option, you must also specify option \-S, which causes an assembly listing to be generated.
.NL
.TP
\fBAlternate Options:\fR 
.PP
Linux and OS X: None
.NL
.RE
.TP
.B
\-fcommon
.TP
.B
\-fno\-common
.RS
.TP
Determines whether the compiler treats common symbols as global definitions. 
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-fcommon
.NL
The compiler does not treat common symbols as global definitions.
.TP
\fBDescription:\fR 
.PP
This option determines whether the compiler treats common symbols as global definitions and to allocate memory for each symbol at compile time.
.NL
.PP
Option \-fno\-common tells the compiler to treat common symbols as global definitions. When using this option, you can only have a common variable declared in one module; otherwise, a link time error will occur for multiple defined symbols.
.NL
.PP
Normally, a file\-scope declaration with no initializer and without the extern or static keyword "int i;" is represented as a common symbol. Such a symbol is treated as an external reference. However, if no other compilation unit has a global definition for the name, the linker allocates memory for it. 
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-fexceptions
.TP
.B
\-fno\-exceptions
.RS
.TP
Enables exception handling table generation. 
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-fexceptions
.NL
Exception handling table generation is enabled. Default for C++.
.TP 18
\-fno\-exceptions
.NL
Exception handling table generation is disabled. Default for C.
.TP
\fBDescription:\fR 
.PP
This option enables exception handling table generation. The \-fno\-exceptions option disables exception handling table generation, resulting in smaller code. When this option is used, any use of exception handling constructs (such as try blocks and throw statements) will produce an error. Exception specifications are parsed but ignored. It also undefines the preprocessor symbol __EXCEPTIONS.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-fextend\-arguments=n
.RS
.TP
Controls how scalar integer arguments are extended in calls to unprototyped and varargs functions.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.TP 18
\fIn\fR
.NL
Specifies the extension for the integer parameters. Possible values are:
.RS
.TP 15
32
Causes unprototyped integer parameters to be extended to 32 bits.
.TP 15
64
Causes unprototyped integer parameters to be extended to 64 bits. This value is only available on Intel(R) 64 architecture.
.RE
.TP
\fBDefault:\fR 
.TP 18
\-fextend\-arguments=32 or /Qextend\-arguments:32
.NL
Unprototyped integer parameters are extended to 32 bits.
.TP
\fBDescription:\fR 
.PP
This option controls how scalar integer arguments are extended in calls to unprototyped and varargs functions.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-ffnalias
.TP
.B
\-fno\-fnalias
.RS
.TP
Specifies that aliasing should be assumed within functions.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-ffnalias
.NL
Aliasing is assumed within functions.
.TP
\fBDescription:\fR 
.PP
This option specifies that aliasing should be assumed within functions.
.NL
.PP
The \-fno\-fnalias option specifies that aliasing should not be assumed within functions, but should be assumed across calls.
.NL
.TP
\fBAlternate Options:\fR 
.PP
Linux and OS X: None
.NL
.RE
.TP
.B
\-ffreestanding
.RS
.TP
Ensures that compilation takes place in a freestanding environment.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
Standard libraries are used during compilation.
.TP
\fBDescription:\fR 
.PP
This option ensures that compilation takes place in a freestanding environment. The compiler assumes that the standard library may not exist and program startup may not necessarily be at main. This environment meets the definition of a freestanding environment as described in the C and C++ standard.
.NL
.PP
An example of an application requiring such an environment is an OS kernel.
.NL
.PP
.B NOTE:
When you specify this option, the compiler will not assume the presence of compiler\-specific libraries. It will only generate calls that appear in the source code.
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-ffriend\-injection
.TP
.B
\-fno\-friend\-injection
.RS
.TP
Causes the compiler to inject friend functions into the enclosing namespace.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-fno\-friend\-injection
.NL
The compiler does not inject friend functions
into the enclosing namespace. A friend function that is not declared in an
enclosing scope can only be found using argument\-dependent
lookup.
.TP
\fBDescription:\fR 
.PP
This option causes the compiler to inject
friend functions into the enclosing namespace, so they are visible
outside the scope of the class in which they are
declared.
.NL
.PP
In gcc versions 4.1 or later, this is not the
default behavior. This option allows compatibility with gcc 4.0 or
earlier.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-ffunction\-sections
.RS
.TP
Places each function in its own COMDAT section.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
.TP
\fBDescription:\fR 
.PP
Places each function in its own COMDAT section.
.NL
.TP
\fBAlternate Options:\fR 
.PP
\-fdata\-sections
.NL
.RE
.TP
.B
\-fgnu89\-inline
.RS
.TP
Tells the compiler to use C89 semantics for inline functions when in C99 mode.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to use C89 semantics for inline functions when in C99 mode.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-fimf\-absolute\-error=value[:funclist]
.RS
.TP
Defines the maximum allowable absolute error for math library function results.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.TP 18
\fIvalue\fR
.NL
Is a positive, floating\-point number. Errors in math library function results may exceed the maximum relative error (max\-error) setting if the absolute\-error is less than or equal to \fIvalue\fR.
.IP
The format for the number is [digits] [.digits] [ { e | E
}[sign]digits]
.TP 18
\fIfunclist\fR
.NL
Is an optional list of one or more math library functions to which the attribute should be applied. If you specify more than one function, they must be separated with commas.  Precision\-specific variants like sin and sinf are considered different functions, so you would need to use \-fimf\-absolute\-error=0.00001:sin,sinf (or /Qimf\-absolute\-error:0.00001:sin,sinf) to specify the maximum allowable absolute error for both the single\-precision and double\-precision sine functions. 
.IP
You also can specify the symbol /f to denote single\-precision divides, symbol / to denote double\-precision divides, symbol /l to denote extended\-precision divides, and symbol /q to denote quad\-precision divides. For example you can specify  \-fimf\-absolute\-error=0.00001:/ or /Qimf\-absolute\-error: 0.00001:/.
.TP
\fBDefault:\fR 
.TP 18
Zero ("0")
.NL
An absolute\-error setting of 0 means that the function is bound by the relative error setting. This is the default behavior.
.TP
\fBDescription:\fR 
.PP
This option defines the maximum allowable absolute error for math library function results.
.NL
.PP
This option can improve run\-time performance, but it may decrease the accuracy of results.
.NL
.PP
This option only affects functions that have
zero as a possible return value, such as log, sin, asin,
etc.
.NL
.PP
The relative error requirements for a
particular function are determined by options that set the maximum relative error (max\-error)
and precision. The return value from a function must have a
relative error less than the max\-error value, or an absolute error
less than the absolute\-error value.
.NL
.PP
If you need to define the accuracy for a math function of a certain
precision, specify the function name of the precision that you
need. For example, if you want double precision, you can specify
:sin; if you want single precision, you can specify :sinf, as
in \-fimf\-absolute\-error=0.00001:sin or
/Qimf\-absolute\-error:0.00001:sin, or \-fimf\-absolute\-error=0.00001:sqrtf or
/Qimf\-absolute\-error:0.00001:sqrtf.
.NL
.PP
If you do not specify any function names, then
the setting applies to all functions (and to all precisions).
However, as soon as you specify an individual function name, the
setting applies only to the function of corresponding
precision. So, for example, sinf applies only to the single\-precision sine
function, sin applies only to the
double\-precision sine
function, sinl applies only to the
extended\-precision sine
function, etc.
.NL
.PP
.B NOTE:
Many routines in libraries LIBM (Math Library) and SVML (Short Vector Math Library) are more highly optimized for Intel(R) microprocessors than for non\-Intel microprocessors.
.PP
.TP 18
\fBOptimization Notice 
\fR
.NL
.NL
.TP 18
= = = = = = = = = = 
.TP 18
Intel\[aq]s compilers may or may not optimize to the same degree for non\-Intel microprocessors for optimizations that are not unique to Intel microprocessors. These optimizations include SSE2, SSE3, and SSSE3 instruction sets and other optimizations. Intel does not guarantee the availability, functionality, or effectiveness of any optimization on microprocessors not manufactured by Intel. Microprocessor\-dependent optimizations in this product are intended for use with Intel microprocessors. Certain optimizations not specific to Intel microarchitecture are reserved for Intel microprocessors. Please refer to the applicable product User and Reference Guides for more information regarding the specific instruction sets covered by this notice. 
.TP 18
Notice revision #20110804 
.TP 18
= = = = = = = = = = 
.NL
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-fimf\-accuracy\-bits=bits[:funclist]
.RS
.TP
Defines the relative error for math library function results,  including division and square root.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.TP 18
\fIbits\fR
.NL
Is a positive, floating\-point number indicating the number of correct bits the compiler should use.
.IP
The format for the number is [digits] [.digits] [ { e | E }[sign]digits].
.TP 18
\fIfunclist\fR
.NL
Is an optional list of one or more math library functions to which the attribute should be applied. If you specify more than one function, they must be separated with commas.  Precision\-specific variants like sin and sinf are considered different functions, so you would need to use \-fimf\-accuracy\-bits=23:sin,sinf (or /Qimf\-accuracy\-bits:23:sin,sinf) to specify the relative error for both the single\-precision and double\-precision sine functions. 
.IP
You also can specify the symbol /f to denote single\-precision divides, symbol / to denote double\-precision divides, symbol /l to denote extended\-precision divides, and symbol /q to denote quad\-precision divides. For example you can specify  \-fimf\-accuracy\-bits=10.0:/f or /Qimf\-accuracy\-bits:10.0:/f.
.TP
\fBDefault:\fR 
.TP 18
\-fimf\-precision=medium or /Qimf\-precision:medium
.NL
The compiler uses medium precision when calling math library functions. Note that other options can affect precision; see below for details.
.TP
\fBDescription:\fR 
.PP
This option defines the relative error, measured by the number of correct bits, for math library function results.
.NL
.PP
The following
formula is used to convert bits into ulps: ulps = 2p\-1\-bits,
where p is the number of the target format mantissa bits (24, 53,
and 64 for
single, double, and long double, respectively).
.NL
.PP
This option can affect run\-time performance and the accuracy of results.
.NL
.PP
If you need to define the accuracy for a math function of a certain precision, specify the function name of the precision that you need. For example, if you want double precision, you can specify :sin; if you want single precision, you can specify :sinf, as in the following: 
.NL
.IP \(bu 2
\-fimf\-accuracy\-bits=23:sinf,cosf,logf or /Qimf\-accuracy\-bits:23:sinf,cosf,logf
.IP \(bu 2
\-fimf\-accuracy\-bits=52:sqrt,/,trunc or /Qimf\-accuracy\-bits:52:sqrt,/,trunc
.IP \(bu 2
\-fimf\-accuracy\-bits=10:powf or /Qimf\-accuracy\-bits:10:powf
.PP
If you do not specify any function names, then the setting applies to all functions (and to all precisions). However, as soon as you specify an individual function name, the setting applies only to the function of corresponding precision. So, for example, sinf applies only to the single\-precision sine function, sin applies only to the double\-precision sine function, sinl applies only to the extended\-precision sine function, etc.  
.NL
.PP
There are three options you can use to express the maximum relative error.  They are as follows:
.NL
.IP \(bu 2
\-fimf\-precision (Linux* OS and OS X*) or /Qimf\-precision (Windows* OS)
.IP \(bu 2
\-fimf\-max\-error (Linux* OS and OS X*) or /Qimf\-max\-error (Windows* OS)
.IP \(bu 2
\-fimf\-accuracy\-bits (Linux OS and OS X*) or /Qimf\-accuracy\-bits (Windows OS)
.PP
If more than one of these options are specified, the default value for the maximum relative error is determined by the last one specified on the command line.
.NL
.PP
If none of the above options are specified, the default values for the maximum relative error are determined by the setting of the following options:
.NL
.IP \(bu 2
\-fast\-transcendentals (Linux OS and OS X) or 
/Qfast\-transcendentals (Windows OS)
.IP \(bu 2
\-prec\-div (Linux OS and OS X) or /Qprec\-div (Windows OS)
.IP \(bu 2
\-prec\-sqrt
(Linux OS and OS X) or /Qprec\-sqrt (Windows OS)
.IP \(bu 2
\-fp\-model (Linux OS and OS X) or /fp (Windows OS)
.PP
.B NOTE:
Many routines in libraries LIBM (Math Library) and SVML (Short Vector Math Library) are more highly optimized for Intel(R) microprocessors than for non\-Intel microprocessors.
.PP
.TP 18
\fBOptimization Notice 
\fR
.NL
.NL
.TP 18
= = = = = = = = = = 
.TP 18
Intel\[aq]s compilers may or may not optimize to the same degree for non\-Intel microprocessors for optimizations that are not unique to Intel microprocessors. These optimizations include SSE2, SSE3, and SSSE3 instruction sets and other optimizations. Intel does not guarantee the availability, functionality, or effectiveness of any optimization on microprocessors not manufactured by Intel. Microprocessor\-dependent optimizations in this product are intended for use with Intel microprocessors. Certain optimizations not specific to Intel microarchitecture are reserved for Intel microprocessors. Please refer to the applicable product User and Reference Guides for more information regarding the specific instruction sets covered by this notice. 
.TP 18
Notice revision #20110804 
.TP 18
= = = = = = = = = = 
.NL
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-fimf\-arch\-consistency=value[:funclist]
.RS
.TP
Ensures that the math library functions produce consistent results across different microarchitectural implementations of the same architecture.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.TP 18
\fIvalue\fR
.NL
Is one of the logical values "true" or "false".
.TP 18
\fIfunclist\fR
.NL
Is an optional list of one or more math library functions to which the attribute should be applied. If you specify more than one function, they must be separated with commas.  Precision\-specific variants like sin and sinf are considered different functions, so you would need to use \-fimf\-arch\-consistency=true:sin,sinf (or /Qimf\-arch\-consistency:true:sin,sinf) to specify consistent results for both the single\-precision and double\-precision sine functions. 
.IP
You also can specify the symbol /f to denote single\-precision divides, symbol / to denote double\-precision divides, symbol /l to denote extended\-precision divides, and symbol /q to denote quad\-precision divides. For example you can specify  \-fimf\-arch\-consistency=true:/ or /Qimf\-arch\-consistency:true:/.
.TP
\fBDefault:\fR 
.TP 18
false
.NL
Implementations of some math library functions may produce slightly different results on implementations of the same architecture.
.TP
\fBDescription:\fR 
.PP
This option ensures that the math library functions produce consistent results across different microarchitectural implementations of the same architecture (for example, across different microarchitectural implementations of IA\-32 architecture). Consistency is only guaranteed for a single binary. Consistency is not guaranteed across different architectures. For example, consistency is not guaranteed across IA\-32 architecture and Intel(R) 64 architecture.
.NL
.PP
If you need to define the accuracy for a math function of a certain precision, specify the function name of the precision that you need. For example, if you want double precision, you can specify :sin; if you want single precision, you can specify :sinf, as in \-fimf\-arch\-consistency=true:sin  or /Qimf\-arch\-consistency:true:sin, or \-fimf\-arch\-consistency=false:sqrtf or /Qimf\-arch\-consistency:false:sqrtf.
.NL
.PP
If you do not specify any function names, then the setting applies to all functions (and to all precisions). However, as soon as you specify an individual function name, the setting applies only to the function of corresponding precision. So, for example, sinf applies only to the single\-precision sine function, sin applies only to the double\-precision sine function, sinl applies only to the extended\-precision sine function, etc.  
.NL
.PP
The \-fimf\-arch\-consistency (Linux* OS and OS X*) and
/Qimf\-arch\-consistency (Windows* OS)
option may decrease run\-time performance, but the option will
provide bit\-wise consistent results on all Intel(R) processors and
compatible, non\-Intel processors,
regardless of micro\-architecture. This option may not provide bit\-wise
consistent results between different architectures, for example,
between IA\-32 and Intel(R) 64 architectures, or between Intel(R) 64 architecture and Intel(R) MIC Architecture.
.NL
.PP
.B NOTE:
Many routines in libraries LIBM (Math Library) and SVML (Short Vector Math Library) are more highly optimized for Intel(R) microprocessors than for non\-Intel microprocessors.
.PP
.TP 18
\fBOptimization Notice 
\fR
.NL
.NL
.TP 18
= = = = = = = = = = 
.TP 18
Intel\[aq]s compilers may or may not optimize to the same degree for non\-Intel microprocessors for optimizations that are not unique to Intel microprocessors. These optimizations include SSE2, SSE3, and SSSE3 instruction sets and other optimizations. Intel does not guarantee the availability, functionality, or effectiveness of any optimization on microprocessors not manufactured by Intel. Microprocessor\-dependent optimizations in this product are intended for use with Intel microprocessors. Certain optimizations not specific to Intel microarchitecture are reserved for Intel microprocessors. Please refer to the applicable product User and Reference Guides for more information regarding the specific instruction sets covered by this notice. 
.TP 18
Notice revision #20110804 
.TP 18
= = = = = = = = = = 
.NL
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-fimf\-domain\-exclusion=classlist[:funclist]
.RS
.TP
Indicates the input arguments domain on which math functions must provide correct results. 
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.TP 18
\fIclasslist\fR
.NL
Is one of the following: 
.RS
.IP \(bu 2
One or more of the following floating\-point value classes you can exclude from the function domain without affecting the correctness of your program. The supported class names are:
.RS
extremes
This class is for values which do not lie within the usual domain of arguments for a given function.
nans
This means "x=Nan".
infinities
This means "x=infinities".
denormals
This means "x=denormal".
zeros
This means "x=0".
.RE
Each \fIclasslist\fR element corresponds to a power of two. The exclusion attribute is the logical or of the associated powers of two (that is, a bitmask). 
The following shows the current mapping from \fIclasslist\fR mnemonics to numerical values:
.TP 18
extremes
.NL
1
.NL
.TP 18
nans
.NL
2
.NL
.TP 18
infinities
.NL
4
.NL
.TP 18
denormals
.NL
8
.NL
.TP 18
zeros
.NL
16
.NL
.TP 18
none
.NL
0
.NL
.TP 18
all
.NL
31
.NL
.TP 18
common
.NL
15
.NL
.TP 18
other combinations
.NL
bitwise OR of the used values
.NL
You must specify the integer value that corresponds to the class that you want to exclude. 
Note that on excluded values, unexpected results may occur.
.IP \(bu 2
One of the following short\-hand tokens:
.RS
none
This means that none of the supported classes are excluded from the domain. To indicate this token, specify 0, as in \-fimf\-domain\-exclusion=0 (or /Qimf\-domain\-exclusion:0).
all
This means that all of the supported classes are excluded from the domain. To indicate this token, specify 31, as in \-fimf\-domain\-exclusion=31 (or /Qimf\-domain\-exclusion:31).
common
This is the same as specifying extremes,nans,infinities,denormals. To indicate this token, specify 15 (1 + 2+ 4 + 8), as in \-fimf\-domain\-exclusion=15 (or /Qimf\-domain\-exclusion:15)
.RE
.RE
.TP 18
\fIfunclist\fR
.NL
Is an optional list of one or more math library functions to which the attribute should be applied. If you specify more than one function, they must be separated with commas.  Precision\-specific variants like sin and sinf are considered different functions, so you would need to use \-fimf\-domain\-exclusion=4:sin,sinf (or /Qimf\-domain\-exclusion:4:sin,sinf) to specify infinities for both the single\-precision and double\-precision sine functions. 
.IP
You also can specify the symbol /f to denote single\-precision divides, symbol / to denote double\-precision divides, symbol /l to denote extended\-precision divides, and symbol /q to denote quad\-precision divides. For example, you can specify:
.IP
\-fimf\-domain\-exclusion=4 or /Qimf\-domain\-exclusion:4
.IP
\-fimf\-domain\-exclusion=5:/,powf or /Qimf\-domain\-exclusion:5:/,powf
.IP
\-fimf\-domain\-exclusion=23:log,logf,/,sin,cosf or /Qimf\-domain\-exclusion:23:log,logf,/,sin,cosf
.IP
If you don’t specify argument \fIfunclist\fR, the domain restrictions apply to all math library functions.
.TP
\fBDefault:\fR 
.TP 18
Zero ("0")
.NL
The compiler uses default heuristics when calling math library functions.
.TP
\fBDescription:\fR 
.PP
This option indicates the input arguments domain on which math functions must provide correct results. It specifies that your program will function correctly if the functions specified in \fIfunclist\fR do not produce standard conforming results on the number classes.
.NL
.PP
This option can affect run\-time performance and the accuracy of results.  As more classes are excluded, faster code sequences can be used.
.NL
.PP
If you need to define the accuracy for a math function of a certain precision, specify the function name of the precision that you need. For example, if you want double precision, you can specify :sin; if you want single precision, you can specify :sinf, as in \-fimf\-domain\-exclusion=denormals:sin  or /Qimf\-domain\-exclusion:denormals:sin, or \-fimf\-domain\-exclusion=extremes:sqrtf or /Qimf domain\-exclusion:extremes:sqrtf.
.NL
.PP
If you do not specify any function names, then the setting applies to all functions (and to all precisions). However, as soon as you specify an individual function name, the setting applies only to the function of corresponding precision. So, for example, sinf applies only to the single\-precision sine function, sin applies only to the double\-precision sine function, sinl applies only to the extended\-precision sine function, etc.  
.NL
.PP
.B NOTE:
Many routines in libraries LIBM (Math Library) and SVML (Short Vector Math Library) are more highly optimized for Intel(R) microprocessors than for non\-Intel microprocessors.
.PP
.TP 18
\fBOptimization Notice 
\fR
.NL
.NL
.TP 18
= = = = = = = = = = 
.TP 18
Intel\[aq]s compilers may or may not optimize to the same degree for non\-Intel microprocessors for optimizations that are not unique to Intel microprocessors. These optimizations include SSE2, SSE3, and SSSE3 instruction sets and other optimizations. Intel does not guarantee the availability, functionality, or effectiveness of any optimization on microprocessors not manufactured by Intel. Microprocessor\-dependent optimizations in this product are intended for use with Intel microprocessors. Certain optimizations not specific to Intel microarchitecture are reserved for Intel microprocessors. Please refer to the applicable product User and Reference Guides for more information regarding the specific instruction sets covered by this notice. 
.TP 18
Notice revision #20110804 
.TP 18
= = = = = = = = = = 
.NL
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-fimf\-max\-error=ulps[:funclist]
.RS
.TP
Defines the maximum allowable relative error for math library function results, including division and square root.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.TP 18
\fIulps\fR
.NL
Is a positive, floating\-point number indicating the maximum allowable relative error the compiler should use.  
.IP
The format for the number is [digits] [.digits] [ { e | E
}[sign]digits].
.TP 18
\fIfunclist\fR
.NL
Is an optional list of one or more math library functions to which the attribute should be applied. If you specify more than one function, they must be separated with commas.  Precision\-specific variants like sin and sinf are considered different functions, so you would need to use \-fimf\-max\-error=4.0:sin,sinf (or /Qimf\-max\-error=4.0:sin,sinf) to specify the maximum allowable relative error for both the single\-precision and double\-precision sine functions. 
.IP
You also can specify the symbol /f to denote single\-precision divides, symbol / to denote double\-precision divides, symbol /l to denote extended\-precision divides, and symbol /q to denote quad\-precision divides. For example you can specify  \-fimf\-max\-error=4.0:/ or /Qimf\-max\-error:4.0:/.
.TP
\fBDefault:\fR 
.TP 18
\-fimf\-precision=medium or /Qimf\-precision:medium
.NL
The compiler uses medium precision when calling math library functions. Note that other options can affect precision; see below for details.
.TP
\fBDescription:\fR 
.PP
This option defines the maximum allowable relative error, measured in ulps, for math library function results. 
.NL
.PP
This option can affect run\-time performance and the accuracy of results.
.NL
.PP
If you need to define the accuracy for a math function of a certain precision, specify the function name of the precision that you need. For example, if you want double precision, you can specify :sin; if you want single precision, you can specify :sinf, as in \-fimf\-max\-error=4.0:sin  or /Qimf\-max\-error:4.0:sin, or \-fimf\-max\-error=4.0:sqrtf or /Qimf\-max\-error:4.0:sqrtf.
.NL
.PP
If you do not specify any function names, then the setting applies to all functions (and to all precisions). However, as soon as you specify an individual function name, the setting applies only to the function of corresponding precision. So, for example, sinf applies only to the single\-precision sine function, sin applies only to the double\-precision sine function, sinl applies only to the extended\-precision sine function, etc.  
.NL
.PP
There are three options you can use to express the maximum relative error.  They are as follows:
.NL
.IP \(bu 2
\-fimf\-precision (Linux* OS and OS X*) or /Qimf\-precision (Windows* OS)
.IP \(bu 2
\-fimf\-max\-error (Linux* OS and OS X*) or /Qimf\-max\-error (Windows* OS)
.IP \(bu 2
\-fimf\-accuracy\-bits (Linux OS and OS X*) or /Qimf\-accuracy\-bits (Windows OS)
.PP
If more than one of these options are specified, the default value for the maximum relative error is determined by the last one specified on the command line.
.NL
.PP
If none of the above options are specified, the default values for the maximum relative error are determined by the setting of the following options:
.NL
.IP \(bu 2
\-fast\-transcendentals (Linux OS and OS X) or 
/Qfast\-transcendentals (Windows OS)
.IP \(bu 2
\-prec\-div (Linux OS and OS X) or /Qprec\-div (Windows OS)
.IP \(bu 2
\-prec\-sqrt
(Linux OS and OS X) or /Qprec\-sqrt (Windows OS)
.IP \(bu 2
\-fp\-model (Linux OS and OS X) or /fp (Windows OS)
.PP
.B NOTE:
Many routines in libraries LIBM (Math Library) and SVML (Short Vector Math Library) are more highly optimized for Intel(R) microprocessors than for non\-Intel microprocessors.
.PP
.TP 18
\fBOptimization Notice 
\fR
.NL
.NL
.TP 18
= = = = = = = = = = 
.TP 18
Intel\[aq]s compilers may or may not optimize to the same degree for non\-Intel microprocessors for optimizations that are not unique to Intel microprocessors. These optimizations include SSE2, SSE3, and SSSE3 instruction sets and other optimizations. Intel does not guarantee the availability, functionality, or effectiveness of any optimization on microprocessors not manufactured by Intel. Microprocessor\-dependent optimizations in this product are intended for use with Intel microprocessors. Certain optimizations not specific to Intel microarchitecture are reserved for Intel microprocessors. Please refer to the applicable product User and Reference Guides for more information regarding the specific instruction sets covered by this notice. 
.TP 18
Notice revision #20110804 
.TP 18
= = = = = = = = = = 
.NL
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-fimf\-precision[=value[:funclist]]
.RS
.TP
Lets you specify a level of accuracy (precision) that the compiler should use when determining which math library functions to use.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.TP 18
\fIvalue\fR
.NL
Is one of the following values denoting the desired accuracy: 
.RS
.TP 15
high
This is equivalent to max\-error = 0.6.
.TP 15
medium
This is equivalent to max\-error = 4; this is the default setting if the option is specified and \fIvalue\fR is omitted.
.TP 15
low
This is equivalent to accuracy\-bits = 11 for single\-precision functions; accuracy\-bits = 26 for double\-precision functions.
.RE
.IP
In the above explanations, max\-error
means option  \-fimf\-max\-error (Linux* OS and OS X*) or
/Qimf\-max\-error (Windows* OS);  accuracy\-bits means option \-fimf\-accuracy\-bits (Linux* OS and OS X*) or /Qimf\-accuracy\-bits (Windows* OS).
.TP 18
\fIfunclist\fR
.NL
Is an optional list of one or more math library functions to which the attribute should be applied. If you specify more than one function, they must be separated with commas.  Precision\-specific variants like sin and sinf are considered different functions, so you would need to use \-fimf\-precision=high:sin,sinf (or /Qimf\-precision:high:sin,sinf) to specify high precision for both the single\-precision and double\-precision sine functions. 
.IP
You also can specify the symbol /f to denote single\-precision divides, symbol / to denote double\-precision divides, symbol /l to denote extended\-precision divides, and symbol /q to denote quad\-precision divides. For example you can specify \-fimf\-precision=low:/ or /Qimf\-precision:low:/ and \-fimf\-precision=low:/f or /Qimf\-precision:low:/f.
.TP
\fBDefault:\fR 
.TP 18
medium
.NL
The compiler uses medium precision when calling math library functions. Note that other options can affect precision; see below for details.
.TP
\fBDescription:\fR 
.PP
This option lets you specify a level of accuracy (precision) that the compiler should use when determining which math library functions to use. 
.NL
.PP
This option can be used to improve run\-time performance if reduced accuracy is sufficient for the application, or it can be used to increase the accuracy of math library functions selected by the compiler.
.NL
.PP
In general, using a lower precision can improve run\-time performance and using a higher precision may reduce run\-time performance.
.NL
.PP
If you need to define the accuracy for a math function of a certain precision, specify the function name of the precision that you need.  For example, if you want double precision, you can specify :sin; if you want single precision, you can specify :sinf, as  in \-fimf\-precision=low:sin  or /Qimf\-precision:low:sin, or \-fimf\-precision=high:sqrtf or /Qimf\-precision:high:sqrtf.
.NL
.PP
If you do not specify any function names, then the setting applies to all functions (and to all precisions). However, as soon as you specify an individual function name, the setting applies only to the function of corresponding precision. So, for example, sinf applies only to the single\-precision sine function, sin applies only to the double\-precision sine function, sinl applies only to the extended\-precision sine function, etc. 
.NL
.PP
There are three options you can use to express the maximum relative error.  They are as follows:
.NL
.IP \(bu 2
\-fimf\-precision (Linux* OS and OS X*) or /Qimf\-precision (Windows* OS)
.IP \(bu 2
\-fimf\-max\-error (Linux* OS and OS X*) or /Qimf\-max\-error (Windows* OS)
.IP \(bu 2
\-fimf\-accuracy\-bits (Linux OS and OS X*) or /Qimf\-accuracy\-bits (Windows OS)
.PP
If more than one of these options are specified, the default value for the maximum relative error is determined by the last one specified on the command line.
.NL
.PP
If none of the above options are specified, the default values for the maximum relative error are determined by the setting of the following options:
.NL
.IP \(bu 2
\-fast\-transcendentals (Linux OS and OS X) or 
/Qfast\-transcendentals (Windows OS)
.IP \(bu 2
\-prec\-div (Linux OS and OS X) or /Qprec\-div (Windows OS)
.IP \(bu 2
\-prec\-sqrt
(Linux OS and OS X) or /Qprec\-sqrt (Windows OS)
.IP \(bu 2
\-fp\-model (Linux OS and OS X) or /fp (Windows OS)
.PP
.B NOTE:
Many routines in libraries LIBM (Math Library) and SVML (Short Vector Math Library) are more highly optimized for Intel(R) microprocessors than for non\-Intel microprocessors.
.PP
.TP 18
\fBOptimization Notice 
\fR
.NL
.NL
.TP 18
= = = = = = = = = = 
.TP 18
Intel\[aq]s compilers may or may not optimize to the same degree for non\-Intel microprocessors for optimizations that are not unique to Intel microprocessors. These optimizations include SSE2, SSE3, and SSSE3 instruction sets and other optimizations. Intel does not guarantee the availability, functionality, or effectiveness of any optimization on microprocessors not manufactured by Intel. Microprocessor\-dependent optimizations in this product are intended for use with Intel microprocessors. Certain optimizations not specific to Intel microarchitecture are reserved for Intel microprocessors. Please refer to the applicable product User and Reference Guides for more information regarding the specific instruction sets covered by this notice. 
.TP 18
Notice revision #20110804 
.TP 18
= = = = = = = = = = 
.NL
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-finline
.TP
.B
\-fno\-inline
.RS
.TP
Tells the compiler to inline functions declared with __inline and perform C++ inlining.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-fno\-inline
.NL
The compiler does not inline functions declared with __inline.
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to inline functions declared with __inline and perform C++ inlining.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-finline\-functions
.TP
.B
\-fno\-inline\-functions
.RS
.TP
Enables function inlining for single file compilation.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-finline\-functions
.NL
Interprocedural optimizations occur. However, if you specify \-O0, the default is OFF.
.TP
\fBDescription:\fR 
.PP
This option enables function inlining for single file compilation. 
.NL
.PP
It enables the compiler to perform inline function expansion for calls to functions defined within the current source file.
.NL
.PP
The compiler applies a heuristic to perform the function expansion. To specify the size of the function to be expanded, use the \-finline\-limit option.
.NL
.TP
\fBAlternate Options:\fR 
.PP
Linux and OS X: \-inline\-level=2
.NL
.RE
.TP
.B
\-finline\-limit=n
.RS
.TP
Lets you specify the maximum size of a function to be inlined.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.TP 18
\fIn\fR
.NL
Must be an integer greater than or equal to zero. It is the maximum number of lines the function can have to be considered for inlining.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler uses default heuristics when inlining functions.
.TP
\fBDescription:\fR 
.PP
This option lets you specify the maximum size of a function to be inlined. The compiler inlines smaller functions, but this option lets you inline large functions. For example, to indicate a large function, you could specify 100 or 1000 for \fIn\fR.
.NL
.PP
Note that parts of functions cannot be inlined, only whole functions.
.NL
.PP
This option is a modification of the \-finline\-functions option, whose behavior occurs by default.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-finstrument\-functions
.TP
.B
\-fno\-instrument\-functions
.RS
.TP
Determines whether function entry and exit points are instrumented.
.NL
.TP
\fBArchitectures:\fR IA\-32, Intel(R) 64 architecture
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-fno\-instrument\-functions 
.NL
Function entry and exit points are not instrumented.
.TP
\fBDescription:\fR 
.PP
This option determines whether function entry and exit points are instrumented. It may increase execution time.
.NL
.PP
The following profiling functions are called with the address of the current function and the address of where the function was called (its "call site"):
.NL
.IP \(bu 2
This function is called upon function entry:
.RS
.IP \(bu 2
.IP
void __cyg_profile_func_enter (void *this_fn,
.IP
void *call_site);
.RE
.IP \(bu 2
This function is called upon function exit:
.RS
.IP \(bu 2
.IP
void __cyg_profile_func_exit (void *this_fn,
.IP
void *call_site);
.RE
.PP
These functions can be used to gather more information, such as profiling information or timing information. Note that it is the user\[aq]s responsibility to provide these profiling functions.
.NL
.PP
If you specify \-finstrument\-functions (Linux* OS and OS X*) or /Qinstrument\-functions (Windows* OS), function inlining is disabled. If you specify \-fno\-instrument\-functions or /Qinstrument\-functions\-, inlining is not disabled.
.NL
.PP
On Linux and OS X systems, you can use the following attribute to stop an individual function from being instrumented:
.NL
.PP
__attribute__((__no_instrument_function__))
.PP
.PP
It also stops inlining from being disabled for that individual function.
.NL
.PP
This option is provided for compatibility with gcc.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-fjump\-tables
.TP
.B
\-fno\-jump\-tables
.RS
.TP
Determines whether jump tables are generated for switch statements. 
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-fjump\-tables
.NL
The compiler uses jump tables for switch statements.
.TP
\fBDescription:\fR 
.PP
This option determines whether jump tables are generated for switch statements.
.NL
.PP
Option \-fno\-jump\-tables prevents the compiler from generating jump tables for switch statements. This action is performed unconditionally and independent of any generated code performance consideration.
.NL
.PP
Option \-fno\-jump\-tables also prevents the compiler from creating switch statements internally as a result of optimizations.
.NL
.PP
Use \-fno\-jump\-tables with \-fpic when compiling objects that will be loaded in a way where the jump table relocation cannot be resolved.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-fkeep\-static\-consts
.TP
.B
\-fno\-keep\-static\-consts
.RS
.TP
Tells the compiler to preserve allocation of variables that are not referenced in the source.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-fno\-keep\-static\-consts
.NL
If a variable is never referenced in a routine, the variable is discarded unless optimizations are disabled by option \-O0 (Linux* OS and OS X*).
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to preserve allocation of variables that are not referenced in the source.
.NL
.PP
The negated form can be useful when optimizations are enabled to reduce the memory usage of static data.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-fma
.TP
.B
\-no\-fma
.RS
.TP
Determines whether the compiler generates fused multiply\-add (FMA) instructions if such instructions exist on the target processor. 
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-fma 
.NL
If the instructions exist on the target processor, the compiler generates fused multiply\-add (FMA) instructions.
.IP
However, if you specify 
\-fp\-model strict (Linux* OS and OS X*), but do not explicitly specify \-fma, the default is \-no\-fma.  
.TP
\fBDescription:\fR 
.PP
This option determines whether the compiler
generates fused multiply\-add (FMA) instructions if such instructions exist on the target processor. When \-fma (Linux OS and OS X) or /Qfma (Windows OS)
is specified, the compiler may generate FMA
instructions for combining multiply and add operations. When
\-no\-fma (Linux  OS and OS X) or /Qfma\- (Windows OS) is specified, the
compiler must generate separate multiply and add
instructions with intermediate rounding.
.NL
.PP
This option has no effect unless setting CORE\-AVX2 or higher is specified for option \-x (Linux  OS and OS X) or /Qx (Windows OS),  or options \-march (Linux OS and OS X) or /arch (Windows OS).
.NL
.RE
.TP
.B
\-fmath\-errno
.TP
.B
\-fno\-math\-errno
.RS
.TP
Tells the compiler that errno can be reliably tested after calls to standard math library functions.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-fno\-math\-errno
.NL
The compiler assumes that the program does not test errno after calls to standard math library functions.
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to assume that the program tests errno after calls to math library functions. This restricts optimization because it causes the compiler to treat most math functions as having side effects.
.NL
.PP
Option \-fno\-math\-errno tells the compiler to assume that the program does not test errno after calls to math library functions. This frequently allows the compiler to generate faster code. Floating\-point code that relies on IEEE exceptions instead of errno to detect errors can safely use this option to improve performance.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-fmerge\-debug\-strings (L*X only)
.TP
.B
\-fno\-merge\-debug\-strings (L*X only)
.RS
.TP
Causes the compiler to pool strings used in debugging information.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-fmerge\-debug\-strings
.NL
The compiler will pool strings used in debugging information.
.TP
\fBDescription:\fR 
.PP
This option causes the compiler to pool strings
used in debugging information. The linker will automatically retain
this pooling.
.NL
.PP
This option can reduce the size of debug
information, but it may produce slightly slower compile and link
times.
.NL
.PP
This option is only turned on by default if you
are using gcc 4.3 or later, where this setting is also the default,
since the generated debug tables require binutils version 2.17 or
later to work reliably.
.NL
.PP
If you do not want the compiler to pool strings
used in debugging information, specify option
\-fno\-merge\-debug\-strings.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-fminshared
.RS
.TP
Specifies that a compilation unit is a component of a main program and should not be linked as part of a shareable object.
.NL
.TP
\fBArchitectures:\fR IA\-32, Intel(R) 64 architecture
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
Source files are compiled together to form a single object file.
.TP
\fBDescription:\fR 
.PP
This option specifies that a compilation unit is a component of a main program and should not be linked as part of a shareable object.
.NL
.PP
This option allows the compiler to optimize references to defined symbols without special visibility settings. To ensure that external and common symbol references are optimized, you need to specify visibility hidden or protected by using the \-fvisibility, \-fvisibility\-hidden, or \-fvisibility\-protected option.
.NL
.PP
Also, the compiler does not need to generate position\-independent code for the main program. It can use absolute addressing, which may reduce the size of the global offset table (GOT) and may reduce memory traffic.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-fms\-dialect[=ver]
.RS
.TP
Enables support for a language dialect that is compatible with Microsoft* Windows, while maintaining link compatibility with gcc. This option is deprecated on OS* X systems.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.TP 18
\fIver\fR
.NL
Indicates that the language dialect should be compatible with a certain version of Microsoft* Visual Studio. Possible values are: 
.RS
.TP 15
10
Specifies the dialect should be compatible with Microsoft* Visual Studio 2010.
.TP 15
9
Specifies the dialect should be compatible with Microsoft* Visual Studio 2008. This is the default if you do not specify \fIver\fR.
.RE
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler does not support a language dialect that is compatible with Microsoft* Windows.
.TP
\fBDescription:\fR 
.PP
This option enables support for a language dialect that is compatible with Microsoft* Windows, while maintaining link compatibility with gcc. It allows portability of code written on Windows* OS that uses Microsoft extensions or language features.  
.NL
.TP
\fBAlternate Options:\fR 
.PP
Linux and OS X: None
.NL
.RE
.TP
.B
\-fmudflap (L*X only)
.RS
.TP
The compiler instruments risky pointer operations to prevent buffer overflows and invalid heap use.
.NL
.TP
\fBArchitectures:\fR IA\-32, Intel(R) 64 architecture
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler does not instrument risky pointer operations.
.TP
\fBDescription:\fR 
.PP
The compiler instruments risky pointer operations to prevent buffer overflows and invalid heap use. Requires gcc 4.0 or newer.
.NL
.PP
When using this compiler option, you must specify linker option \-lmudflap in the link command line to resolve references to the libmudflap library.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-fno\-gnu\-keywords
.RS
.TP
Tells the compiler to not recognize typeof as a keyword.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
Keyword typeof
is recognized.
.TP
\fBDescription:\fR 
.PP
Tells the compiler to not recognize typeof as a  keyword.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-fno\-implicit\-inline\-templates
.RS
.TP
Tells the compiler to not emit code for implicit instantiations of inline templates.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler handles inlines so that compilations, with and without optimization, will need the same set of explicit instantiations.
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to not emit code for implicit instantiations of inline templates.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-fno\-implicit\-templates
.RS
.TP
Tells the compiler to not emit code for non\-inline templates that are instantiated implicitly. 
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler handles inlines so that compilations, with and without optimization, will need the same set of explicit instantiations.
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to not emit code for non\-inline templates that are instantiated implicitly, but to only emit code for explicit instantiations.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-fnon\-call\-exceptions
.TP
.B
\-fno\-non\-call\-exceptions
.RS
.TP
Allows trapping instructions to throw C++ exceptions.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-fno\-non\-call\-exceptions
.NL
C++ exceptions are not thrown from trapping instructions.
.TP
\fBDescription:\fR 
.PP
This option allows trapping instructions to throw C++ exceptions. It allows hardware signals generated by trapping instructions to be converted into C++ exceptions and caught using the standard C++ exception handling mechanism. Examples of such signals are SIGFPE (floating\-point exception) and SIGSEGV (segmentation violation). 
.NL
.PP
You must write a signal handler that catches the signal and throws a C++ exception. After that, any occurrence of that signal within a C++ try block can be caught by a C++ catch handler of the same type as the C++ exception thrown within the signal handler.
.NL
.PP
Only signals generated by trapping instructions (that is, memory access instructions and floating\-point instructions) can be caught. Signals that can occur at any time, such as SIGALRM, cannot be caught in this manner.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-fnon\-lvalue\-assign
.TP
.B
\-fno\-non\-lvalue\-assign
.RS
.TP
Determines whether casts and conditional expressions can be used as lvalues.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-fnon\-lvalue\-assign
.NL
The compiler allows casts and conditional expressions to be used as lvalues.
.TP
\fBDescription:\fR 
.PP
This option determines whether casts and conditional expressions can be used as lvalues.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-fno\-operator\-names
.RS
.TP
Disables support for the operator names specified in the standard.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
.TP
\fBDescription:\fR 
.PP
Disables support for the operator names specified in the standard.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-fno\-rtti
.RS
.TP
Disables support for run\-time type information (RTTI). 
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
.TP
\fBDescription:\fR 
.PP
This option disables support for run\-time type information (RTTI).
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-fomit\-frame\-pointer
.TP
.B
\-fno\-omit\-frame\-pointer
.RS
.TP
Determines whether EBP is used as a general\-purpose register in optimizations.
.NL
.TP
\fBArchitectures:\fR \-f[no\-]omit\-frame\-pointer: All/Oy[\-]: IA\-32 architecture
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-fomit\-frame\-pointer 
.NL
EBP is used as a general\-purpose register in optimizations. However, on Linux* and OS X* systems, the default is \-fno\-omit\-frame\-pointer if option \-O0 or \-g is specified. 
.TP
\fBDescription:\fR 
.PP
These options determine whether EBP is used as a general\-purpose register in optimizations. Options \-fomit\-frame\-pointer and /Oy allow this use. Options \-fno\-omit\-frame\-pointer and /Oy\- disallow it.
.NL
.PP
Some debuggers expect EBP to be used as a stack frame pointer, and cannot produce a stack backtrace unless this is so. The \-fno\-omit\-frame\-pointer and /Oy\- options direct the compiler to generate code that maintains and uses EBP as a stack frame pointer for all functions so that a debugger can still produce a stack backtrace without doing the following:
.NL
.IP \(bu 2
For \-fno\-omit\-frame\-pointer: turning off optimizations with \-O0
.IP \(bu 2
For /Oy\-: turning off /O1, /O2, or /O3 optimizations
.PP
The \-fno\-omit\-frame\-pointer option is set when you specify option \-O0 or the \-g option. The \-fomit\-frame\-pointer option is set when you specify option \-O1, \-O2, or \-O3.
.NL
.PP
The /Oy option is set when you specify the /O1, /O2, or /O3 option. Option /Oy\- is set when you specify the /Od option.
.NL
.PP
Using the \-fno\-omit\-frame\-pointer or /Oy\- option reduces the number of available general\-purpose registers by 1, and can result in slightly less efficient code.
.NL
.PP
.B NOTE:
There is currently an issue with GCC 3.2 exception handling. Therefore, the Intel compiler ignores this option when GCC 3.2 is installed for C++ and exception handling is turned on (the default).
.TP
\fBAlternate Options:\fR 
.PP
Linux and OS X: \-fp (this is a deprecated option)
.NL
.RE
.TP
.B
\-fp\-model keyword
.RS
.TP
Controls the semantics of floating\-point calculations.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.TP 18
\fIkeyword\fR
.NL
Specifies the semantics to be used. Possible values are:
.RS
.TP 15
precise
Disables optimizations that are not  value\-safe on floating\-point data.
.TP 15
fast[=1|2]
Enables more aggressive optimizations on floating\-point data.
.TP 15
strict
Enables precise and except, disables contractions, and 
enables pragma stdc fenv_access.
.TP 15
source
Rounds intermediate results to source\-defined precision.
.TP 15
double
Rounds intermediate results to 53\-bit (double) precision.
.TP 15
extended
Rounds intermediate results to 64\-bit (extended) precision.
.TP 15
[no\-]except (Linux* OS and OS X*) or except[\-] (Windows* OS)
Determines whether strict floating\-point exception semantics are honored.
.RE
.TP
\fBDefault:\fR 
.TP 18
\-fp\-model fast=1 
.NL
The compiler uses more aggressive optimizations on floating\-point calculations.
.TP
\fBDescription:\fR 
.PP
This option controls the semantics of floating\-point calculations.
.NL
.PP
The \fIkeywords\fR can be considered in groups:
.NL
.IP \(bu 2
Group A: precise, fast, strict
.IP \(bu 2
Group B: source, double, extended
.IP \(bu 2
Group C: except (or the negative form) 
.PP
You can use more than one \fIkeyword\fR. However, the following rules apply:
.NL
.IP \(bu 2
You cannot specify fast and except together in the same compilation. You can specify any other combination of group A, group B, and group C. Since fast is the default, you must not specify except without a group A or group B \fIkeyword\fR.
.IP \(bu 2
You should specify only one \fIkeyword\fR from group A and only one \fIkeyword\fR from  group B. If you try to specify more than one \fIkeyword\fR from either group A or group B, the last (rightmost) one takes effect.
.IP \(bu 2
If you specify except more than once, the last (rightmost) one takes effect.
.PP
The floating\-point (FP) environment is a collection of registers that control the behavior of FP machine instructions and indicate the current FP status. The floating\-point environment may include rounding\-mode controls, exception masks, flush\-to\-zero controls, exception status flags, and other floating\-point related features.
.NL
.TP 18
\fBOption\fR
.NL
.NL
\fBDescription\fR
.NL
.NL
.TP 18
\-fp\-model precise or /fp:precise
.NL
Tells the compiler to strictly adhere to value\-safe optimizations when implementing floating\-point calculations. It disables optimizations that can change the result of floating\-point calculations, which is required for strict ANSI conformance. 
.TP 18
These semantics ensure the reproducibility of floating\-point computations for serial code, including code vectorized or auto\-parallelized by the compiler, but they may slow performance. They do not ensure value safety or run\-to\-run reproducibility of other parallel code.  
Run\-to\-run reproducibility for floating\-point reductions in OpenMP* code may be obtained for a fixed number of threads through the KMP_DETERMINISTIC_REDUCTION environment variable. 
For more information about this environment variable, see 
\fISetting Environment Variables\fR
.
.TP 18
The compiler assumes the default floating\-point environment; you are not allowed to modify it.
.TP 18
Intermediate results are computed with the precision shown in the following table, unless it is overridden by a keyword from Group B: 
.TP 18
IA\-32 architecture: Windows: Double; Linux: Extended; OS X: Extended
.TP 18
Intel(R) 64 architecture: All operating systems: Source
.TP 18
Floating\-point exception semantics are disabled by default. To enable these semantics, you must also specify \-fp\-model except or /fp:except.
.NL
.TP 18
\-fp\-model fast[=1|2] or /fp:fast[=1|2]
.NL
Tells the compiler to use more aggressive optimizations when implementing floating\-point calculations. These optimizations increase speed,  but may affect the accuracy or reproducibility of floating\-point computations.
.TP 18
Specifying fast is the same as specifying fast=1. fast=2 may produce faster and less accurate results.
.TP 18
Floating\-point exception semantics are disabled by default and they cannot be enabled because you cannot specify fast and except together in the same compilation. To enable exception semantics, you must explicitly specify another keyword (see other keyword descriptions for details).
.NL
.TP 18
\-fp\-model strict or /fp:strict
.NL
Tells the compiler to strictly adhere to value\-safe optimizations when implementing floating\-point calculations and enables floating\-point exception semantics. This is the strictest floating\-point model.
.TP 18
The compiler does not assume the default floating\-point environment; you are allowed to modify it.
.TP 18
Floating\-point exception semantics can be disabled by explicitly specifying \-fp\-model no\-except or /fp:except\-.
.NL
.TP 18
\-fp\-model source or /fp:source
.NL
This option causes intermediate results to be rounded to the precision defined in the source code. It also implies keyword precise unless it is overridden by a keyword from Group A.
.TP 18
Intermediate expressions use the precision of the operand with higher precision, if any.
.TP 18
long double: 64\-bit precision; 80\-bit data type; 15\-bit exponent
.TP 18
double: 53\-bit precision; 64\-bit data type; 11\-bit exponent; on Windows systems using IA\-32 architecture, the exponent may be 15\-bit if an x87 register is used to hold the value.
.TP 18
float: 24\-bit precision; 32\-bit data type; 8\-bit exponent
.TP 18
The compiler assumes the default floating\-point environment; you are not allowed to modify it.
.NL
.TP 18
\-fp\-model double or /fp:double
.NL
This option causes intermediate results to be rounded as follows:
.TP 18
53\-bit (double) precision
.NL
.TP 18
64\-bit data type
.NL
.TP 18
11\-bit exponent; on Windows systems using IA\-32 architecture, the exponent may be 15\-bit if an x87 register is used to hold the value.
.NL
.TP 18
53\-bit (double) precision
.TP 18
64\-bit data type
.TP 18
11\-bit exponent; on Windows systems using IA\-32 architecture, the exponent may be 15\-bit if an x87 register is used to hold the value.
.TP 18
This option also implies keyword precise unless it is overridden by a keyword from Group A.
.TP 18
The compiler assumes the default floating\-point environment; you are not allowed to modify it.
.NL
.TP 18
\-fp\-model extended or /fp:extended
.NL
This option causes intermediate results to be rounded as follows:
.TP 18
64\-bit (extended) precision
.NL
.TP 18
80\-bit data type
.NL
.TP 18
15\-bit exponent
.NL
.TP 18
64\-bit (extended) precision
.TP 18
80\-bit data type
.TP 18
15\-bit exponent
.TP 18
This option also implies keyword precise unless it is overridden by a keyword from Group A.
.TP 18
The compiler assumes the default floating\-point environment; you are not allowed to modify it.
.NL
.TP 18
\-fp\-model except or /fp:except
.NL
Tells the compiler to follow strict floating\-point exception semantics.
.NL
.PP
The \-fp\-model and /fp  options determine the setting for the
maximum allowable relative error for math library function results
(max\-error) if none of the following options are
specified:
.NL
.IP \(bu 2
\-fimf\-accuracy\-bits (Linux* OS and OS X*) or
/Qimf\-accuracy\-bits (Windows* OS)
.IP \(bu 2
\-fimf\-max\-error (Linux OS and OS X) or
/Qimf\-max\-error (Windows OS)
.IP \(bu 2
\-fimf\-precision (Linux OS and OS X) or
/Qimf\-precision (Windows OS)
.IP \(bu 2
\-fast\-transcendentals (Linux OS and OS X) or 
/Qfast\-transcendentals (Windows OS)
.PP
Option \-fp\-model fast (and /fp:fast) sets option \-fimf\-precision=medium (/Qimf\-precision:medium) and option \-fp\-model precise (and /fp:precise) implies \-fimf\-precision=high (and /Qimf\-precision:high). Option \-fp\-model fast=2 (and /fp:fast2) sets option \-fimf\-precision=medium (and /Qimf\-precision:medium) and option \-fimf\-domain\-exclusion=15 (and /Qimf\-domain\-exclusion=15).
.NL
.PP
.B NOTE:
On Windows and Linux operating systems on IA\-32 architecture,  the compiler, by default, implements floating\-point (FP) arithmetic using SSE2 and SSE instructions. This can cause differences in floating\-point results when compared to previous x87 implementations.
.PP
.TP 18
\fBOptimization Notice 
\fR
.NL
.NL
.TP 18
= = = = = = = = = = 
.TP 18
Intel\[aq]s compilers may or may not optimize to the same degree for non\-Intel microprocessors for optimizations that are not unique to Intel microprocessors. These optimizations include SSE2, SSE3, and SSSE3 instruction sets and other optimizations. Intel does not guarantee the availability, functionality, or effectiveness of any optimization on microprocessors not manufactured by Intel. Microprocessor\-dependent optimizations in this product are intended for use with Intel microprocessors. Certain optimizations not specific to Intel microarchitecture are reserved for Intel microprocessors. Please refer to the applicable product User and Reference Guides for more information regarding the specific instruction sets covered by this notice. 
.TP 18
Notice revision #20110804 
.TP 18
= = = = = = = = = = 
.NL
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-fp\-port
.TP
.B
\-no\-fp\-port
.RS
.TP
Rounds floating\-point results after floating\-point operations. 
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-no\-fp\-port 
.NL
The default rounding behavior depends on the compiler\[aq]s code generation decisions and the precision parameters of the operating system.
.TP
\fBDescription:\fR 
.PP
This option rounds floating\-point results after floating\-point operations. Rounding to user\-specified precision occurs at assignments and type conversions. This has some impact on speed.
.NL
.PP
The default is to keep results of floating\-point operations in higher precision. This provides better performance but less consistent floating\-point results. 
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-fp\-speculation=mode
.RS
.TP
Tells the compiler the mode in which to speculate on floating\-point operations.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.TP 18
\fImode\fR
.NL
Is the mode for floating\-point operations. Possible values are:
.RS
.TP 15
fast
Tells the compiler to speculate on floating\-point operations.
.TP 15
safe
Tells the compiler to disable speculation if there is a possibility that the speculation may cause a floating\-point exception.
.TP 15
strict
Tells the compiler to disable speculation on floating\-point operations.
.TP 15
off
This is the same as specifying strict.
.RE
.TP
\fBDefault:\fR 
.TP 18
\-fp\-speculation=fast 
.NL
The compiler speculates on floating\-point operations. This is also the behavior when optimizations are enabled. However, if you specify no optimizations (\-O0 on Linux* OS), the default is \-fp\-speculation=safe (Linux* OS).
.TP
\fBDescription:\fR 
.PP
This option tells the compiler the mode in which to speculate on floating\-point operations.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-fp\-stack\-check
.RS
.TP
Tells the compiler to generate extra code after every function call to ensure that the floating\-point stack is in the expected state.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
There is no checking to ensure that the floating\-point (FP) stack is in the expected state.
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to generate extra code after every function call to ensure that the floating\-point (FP) stack is in the expected state.
.NL
.PP
By default, there is no checking. So when the FP stack overflows, a NaN value is put into FP calculations and the program\[aq]s results differ. Unfortunately, the overflow point can be far away from the point of the actual bug. This option places code that causes an access violation exception immediately after an incorrect call occurs, thus making it easier to locate these issues. 
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-fp\-trap=mode[,mode,...]
.RS
.TP
Sets the floating\-point trapping mode for the main routine.
.NL
.TP
\fBArchitectures:\fR IA\-32, Intel(R) 64 architecture
.TP
\fBArguments:\fR 
.TP 18
\fImode\fR
.NL
Is the floating\-point trapping mode. If you specify more than one mode value, the list is processed 
sequentially from left to right. 
Possible values are:
.RS
.TP 15
[no]divzero
Enables or disables the IEEE trap for division by zero.
.TP 15
[no]inexact
Enables or disables the IEEE trap for inexact result.
.TP 15
[no]invalid
Enables or disables the IEEE trap for invalid operation.
.TP 15
[no]overflow
Enables or disables the IEEE trap for overflow.
.TP 15
[no]underflow
Enables or disables the IEEE trap for underflow.
.TP 15
[no]denormal
Enables or disables the trap for denormal.
.TP 15
all
Enables all of the above traps.
.TP 15
none
Disables all of the above traps.
.TP 15
common
Sets the most commonly used IEEE traps: division by zero, invalid operation, 
and overflow.
.RE
.TP
\fBDefault:\fR 
.TP 18
\-fp\-trap=none 
.NL
No traps are enabled when a program starts.
.TP
\fBDescription:\fR 
.PP
This option sets the floating\-point trapping mode for the main routine.   It does not set a handler for floating\-point exceptions.
.NL
.PP
The [no] form of a mode value is only used to modify the meaning of mode values all and common, and can only be used with one of those values. The [no]
form of the option by itself does not explicitly cause a particular trap to be disabled.
.NL
.PP
Use mode value inexact with caution. This results in the trap being enabled whenever a floating\-point value cannot be represented exactly, which can cause unexpected results.
.NL
.PP
If mode value underflow is specified, the compiler ignores the FTZ (flush\-to\-zero) bit state of Intel(R) Streaming SIMD Extensions (Intel(R) SSE) floating\-point units.
.NL
.PP
When a DAZ (denormals are zero) bit is set in an Intel(R) SSE floating\-point unit control word, a denormal operand exception is never generated.
.NL
.PP
To set the floating\-point trapping mode for all routines, specify option \-fp\-trap\-all (Linux and OS X) or /Qfp\-trap\-all (Windows).
.NL
.PP
.B NOTE:
Option \-[no\-]ftz (Linux and OS X) and /Qftz[\-] (Windows) can be used to set or reset the FTZ and the DAZ hardware flags.
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-fp\-trap\-all=mode[,mode,...]
.RS
.TP
Sets the floating\-point trapping mode for all routines.
.NL
.TP
\fBArchitectures:\fR IA\-32, Intel(R) 64 architecture
.TP
\fBArguments:\fR 
.TP 18
\fImode\fR
.NL
Is the floating\-point trapping mode. If you specify more than one mode value, the list is processed 
sequentially from left to right. 
Possible values are:
.RS
.TP 15
[no]divzero
Enables or disables the IEEE trap for division by zero.
.TP 15
[no]inexact
Enables or disables the IEEE trap for inexact result.
.TP 15
[no]invalid
Enables or disables the IEEE trap for invalid operation.
.TP 15
[no]overflow
Enables or disables the IEEE trap for overflow.
.TP 15
[no]underflow
Enables or disables the IEEE trap for underflow.
.TP 15
[no]denormal
Enables or disables the trap for denormal.
.TP 15
all
Enables all of the above traps.
.TP 15
none
Disables all of the above traps.
.TP 15
common
Sets the most commonly used IEEE traps: division by zero, invalid operation, 
and overflow.
.RE
.TP
\fBDefault:\fR 
.TP 18
\-fp\-trap\-all=none 
.NL
No traps are enabled for all routines.
.TP
\fBDescription:\fR 
.PP
This option sets the floating\-point trapping mode for the main routine.   It does not set a handler for floating\-point exceptions.
.NL
.PP
The [no] form of a mode value is only used to modify the meaning of mode values all and common, and can only be used with one of those values. The [no]
form of the option by itself does not explicitly cause a particular trap to be disabled.
.NL
.PP
Use mode value inexact with caution. This results in the trap being enabled whenever a floating\-point value cannot be represented exactly, which can cause unexpected results.
.NL
.PP
If mode value underflow is specified, the compiler ignores the FTZ (flush\-to\-zero) bit state of Intel(R) Streaming SIMD Extensions (Intel(R) SSE) floating\-point units.
.NL
.PP
When a DAZ (denormals are zero) bit is set in an Intel(R) SSE floating\-point unit control word, a denormal operand exception is never generated.
.NL
.PP
To set the floating\-point trapping mode for the main routine only, specify option \-fp\-trap (Linux and OS X) or /Qfp\-trap (Windows).
.NL
.PP
.B NOTE:
Option \-[no\-]ftz (Linux and OS X) and /Qftz[\-] (Windows) can be used to set or reset the FTZ and the DAZ hardware flags.
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-fpack\-struct
.RS
.TP
Specifies that structure members should be packed together.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
.TP
\fBDescription:\fR 
.PP
Specifies that structure members should be packed together. Note: Using this option may result in code that is not usable with standard (system) c and C++ libraries.
.NL
.TP
\fBAlternate Options:\fR 
.PP
Linux and OS X: \-Zp1
.NL
.RE
.TP
.B
\-fpermissive
.RS
.TP
Tells the compiler to allow for non\-conformant code.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
.TP
\fBDescription:\fR 
.PP
Tells the compiler to allow for non\-conformant code.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-fpic
.TP
.B
\-fno\-pic
.RS
.TP
Determines whether the compiler generates position\-independent code.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-fno\-pic
.NL
The compiler does not generate position\-independent code.
.TP
\fBDescription:\fR 
.PP
This option determines whether the compiler generates position\-independent code.
.NL
.PP
Option \-fpic specifies full symbol preemption. Global symbol definitions as well as global symbol references get default (that is, preemptable) visibility unless explicitly specified otherwise.
.NL
.PP
Option \-fpic must be used when building shared objects.
.NL
.PP
This option can also be specified as \-fPIC.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-fpie (L*X only)
.RS
.TP
Tells the compiler to generate position\-independent code. The generated code can only be linked into executables. 
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler does not generate position\-independent code for an executable\-only object.
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to generate position\-independent code. It is similar to \-fpic, but code generated by \-fpie can only be linked into an executable. 
.NL
.PP
Because the object is linked into an executable, this option causes better optimization of some symbol references.
.NL
.PP
To ensure that run\-time libraries are set up properly for the executable, you should also specify option \-pie to the compiler driver on the link command line. 
.NL
.PP
Option \-fpie can also be specified as \-fPIE.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-freg\-struct\-return
.RS
.TP
Tells the compiler to return struct and union values in registers when possible.
.NL
.TP
\fBArchitectures:\fR IA\-32 architecture
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to return struct and union values in registers when possible.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-fshort\-enums
.RS
.TP
Tells the compiler to allocate as many bytes as needed for enumerated types. 
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler allocates a default number of bytes for enumerated types.
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to allocate as many bytes as needed for enumerated types.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-fsource\-asm
.RS
.TP
Produces an assembly listing with source code annotations.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
No source code annotations appear in the assembly listing file, if one is produced.
.TP
\fBDescription:\fR 
.PP
This option produces an assembly listing file with source code annotations. The assembly listing file shows the source code as interspersed comments.
.NL
.PP
To use this option, you must also specify option \-S, which causes an assembly listing to be generated.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-fstack\-protector\-all
.TP
.B
\-fno\-stack\-protector\-all
.RS
.TP
Enables or disables stack overflow security checks including functions.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-fno\-stack\-protector\-all
.NL
Stack overflow security checks, including functions, are disabled.
.TP
\fBDescription:\fR 
.PP
Enables or disables stack overflow security checks including functions.  These checks are enabled when you specify \-fstack\-protector\-all.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-fstack\-security\-check
.TP
.B
\-fno\-stack\-security\-check
.RS
.TP
Determines whether the compiler generates code that detects some buffer overruns. 
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-fno\-stack\-security\-check 
.NL
The compiler does not detect buffer overruns.
.TP
\fBDescription:\fR 
.PP
This option determines whether the compiler generates code that detects some buffer overruns that overwrite the return address. This is a common technique for exploiting code that does not enforce buffer size restrictions. 
.NL
.TP
\fBAlternate Options:\fR 
.PP
Linux and OS X: \-f[no\-]stack\-protector
.NL
.RE
.TP
.B
\-fsyntax\-only
.RS
.TP
Tells the compiler to check only for correct syntax. 
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
Normal compilation is performed.
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to check only for correct syntax. No object file is produced.
.NL
.TP
\fBAlternate Options:\fR 
.PP
Linux and OS X: None
.NL
.RE
.TP
.B
\-ftemplate\-depth\-n
.RS
.TP
Control the depth in which recursive templates are expanded.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.TP 18
\fIn\fR
.NL
The number of recursive templates that are expanded.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
.TP
\fBDescription:\fR 
.PP
Control the depth in which recursive templates are expanded. On Linux*, this option is supported only by invoking the compiler with icpc.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-ftls\-model=model
.RS
.TP
Changes the thread local storage (TLS) model.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.TP 18
\fImodel\fR
.NL
Determines the TLS model used by the compiler. Possible values are:
.RS
.TP 15
global\-dynamic
Generates a generic TLS code. The code can be used everywhere and the code can access variables defined anywhere else. This setting causes the largest size code to be generated and uses the most run time to produce.
.TP 15
local\-dynamic
Generates an optimized TLS code. To use this setting, the thread\-local variables must be defined in the same object in which they are referenced.
.TP 15
initial\-exec
Generates a restrictive, optimized TLS code. To use this setting, the thread\-local variables accessed must be defined in one of the modules available to the program.
.TP 15
local\-exec
Generates the most restrictive TLS code. To use this setting, the thread\-local variables must be defined in the executable.
.RE
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler uses default heuristics when determining the thread\-local storage model.
.TP
\fBDescription:\fR 
.PP
This option changes the thread local storage (TLS) model.  Thread\-local storage is a mechanism by which
variables are allocated in a way that causes one instance of the
variable per extant thread.
.NL
.PP
For more information on the thread\-storage
localization models, see the appropriate gcc*
documentation.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-ftrapuv
.RS
.TP
Initializes stack local variables to an unusual value to aid error detection.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler does not initialize local variables.
.TP
\fBDescription:\fR 
.PP
This option initializes stack local variables to an unusual value to aid error detection. Normally, these local variables should be initialized in the application.
.NL
.PP
The option sets any uninitialized local variables that are allocated on the stack to a value that is typically interpreted as a very large integer or an invalid address. References to these variables are then likely to cause run\-time errors that can help you detect coding errors.
.NL
.PP
This option sets option \-g (Linux* OS and OS X*) and /Zi or /Z7 (Windows* OS), which  changes
the default optimization level from O2 to \-O0 (Linux OS and OS X)
or /Od (Windows OS). You can override this effect by explicitly
specifying an O option setting.
.NL
.PP
If option O2 and option \-ftrapuv (Linux OS and OS X) or /Qtrapuv (Windows OS) are used together, you should specify
option \-fp\-speculation safe (Linux OS and OS X) or
/Qfp\-speculation:safe (Windows OS) to prevent exceptions resulting
from speculated floating\-point operations from being
trapped.
.NL
.PP
For more details on using options \-ftrapuv and /Qtrapuv
with compiler option O, see the article on Intel(R) Software Network
titled Don\[aq]t optimize when using \-ftrapuv for uninitialized
variable detection.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-ftz
.TP
.B
\-no\-ftz
.RS
.TP
Flushes denormal results to zero.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-ftz or /Qftz
.NL
Denormal results are flushed to zero.
.IP
Every optimization option O level, except O0, sets \-ftz and /Qftz.
.TP
\fBDescription:\fR 
.PP
This option flushes denormal results to zero when the application is in the gradual underflow mode. It may improve performance if the denormal values are not critical to your application\[aq]s behavior.
.NL
.PP
This option sets or resets the FTZ and the DAZ hardware flags. If FTZ is ON, denormal results from floating\-point calculations will be set to the value zero. If FTZ is OFF, denormal results remain as is. If DAZ is ON, denormal values used as input to floating\-point instructions will be treated as zero. If DAZ is OFF, denormal instruction inputs remain as is.  Systems using Intel(R) 64 architecture have both FTZ and DAZ. FTZ and DAZ are not supported on all IA\-32 architectures. 
.NL
.PP
When \-ftz (Linux OS and OS X) or /Qftz (Windows OS) is used in combination with an SSE\-enabling option on systems using IA\-32 architecture (for example, xN or QxN), the compiler will insert code in the main routine to set FTZ and DAZ. When \-ftz or /Qftz is used without such an option, the compiler will insert code to conditionally set FTZ/DAZ based on a run\-time processor check. \-no\-ftz (Linux OS and OS X) or /Qftz\- (Windows OS) will prevent the compiler from inserting any code that might set FTZ or DAZ. 
.NL
.PP
This option only has an effect when the main program is being compiled. It sets the FTZ/DAZ mode for the process. The initial thread and any threads subsequently created by that process will operate in FTZ/DAZ mode.
.NL
.PP
If this option produces undesirable results of the numerical behavior of your program, you can turn the FTZ/DAZ mode off by using \-no\-ftz or /Qftz\- in the command line while still benefiting from the O3 optimizations.
.NL
.PP
.B NOTE:
Options \-ftz and /Qftz are performance options. Setting these options does not guarantee that all denormals in a program are flushed to zero. They only cause denormals generated at run time to be flushed to zero.
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-funroll\-all\-loops
.RS
.TP
Unroll all loops even if the number of iterations is uncertain when the loop is entered.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
Do not unroll all loops.
.TP
\fBDescription:\fR 
.PP
Unroll all loops, even if the number of iterations is uncertain when the loop is entered. There may a performance impact with this option.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-funsigned\-bitfields
.TP
.B
\-fno\-unsigned\-bitfields
.RS
.TP
Determines whether the default bitfield type is changed to unsigned.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-fno\-unsigned\-bitfields
.NL
The default bitfield type is signed.
.TP
\fBDescription:\fR 
.PP
This option determines whether the default bitfield type is changed to unsigned.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-funsigned\-char
.RS
.TP
Change default char type to unsigned.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
Do not change default char type to unsigned.
.TP
\fBDescription:\fR 
.PP
Change default char type to unsigned. 
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-fverbose\-asm
.TP
.B
\-fno\-verbose\-asm
.RS
.TP
Produces an assembly listing with compiler comments, including options and version information.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-fno\-verbose\-asm
.NL
No source code annotations appear in the assembly listing file, if one is produced.
.TP
\fBDescription:\fR 
.PP
This option produces an assembly listing file with compiler comments, including options and version information.
.NL
.PP
To use this option, you must also specify \-S, which sets \-fverbose\-asm.
.NL
.PP
If you do not want this default when you specify \-S, specify \-fno\-verbose\-asm.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-fvisibility=keyword
.TP
.B
\-fvisibility\-keyword=filename
.RS
.TP
Specifies the default visibility for global symbols or the visibility for symbols in a file. 
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.TP 18
\fIkeyword\fR
.NL
Specifies the visibility setting. Possible values are:
.RS
.TP 15
default
Sets visibility to default.
.TP 15
extern
Sets visibility to extern.
.TP 15
hidden
Sets visibility to hidden.
.TP 15
protected
Sets visibility to protected. This value is not available on OS X* systems.
.RE
.TP 18
\fIfilename\fR
.NL
Is the pathname of a file containing the list of symbols whose visibility you want to set. The symbols must be separated by whitespace (spaces, tabs, or newlines).
.TP
\fBDefault:\fR 
.TP 18
\-fvisibility=default
.NL
The compiler sets visibility of symbols to default.
.TP
\fBDescription:\fR 
.PP
This option specifies the default visibility for global symbols (syntax \-fvisibility=\fIkeyword\fR) or the visibility for symbols in a file (syntax \-fvisibility\-\fIkeyword=filename\fR). 
.NL
.PP
Visibility specified by \-fvisibility\-\fIkeyword=filename\fR overrides visibility specified by \-fvisibility=\fIkeyword\fR for symbols specified in a file.
.NL
.TP 18
\fBOption\fR
.NL
.NL
\fBDescription\fR
.NL
.NL
.TP 18
\-fvisibility=default \-fvisibility\-default\fI=filename\fR
.NL
Sets visibility of symbols to default. This means other components can reference the symbol, and the symbol definition can be overridden (preempted) by a definition of the same name in another component.
.NL
.TP 18
\-fvisibility=extern \-fvisibility\-extern\fI=filename\fR
.NL
Sets visibility of symbols to extern. This means the symbol is treated as though it is defined in another component. It also means that the symbol can be overridden by a definition of the same name in another component.
.NL
.TP 18
\-fvisibility=hidden \-fvisibility\-hidden\fI=filename\fR
.NL
Sets visibility of symbols to hidden. This means that other components cannot directly reference the symbol. However, its address may be passed to other components indirectly.
.NL
.TP 18
\-fvisibility=protected \-fvisibility\-protected\fI=filename\fR
.NL
Sets visibility of symbols to protected. This means other
components can reference the symbol, but it cannot be overridden by
a definition of the same name in another component.
This value is not available on OS X* systems.
.NL
.PP
If an \-fvisibility option is specified more than once on the command line, the last specification takes precedence over any others.
.NL
.PP
If a symbol appears in more than one visibility \fIfilename\fR, the setting with the least visibility takes precedence.
.NL
.PP
The following shows the precedence of the visibility settings (from greatest to least visibility):
.NL
.IP \(bu 2
extern
.IP \(bu 2
default
.IP \(bu 2
protected
.IP \(bu 2
hidden
.PP
Note that extern visibility only applies to functions. If a variable symbol is specified as extern, it is assumed to be default.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-fvisibility\-inlines\-hidden
.RS
.TP
Causes inline member functions (those defined in the class declaration) to be marked hidden.
.NL
.TP
\fBArchitectures:\fR IA\-32 architecture
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler does not cause inline member functions to be marked hidden.
.TP
\fBDescription:\fR 
.PP
Causes inline member functions (those defined in the class declaration) to be marked hidden. This option is particularly useful for templates.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-fzero\-initialized\-in\-bss
.TP
.B
\-fno\-zero\-initialized\-in\-bss
.RS
.TP
Determines whether the compiler places in the DATA section any variables explicitly initialized with zeros.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-fno\-zero\-initialized\-in\-bss 
.NL
Variables explicitly initialized with zeros are placed in the BSS section. This can save space in the resulting code.
.TP
\fBDescription:\fR 
.PP
This option determines whether the compiler
places in the DATA section any variables explicitly initialized
with zeros.
.NL
.PP
If option \-fno\-zero\-initialized\-in\-bss (Linux* OS and OS X*) or /Qzero\-initialized\-in\-bss\- (Windows* OS) is specified, the
compiler places in the DATA section any variables that are
initialized to zero.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-g
.RS
.TP
Tells the compiler to generate full debugging information in the object file or a project database (PDB) file. 
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
No debugging information is produced in the object file or in a PDB file.
.TP
\fBDescription:\fR 
.PP
Options \-g (Linux* OS and OS X*)
and /Z7 (Windows* OS) tell the compiler to generate symbolic debugging information in the object file, which increases the size of the object file. The /Zi option (Windows OS) tells the compiler to generate symbolic debugging information in a PDB file. 
.NL
.PP
If you want to name the file, use option /Fd; otherwise, the PDB file used by the compilation step will be named vc90.pdb in Microsoft Visual Studio* 2008, and vc100.pdb in Microsoft Visual Studio* 
2010.  Note that Microsoft Visual Studio users do not normally need to specify this option because the environment sets it correctly.
.NL
.PP
The compiler does not support the generation of debugging information in assemblable files. If you specify these options, the resulting object file will contain debugging information, but the assemblable file will not.
.NL
.PP
These options turn off O2 and make O0 (Linux OS and OS X) or Od (Windows OS) the default unless O2 (or higher) is explicitly specified in the same command line.
.NL
.PP
On Linux* OS and OS X*, specifying the \-g or \-O0 option sets the \-fno\-omit\-frame\-pointer option. On Linux* OS, the \-debug inline\-debug\-info option will be enabled by default if you compile with optimizations (option \-O2 or higher) and debugging is enabled (option \-g).
.NL
.TP
\fBAlternate Options:\fR 
.TP 18
/Zi
.NL
Linux and OS X: None
.RE
.TP
.B
\-g0
.RS
.TP
Disables generation of symbolic debug information. 
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler generates symbolic debug information.
.TP
\fBDescription:\fR 
.PP
This option disables generation of symbolic debug information. 
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-gcc
.TP
.B
\-no\-gcc
.TP
.B
\-gcc\-sys
.RS
.TP
Determines whether certain GNU macros are defined or undefined. 
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-gcc
.NL
The compiler defines the GNU macros __GNUC__, __GNUC_MINOR__, and __GNUC_PATCHLEVEL__
.TP
\fBDescription:\fR 
.PP
This option determines whether the GNU macros __GNUC__, __GNUC_MINOR__, and __GNUC_PATCHLEVEL__ are defined or undefined.
.NL
.TP 18
\fBOption\fR
.NL
.NL
\fBDescription\fR
.NL
.NL
.TP 18
\-gcc
.NL
Defines GNU macros.
.NL
.TP 18
\-no\-gcc
.NL
Undefines GNU macros.
.NL
.TP 18
\-gcc\-sys
.NL
Defines GNU macros only during compilation of system headers.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-gcc\-name=name
.RS
.TP
Specifies the name of the gcc compiler that should be used to set up the environment for C compilations.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.TP 18
\fIname\fR
.NL
Is the name of the gcc compiler to use.  It can include the path where the gcc compiler is located.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler uses the PATH setting to find the gcc compiler and resolve environment settings.
.TP
\fBDescription:\fR 
.PP
This option specifies the name of the gcc compiler that should be used to set up the environment for C compilations.  If you do not specify a path, the compiler will search the PATH settings for the compiler name you provide.
.NL
.PP
This option is helpful when you are referencing a non\-standard gcc installation.
.NL
.PP
The C++ equivalent to option \-gcc\-name is \-gxx\-name.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-gcc\-version=n
.RS
.TP
Provides compatible behavior with gcc.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.TP 18
\fIn\fR
.NL
Is the gcc compatibility. Possible values are:
.RS
.TP 15
320
Specifies gcc 3.2 compatibility.
.TP 15
330
Specifies gcc 3.3 compatibility.
.TP 15
340
Specifies gcc 3.4 compatibility.
.TP 15
400
Specifies gcc 4.0 compatibility.
.TP 15
410
Specifies gcc 4.1 compatibility.
.TP 15
411
Specifies gcc 4.11 compatibility.
.TP 15
420
Specifies gcc 4.2 compatibility.
.TP 15
430
Specifies gcc 4.3 compatibility.
.TP 15
440
Specifies gcc 4.4 compatibility.
.TP 15
450
Specifies gcc 4.5 compatibility.
.TP 15
460
Specifies gcc 4.6 compatibility.
.TP 15
470
Specifies gcc 4.7 compatibility.
.RE
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
This option defaults to the installed version of gcc.
.TP
\fBDescription:\fR 
.PP
This option provides compatible behavior with gcc. It selects the version of gcc with which you achieve ABI interoperability.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-gdwarf\-2
.RS
.TP
Enables generation of debugging information using the DWARF Version 2 format.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
No debug information is generated. However, if compiler option \-g is specified, debugging information is generated in the DWARF Version 2 format with some DWARF Version 3 extensions.
.TP
\fBDescription:\fR 
.PP
This option enables generation of debugging information using the DWARF Version 2 format. 
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-gdwarf\-3
.RS
.TP
Enables generation of debugging information using the DWARF Version 3 format.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
No debug information is generated. However, if compiler option \-g is specified, debugging information is generated in the DWARF Version 2 format with some DWARF Version 3 extensions.
.TP
\fBDescription:\fR 
.PP
This option enables generation of debugging information using the DWARF Version 3 format. 
.NL
.PP
When you specify this option, the compiler will emit DWARF version 3\-compatible debugging information, which can be used by debuggers such as gdb and idb. It also generates additional debugging information for optimized code, such as end of prologue markers.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-global\-hoist
.TP
.B
\-no\-global\-hoist
.RS
.TP
Enables certain optimizations that can move memory loads to a point earlier in the program execution than where they appear in the source.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-global\-hoist 
.NL
Certain optimizations are enabled that can move memory loads.
.TP
\fBDescription:\fR 
.PP
This option enables certain optimizations that can move memory loads to a point earlier in the program execution than where they appear in the source. In most cases, these optimizations are safe and can improve performance. 
.NL
.PP
The \-no\-global\-hoist (Linux* OS and OS X*) or /Qglobal\-hoist\- (Windows* OS) option is useful for some applications, such as those that use shared or dynamically mapped memory, which can fail if a load is moved too early in the execution stream (for example, before the memory is mapped).
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-grecord\-gcc\-switches (L*X only)
.RS
.TP
Causes the command line options that were used to invoke the compiler to be appended to the DW_AT_producer attribute in DWARF debugging information.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The command line options that were used to
invoke the compiler are not appended to the DW_AT_producer
attribute in DWARF debugging information.
.TP
\fBDescription:\fR 
.PP
This option causes the command line options
that were used to invoke the compiler to be appended to the DW_AT_producer attribute in DWARF
debugging information.
.NL
.PP
The options
are concatenated with whitespace separating them from each other and
from the compiler version.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-guide[=n]
.RS
.TP
Lets you set a level of guidance for auto\-vectorization, auto parallelism, and data transformation.  
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.TP 18
\fIn\fR
.NL
Is an optional value specifying the level of guidance to be provided.
.IP
The values available are 1 through 4. Value 1 indicates a standard level of guidance. Value 4
indicates the most advanced level of guidance. If \fIn\fR is omitted, the default is 4.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
You do not receive guidance about how to improve optimizations for parallelism, vectorization, and data transformation.
.TP
\fBDescription:\fR 
.PP
This option lets you set a level of guidance (advice) for auto\-vectorization, auto parallelism, and data transformation. It causes the compiler to generate messages suggesting ways to improve these optimizations. 
.NL
.PP
When this option is specified, the compiler does not produce any objects or executables. 
.NL
.PP
You must also specify option –parallel (Linux* OS and OS X*) or /Qparallel (Windows* OS) to receive auto parallelism guidance.
.NL
.PP
You can set levels of guidance for the individual guide optimizations by specifying one of the following options:
.NL
.PP
.TP 18
data transformation
.NL
\-guide\-data\-trans (Linux OS and OS X) or /Qguide\-data\-trans (Windows OS)
.TP 18
auto parallelism
.NL
\-guide\-par (Linux OS and OS X) or /Qguide\-par (Windows OS)
.TP 18
auto\-vectorization
.NL
\-guide\-vec (Linux OS and OS X) or /Qguide\-vec (Windows OS)
.PP
If you specify \-guide or /Qguide and also specify one of the options setting a level of guidance for an individual guide optimization, the value set for the individual guide optimization will override the setting specified in \-guide or /Qguide.
.NL
.PP
If you do not specify \-guide or /Qguide, but specify one of the options setting a level of guidance for an individual guide optimization, option \-guide or /Qguide
is enabled with the greatest value passed among any of the three individual guide optimizations specified.
.NL
.PP
In debug mode, this option has no effect unless option O2 (or higher) is explicitly specified in the same command line.
.NL
.PP
.B NOTE:
You can specify –diag\-disable (Linux OS and OS X) or /Qdiag\-disable (Windows OS) to prevent the compiler from issuing one or more diagnostic messages.
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-guide\-data\-trans[=n]
.RS
.TP
Lets you set a level of guidance for data transformation.  
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.TP 18
\fIn\fR
.NL
Is an optional value specifying the level of guidance to be provided.
.IP
The values available are 1 and 2. Value 1 indicates a standard level of guidance. Value 2 indicates a more advanced level of guidance. If \fIn\fR is omitted, the default is 2.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
You do not receive guidance about how to improve optimizations for data transformation.
.TP
\fBDescription:\fR 
.PP
This option lets you set a level of guidance for data transformation. It causes the compiler to generate messages suggesting ways to improve that optimization.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-guide\-file[=filename]
.RS
.TP
Causes the results of guided auto parallelism to be output to a file.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.TP 18
\fIfilename\fR
.NL
Is the name of the file for output. It can include a path.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
Messages that are generated by guided auto parallelism are
output to stderr.
.TP
\fBDescription:\fR 
.PP
This option causes the results of guided
auto parallelism to be output to a file.
.NL
.PP
This option is ignored unless you also specify
one or more of the following options: option \-guide, \-guide\-vec,
\-guide\-data\-trans, or \-guide\-par (Linux* OS and OS X*), or option /Qguide,
/Qguide\-vec, /Qguide\-data\-trans, or /Qguide\-par (Windows*
OS).
.NL
.PP
If you do not specify a path, the file is
placed in the current working directory.
.NL
.PP
If there is already a file named \fIfilename\fR, it
will be overwritten.
.NL
.PP
You can include a file extension in \fIfilename\fR.
For example, if \fIfile.txt\fR is specified, the name of the output file
is \fIfile.txt\fR. If you do not provide a file extension, the name of
the file is \fIfilename.guide\fR.
.NL
.PP
If you do not specify \fIfilename\fR, the name of the
file is \fIname\-of\-the\-first\-source\-file.guide\fR. This is also the name
of the file if the name specified for \fIfilename\fR conflicts with a
source file name provided in the command line.
.NL
.PP
.B NOTE:
If you specify \-guide\-file or /Qguide\-file and you also specify \-guide\-file\-append (Linux OS and OS X) or /Qguide\-file\-append (Windows OS), the last option specified on the command line takes precedence.
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-guide\-file\-append[=filename]
.RS
.TP
Causes the results of guided auto parallelism to be appended to a file.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.TP 18
\fIfilename\fR
.NL
Is the name of the file to be appended to. It can include a path.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
Messages that are generated by guided auto parallelism are
output to stderr.
.TP
\fBDescription:\fR 
.PP
This option causes the results of guided auto parallelism to be appended to a file.
.NL
.PP
This option is ignored unless you also specify
one or more of the following options: option \-guide, \-guide\-vec,
\-guide\-data\-trans, or \-guide\-par (Linux* OS and OS X*), or option /Qguide,
/Qguide\-vec, /Qguide\-data\-trans, or /Qguide\-par (Windows*
OS).
.NL
.PP
If you do not specify a path, the compiler
looks for \fIfilename\fR in the current working directory.
.NL
.PP
If \fIfilename\fR is not found, then a new file with
that name is created in the current working directory.
.NL
.PP
If you do not specify a file extension, the
name of the file is \fIfilename.guide\fR.
.NL
.PP
If the name specified for \fIfilename\fR conflicts
with a source file name provided in the command line, the name of
the file is \fIname\-of\-the\-first\-source\-file.guide\fR.
.NL
.PP
.B NOTE:
If you specify \-guide\-file\-append
or /Qguide\-file\-append
and you also specify  \-guide\-file
(Linux OS and OS X) or  /Qguide\-file
(Windows OS), the last option specified on the command line takes precedence.
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
guide\-opts=string
.RS
.TP
Tells the compiler to analyze certain code and generate recommendations that may improve optimizations.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.TP 18
\fIstring\fR
.NL
Is the text denoting the code to analyze. The string must appear
within quotes. It can take one or more of the following forms:
\fIfilename\fR\fIfilename\fR, \fIroutine\fR\fIfilename\fR, \fIrange\fR [, \fIrange\fR]...
\fIfilename\fR, \fIroutine\fR, \fIrange\fR
[, \fIrange\fR]...
.IP
If you specify more than one of the above forms in a string, a semicolon must appear between each form. If you specify more than one \fIrange\fR
in a string, a comma must appear between each \fIrange\fR. Optional blanks can follow each parameter in the forms above and they can also follow each form in a string.
.RS
.TP 15
\fIfilename\fR
Specifies the name of a file to be analyzed. It
can include a path.
.IP
If you do not specify a path, the compiler
looks for filename in the current working directory.
.TP 15
\fIroutine\fR
Specifies the name of a routine to be analyzed.
You can include an identifying parameter. 
.IP
The name, including any parameter, must be enclosed in single quotes.
.IP
The compiler tries to uniquely identify the routine that corresponds to the specified routine name. It may select multiple routines to analyze, especially if the following is true:
.RS
.IP \(bu 2
More than one routine has the specified routine name, so the routine cannot be uniquely identified.
.IP \(bu 2
No parameter
information has been specified to narrow the number of routines selected as matches.
.RE
.TP 15
\fIrange\fR
Specifies a range of line numbers to analyze in
the file or routine specified. The \fIrange\fR must be specified in
integers in the form:
.IP
\fIfirst_line_number\-last_line_number\fR
.IP
The hyphen between the line numbers is
required.
.RE
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
You do not receive guidance on how to improve optimizations.
However, if you specify option \-guide (Linux* OS and OS X*) or /Qguide (Windows* OS), the compiler
analyzes and generates recommendations for all the code in an
application
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to analyze
certain code and generate recommendations that may
improve optimizations.
.NL
.PP
This option is ignored unless you also specify
one or more of the following options: option \-guide, \-guide\-vec,
\-guide\-data\-trans, or \-guide\-par (Linux* OS and OS X*), or option /Qguide,
/Qguide\-vec, /Qguide\-data\-trans, or /Qguide\-par (Windows*
OS).
.NL
.PP
When option \-guide\-opt or /Qguide\-opt is
specified, a message is output that
includes which parts of the input files are being analyzed. If a routine is selected to be analyzed, the
complete routine name will appear in the generated
message.
.NL
.PP
When inlining is involved, you should specify
callee line numbers. Generated messages also use callee line
numbers.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-guide\-par[=n]
.RS
.TP
Lets you set a level of guidance for auto parallelism.  
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.TP 18
\fIn\fR
.NL
Is an optional value specifying the level of guidance to be provided.
.IP
The values available are 1 and 2. Value 1 indicates a standard level of guidance. Value 2 indicates a more advanced level of guidance. If \fIn\fR is omitted, the default is 2.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
You do not receive guidance about how to improve optimizations for parallelism.
.TP
\fBDescription:\fR 
.PP
This option lets you set a level of guidance
for auto parallelism. It causes the compiler to generate
messages suggesting ways to improve that optimization.
.NL
.PP
You must also specify option \-parallel (Linux* OS and OS X*) or
/Qparallel (Windows* OS) to receive auto parallelism
guidance.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-guide\-profile=filename|dir [, [filename|dir]...]
.RS
.TP
Specifies a loop profiler data file (or a set of files) when used with option \-guide or /Qguide.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.TP 18
\fIfilename\fR
.NL
Is an .xml file created from a loop profiler run.
.TP 18
\fIdir\fR
.NL
Is a directory that contains one or more .xml files from a loop profiler run.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
When option \-guide (Linux* OS and OS X*) or /Qguide (Windows* OS) is specified, the guide region is the whole file or the region specified by option \-guide\-opts (Linux OS and OS X) or /Qguide\-opts (Windows OS).
.TP
\fBDescription:\fR 
.PP
This option specifies a loop profiler data file
(or a set of files) when used with option \-guide (Linux* OS and
OS X*) or /Qguide (Windows* OS).
.NL
.PP
This option has no effect unless \-guide or
/Qguide has been specified. Options \-guide\-profile
(Linux OS and OS X) and /Qguide\-profile  (Windows OS) help you take advantage of the \-guide
and /Qguide options to more efficiently optimize
your applications for
auto parallelism and/or vectorization.
.NL
.PP
The loop profile data file can be collected by
using one of the following options:
.NL
.IP \(bu 2
\-profile\-loops (Linux OS and OS X) or /Qprofile\-loops (Windows OS)
.IP \(bu 2
\-profile\-functions (Linux OS and OS X) or /Qprofile\-functions (Windows OS)
.PP
When the data is from \-profile\-loops or
/Qprofile\-loops, the setting of the guide regions will be based
upon the hottest loops.
.NL
.PP
When the data is from \-profile\-functions or
/Qprofile\-functions, the guide region will be the entire function
containing the hottest functions.
.NL
.PP
If you specify options \-guide\-opts and
\-guide\-profile (Linux OS and OS X) or options /Qguide\-opts
and /Qguide\-profile (Windows OS), the compiler issues an error
message.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-guide\-vec[=n]
.RS
.TP
Lets you set a level of guidance for auto\-vectorization.  
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.TP 18
\fIn\fR
.NL
Is an optional value specifying the level of guidance to be provided.
.IP
The values available are 1 and 2. Value 1 indicates a standard level of guidance. Value 2 indicates a more advanced level of guidance. If \fIn\fR is omitted, the default is 2.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
You do not receive guidance about how to improve optimizations for vectorization.
.TP
\fBDescription:\fR 
.PP
This option lets you set a level of guidance
for auto\-vectorization. It causes the compiler to generate
messages suggesting ways to improve that optimization.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-gxx\-name=name
.RS
.TP
Specifies the name of the g++ compiler that should be used to set up the environment for C++ compilations.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.TP 18
\fIname\fR
.NL
Is the name of the g++ compiler to use.  It can include the path where the g++ compiler is located.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler uses the PATH setting to find the g++ compiler and resolve environment settings.
.TP
\fBDescription:\fR 
.PP
This option specifies the name of the g++ compiler that should be used to set up the environment for C++ compilations.  If you do not specify a path, the compiler will search the PATH settings for the compiler name you provide.
.NL
.PP
The C equivalent to option \-gxx\-name is \-gcc\-name.
.NL
.PP
.B NOTE:
When compiling a C++ file with icc, g++ is used to get the environment.
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-H
.RS
.TP
Tells the compiler to display the include file order and continue compilation. 
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
Compilation occurs as usual.
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to display the include file order and continue compilation. 
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-help[category]
.RS
.TP
Displays all available compiler options or a category of compiler options.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.TP 18
\fIcategory\fR
.NL
Is a category or class of options to display. Possible values are:
.RS
.TP 15
advanced
Displays advanced optimization options that allow fine tuning of compilation or allow control over advanced features of the compiler.
.TP 15
codegen
Displays Code Generation options.
.TP 15
compatibility
Displays options affecting language compatibility.
.TP 15
component
Displays options for component control.
.TP 15
data
Displays options related to interpretation of data in programs or the storage of data.
.TP 15
deprecated
Displays options that have been deprecated.
.TP 15
diagnostics
Displays options that affect diagnostic messages displayed by the compiler.
.TP 15
float
Displays options that affect floating\-point operations.
.TP 15
help
Displays all the available help categories.
.TP 15
inline
Displays options that affect inlining.
.TP 15
ipo
Displays Interprocedural Optimization (IPO) options
.TP 15
language
Displays options affecting the behavior of the compiler language features.
.TP 15
link
Displays linking or linker options.
.TP 15
misc
Displays miscellaneous options that do not fit within other categories.
.TP 15
openmp
Displays OpenMP and parallel processing options.
.TP 15
opt
Displays options that help you optimize code.
.TP 15
output
Displays options that provide control over compiler output.
.TP 15
pgo
Displays Profile Guided Optimization (PGO) options.
.TP 15
preproc
Displays options that affect preprocessing operations.
.TP 15
reports
Displays options for optimization reports.
.RE
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
No list is displayed unless this compiler option is specified.
.TP
\fBDescription:\fR 
.PP
This option displays all available compiler options or a category of compiler options. If category is not specified, all available compiler options are displayed. On Linux* systems, this option can also be specified as \-\-help.
.NL
.TP
\fBAlternate Options:\fR 
.PP
Linux and OS X: None
.NL
.RE
.TP
.B
\-help\-pragma
.RS
.TP
Displays all supported pragmas.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
No list is displayed unless this compiler option is specified.
.TP
\fBDescription:\fR 
.PP
This option displays all supported pragmas and shows their syntaxes.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-Idir
.RS
.TP
Specifies an additional directory to search for include files. 
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.TP 18
\fIdir\fR
.NL
Is the additional directory for the search.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The default directory is searched for include files.
.TP
\fBDescription:\fR 
.PP
This option specifies an additional directory to search for include files. To specify multiple directories on the command line, repeat the include option for each directory. 
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-icc
.TP
.B
\-no\-icc
.RS
.TP
Determines whether certain Intel compiler macros are defined or undefined.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-icc
.NL
The __INTEL_COMPILER macros are set to represent the current version of the compiler.
.TP
\fBDescription:\fR 
.PP
This option determines whether certain Intel compiler macros are defined or undefined.
.NL
.PP
If you specify option \-no\-icc, the compiler undefines the __INTEL_COMPILER macros. These macros are defined by default or by specifying \-icc.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-idirafterdir
.RS
.TP
Adds a directory to the second include file search path.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.TP 18
\fIdir\fR
.NL
Is the name of the directory to add.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
Include file search paths include certain default directories.
.TP
\fBDescription:\fR 
.PP
This option adds a directory to the second include file search path (after \-I).
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-imacros filename
.RS
.TP
Allows a header to be specified that is included in front of the other headers in the translation unit.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.TP 18
\fIfilename\fR
.NL
Name of header file.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
.TP
\fBDescription:\fR 
.PP
Allows a header to be specified that is included in front of the other headers in the translation unit.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-inline\-calloc
.TP
.B
\-no\-inline\-calloc
.RS
.TP
Tells the compiler to inline calls to calloc() as calls to malloc() and memset().
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-no\-inline\-calloc 
.NL
The compiler inlines calls to calloc() as calls to calloc().
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to inline calls to calloc() as calls to malloc() and memset(). This enables additional memset() optimizations. For example, it can enable inlining as a sequence of store operations when the size is a compile time constant.
.NL
.PP
.B NOTE:
Many routines in the supplied libraries are more highly optimized for Intel(R) microprocessors than for non\-Intel microprocessors
.PP
.TP 18
\fBOptimization Notice 
\fR
.NL
.NL
.TP 18
= = = = = = = = = = 
.TP 18
Intel\[aq]s compilers may or may not optimize to the same degree for non\-Intel microprocessors for optimizations that are not unique to Intel microprocessors. These optimizations include SSE2, SSE3, and SSSE3 instruction sets and other optimizations. Intel does not guarantee the availability, functionality, or effectiveness of any optimization on microprocessors not manufactured by Intel. Microprocessor\-dependent optimizations in this product are intended for use with Intel microprocessors. Certain optimizations not specific to Intel microarchitecture are reserved for Intel microprocessors. Please refer to the applicable product User and Reference Guides for more information regarding the specific instruction sets covered by this notice. 
.TP 18
Notice revision #20110804 
.TP 18
= = = = = = = = = = 
.NL
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-inline\-factor=n
.TP
.B
\-no\-inline\-factor
.RS
.TP
Specifies the percentage multiplier that should be applied to all inlining options that define upper limits.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.TP 18
\fIn\fR
.NL
Is a positive integer specifying the percentage value. The default value is 100 (a factor of 1).
.TP
\fBDefault:\fR 
.TP 18
\-no\-inline\-factor 
.NL
The compiler uses default heuristics for inline routine expansion.
.TP
\fBDescription:\fR 
.PP
This option specifies the percentage multiplier that should be applied to all inlining options that define upper limits:
.NL
.IP \(bu 2
\-inline\-max\-size and /Qinline\-max\-size
.IP \(bu 2
\-inline\-max\-total\-size and /Qinline\-max\-total\-size
.IP \(bu 2
\-inline\-max\-per\-routine and /Qinline\-max\-per\-routine
.IP \(bu 2
\-inline\-max\-per\-compile and /Qinline\-max\-per\-compile
.PP
This option takes the default value for each of the above options and multiplies it by \fIn\fR divided by 100. For example, if 200 is specified, all inlining options that define upper limits are multiplied by a factor of 2. This option is useful if you do not want to individually increase each option limit.
.NL
.PP
If you specify \-no\-inline\-factor (Linux* OS and OS X*) or /Qinline\-factor\- (Windows* OS), the following occurs:
.NL
.IP \(bu 2
Every function is considered to be a small or medium function; there are no large functions.
.IP \(bu 2
There is no limit to the size a routine may grow when inline expansion is performed.
.IP \(bu 2
There is no limit to the number of times some routine may be inlined into a particular routine.
.IP \(bu 2
There is no limit to the number of times inlining can be applied to a compilation unit.
.PP
To see compiler values for important inlining limits, specify compiler option \-opt\-report (Linux OS and OS X) or /Qopt\-report (Windows).
.NL
.PP
.B CAUTION:
When you use this option to increase default limits, the compiler may do so much additional inlining that it runs out of memory and terminates with an "out of memory" message.
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-inline\-forceinline
.RS
.TP
Specifies that an inline routine should be inlined whenever the compiler can do so.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler uses default heuristics for inline routine expansion.
.TP
\fBDescription:\fR 
.PP
This option specifies that a inline routine should be inlined whenever the compiler can do so. This causes the routines marked with an inline keyword or attribute to be treated as if they were "forceinline".
.NL
.PP
.B NOTE:
Because C++ member functions whose definitions are included in the class declaration are considered inline functions by default, using this option will also make these member functions "forceinline" functions.
.PP
The "forceinline" condition can also be specified by using the keyword __forceinline.
.NL
.PP
To see compiler values for important inlining limits, specify compiler option \-opt\-report (Linux* OS and OS X*) or /Qopt\-report (Windows* OS).
.NL
.PP
.B CAUTION:
When you use this option to change the meaning of inline to "forceinline", the compiler may do so much additional inlining that it runs out of memory and terminates with an "out of memory" message.
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-inline\-level=n
.RS
.TP
Specifies the level of inline function expansion.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.TP 18
\fIn\fR
.NL
Is the inline function expansion level. Possible values are 0, 1, and 2.
.TP
\fBDefault:\fR 
.TP 18
\-inline\-level=2
.NL
This is the default if option O2 is specified or is in effect by default. On Windows* systems, this is also the default if option O3 is specified.
.TP 18
\-inline\-level=0
.NL
This is the default if option \-O0 (Linux* OS and OS X*) is specified.
.TP
\fBDescription:\fR 
.PP
This option specifies the level of inline function expansion. Inlining procedures can greatly improve the run\-time performance of certain programs.
.NL
.TP 18
\fBOption\fR
.NL
.NL
\fBDescription\fR
.NL
.NL
.TP 18
\-inline\-level=0 or Ob0
.NL
Disables inlining of user\-defined functions. Note that statement functions are always inlined.
.NL
.TP 18
\-inline\-level=1 or Ob1 
.NL
Enables inlining when an inline keyword or an inline attribute is specified. Also enables inlining according to the C++ language.
.NL
.TP 18
\-inline\-level=2 or Ob2
.NL
Enables inlining of any function at the compiler\[aq]s discretion.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-inline\-max\-per\-compile=n
.TP
.B
\-no\-inline\-max\-per\-compile
.RS
.TP
Specifies the maximum number of times inlining may be applied to an entire compilation unit.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.TP 18
\fIn\fR
.NL
Is a positive integer that specifies the number of times inlining may be applied.
.TP
\fBDefault:\fR 
.TP 18
\-no\-inline\-max\-per\-compile 
.NL
The compiler uses default heuristics for inline routine expansion.
.TP
\fBDescription:\fR 
.PP
This option the maximum number of times inlining may be applied to an entire compilation unit. It limits the number of times that inlining can be applied.
.NL
.PP
For compilations using Interprocedural Optimizations (IPO), the entire compilation is a compilation unit. For other compilations, a compilation unit is a file.
.NL
.PP
If you specify \-no\-inline\-max\-per\-compile (Linux* OS and OS X*) or /Qinline\-max\-per\-compile\- (Windows* OS), there is no limit to the number of times inlining may be applied to a compilation unit.
.NL
.PP
To see compiler values for important inlining limits, specify compiler option \-opt\-report (Linux OS and OS X) or /Qopt\-report (Windows OS).
.NL
.PP
.B CAUTION:
When you use this option to increase the default limit, the compiler may do so much additional inlining that it runs out of memory and terminates with an "out of memory" message.
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-inline\-max\-per\-routine=n
.TP
.B
\-no\-inline\-max\-per\-routine
.RS
.TP
Specifies the maximum number of times the inliner may inline into a particular routine.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.TP 18
\fIn\fR
.NL
Is a positive integer that specifies the maximum number of times the inliner may inline into a particular routine.
.TP
\fBDefault:\fR 
.TP 18
\-no\-inline\-max\-per\-routine 
.NL
The compiler uses default heuristics for inline routine expansion.
.TP
\fBDescription:\fR 
.PP
This option specifies the maximum number of times the inliner may inline into a particular routine. It limits the number of times that inlining can be applied to any routine.
.NL
.PP
If you specify \-no\-inline\-max\-per\-routine (Linux* OS and OS X*) or /Qinline\-max\-per\-routine\- (Windows* OS), there is no limit to the number of times some routine may be inlined into a particular routine.
.NL
.PP
To see compiler values for important inlining limits, specify compiler option \-opt\-report (Linux OS and OS X) or /Qopt\-report (Windows OS).
.NL
.PP
To see compiler values for important inlining limits, specify compiler option \-opt\-report (Linux OS and OS X) or /Qopt\-report (Windows OS).
.NL
.PP
.B CAUTION:
When you use this option to increase the default limit, the compiler may do so much additional inlining that it runs out of memory and terminates with an "out of memory" message.
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-inline\-max\-size=n
.TP
.B
\-no\-inline\-max\-size
.RS
.TP
Specifies the lower limit for the size of what the inliner considers to be a large routine.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.TP 18
\fIn\fR
.NL
Is a positive integer that specifies the minimum size of what the inliner considers to be a large routine.
.TP
\fBDefault:\fR 
.TP 18
\-inline\-max\-size 
.NL
The compiler sets the maximum size (\fIn\fR) dynamically, based on the platform.
.TP
\fBDescription:\fR 
.PP
This option specifies the lower limit for the size of what the inliner considers to be a large routine (a function). The inliner classifies routines as small, medium, or large. This option specifies the boundary between what the inliner considers to be medium and large\-size routines.
.NL
.PP
The inliner prefers to inline small routines. It has a preference against inlining large routines. So, any large routine is highly unlikely to be inlined.
.NL
.PP
If you specify \-no\-inline\-max\-size (Linux* OS and OS X*) or /Qinline\-max\-size\- (Windows* OS), there are no large routines. Every routine is either a small or medium routine.
.NL
.PP
To see compiler values for important inlining limits, specify compiler option \-opt\-report (Linux OS and OS X) or /Qopt\-report (Windows OS).
.NL
.PP
.B CAUTION:
When you use this option to increase the default limit, the compiler may do so much additional inlining that it runs out of memory and terminates with an "out of memory" message.
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-inline\-max\-total\-size=n
.TP
.B
\-no\-inline\-max\-total\-size
.RS
.TP
Specifies how much larger a routine can normally grow when inline expansion is performed.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.TP 18
\fIn\fR
.NL
Is a positive integer that specifies the permitted increase in the routine\[aq]s size when inline expansion is performed.
.TP
\fBDefault:\fR 
.TP 18
\-no\-inline\-max\-total\-size 
.NL
The compiler uses default heuristics for inline routine expansion.
.TP
\fBDescription:\fR 
.PP
This option specifies how much larger a routine can normally grow when inline expansion is performed. It limits the potential size of the routine. For example, if 2000 is specified for \fIn\fR, the size of any routine will normally not increase by more than 2000.
.NL
.PP
If you specify \-no\-inline\-max\-total\-size (Linux* OS and OS X*) or /Qinline\-max\-total\-size\- (Windows* OS), there is no limit to the size a routine may grow when inline expansion is performed.
.NL
.PP
To see compiler values for important inlining limits, specify compiler option \-opt\-report (Linux OS and OS X) or /Qopt\-report (Windows OS).
.NL
.PP
To see compiler values for important inlining limits, specify compiler option \-opt\-report (Linux OS and OS X) or /Qopt\-report (Windows OS).
.NL
.PP
.B CAUTION:
When you use this option to increase the default limit, the compiler may do so much additional inlining that it runs out of memory and terminates with an "out of memory" message.
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-inline\-min\-size=n
.TP
.B
\-no\-inline\-min\-size
.RS
.TP
Specifies the upper limit for the size of what the inliner considers to be a small routine.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.TP 18
\fIn\fR
.NL
Is a positive integer that specifies the maximum size of what the inliner considers to be a small routine.
.TP
\fBDefault:\fR 
.TP 18
\-no\-inline\-min\-size 
.NL
The compiler uses default heuristics for inline routine expansion.
.TP
\fBDescription:\fR 
.PP
This option specifies the upper limit for the size of what the inliner considers to be a small routine (a function). The inliner classifies routines as small, medium, or large. This option specifies the boundary between what the inliner considers to be small and medium\-size routines.
.NL
.PP
The inliner has a preference to inline small routines. So, when a routine is smaller than or equal to the specified size, it is very likely to be inlined.
.NL
.PP
If you specify \-no\-inline\-min\-size (Linux* OS and OS X*) or /Qinline\-min\-size\- (Windows* OS), there is no limit to the size of small routines. Every routine is a small routine; there are no medium or large routines.
.NL
.PP
To see compiler values for important inlining limits, specify compiler option \-opt\-report (Linux OS and OS X) or /Qopt\-report (Windows OS).
.NL
.PP
To see compiler values for important inlining limits, specify compiler option \-opt\-report (Linux OS and OS X) or /Qopt\-report (Windows OS).
.NL
.PP
.B CAUTION:
When you use this option to increase the default limit, the compiler may do so much additional inlining that it runs out of memory and terminates with an "out of memory" message.
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-intel\-extensions
.TP
.B
\-no\-intel\-extensions
.RS
.TP
Enables or disables all Intel(R) C and Intel(R) C++ language extensions.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The Intel(R) C and Intel(R) C++ language extensions are enabled.
.TP
\fBDescription:\fR 
.PP
This option enables or disables all Intel(R) C and Intel(R) C++ language extensions. 
.NL
.PP
Option –no\-intel\-extensions (Linux* OS) or /Qintel\-extensions\- (Windows* OS) disables all Intel(R) C and Intel(R) C++ language extensions. For example, it disables  the Intel(R)  Cilk(TM) Plus language extensions, which include array notation, and it disables support for the decimal floating\-point types.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-ip
.TP
.B
\-no\-ip
.RS
.TP
Determines whether additional interprocedural optimizations for single\-file compilation are enabled.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
Some limited interprocedural optimizations occur, including inline function expansion for calls to functions defined within the current source file. These optimizations are a subset of full intra\-file interprocedural optimizations. Note that this setting is not the same as \-no\-ip (Linux* OS and OS X*).
.TP
\fBDescription:\fR 
.PP
This option determines whether additional interprocedural optimizations for single\-file compilation are enabled. 
.NL
.PP
Options \-ip (Linux OS and OS X) and /Qip (Windows OS) enable additional interprocedural optimizations for single\-file compilation. 
.NL
.PP
Options \-no\-ip (Linux OS and OS X) and /Qip\- (Windows OS) may not disable inlining. To ensure that inlining of user\-defined functions is disabled, specify \-inline\-level=0or \-fno\-inline (Linux OS and OS X), or specify /Ob0 (Windows OS). To ensure that inliningof compiler intrinsic functions is disabled, specify \-fno\-builtin (Linux OS and OS X) or /Oi\- (Windows OS). 
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-ip\-no\-inlining
.RS
.TP
Disables full and partial inlining enabled by interprocedural optimization options.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
Inlining enabled by interprocedural optimization options is performed.
.TP
\fBDescription:\fR 
.PP
This option disables full and partial inlining enabled by the following interprocedural optimization options:
.NL
.IP \(bu 2
On Linux* and OS X* systems: \-ip or \-ipo
.IP \(bu 2
On Windows* systems: /Qip, /Qipo, or /Ob2
.PP
It has no effect on other interprocedural optimizations.
.NL
.PP
On Windows systems, this option also has no effect on user\-directed inlining specified by option /Ob1.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-ip\-no\-pinlining
.RS
.TP
Disables partial inlining enabled by interprocedural optimization options.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
Inlining enabled by interprocedural optimization options is performed.
.TP
\fBDescription:\fR 
.PP
This option disables partial inlining enabled by the following interprocedural optimization options:
.NL
.IP \(bu 2
On Linux* and OS X* systems: \-ip or \-ipo
.IP \(bu 2
On Windows* systems: /Qip or /Qipo
.PP
It has no effect on other interprocedural optimizations.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-ipo[n]
.TP
.B
\-no\-ipo
.RS
.TP
Enables interprocedural optimization between files.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.TP 18
\fIn\fR
.NL
Is an optional integer that specifies the number of object files the compiler should create. The integer must be greater than or equal to 0.
.TP
\fBDefault:\fR 
.TP 18
\-no\-ipo or /Qipo\-
.NL
Multifile interprocedural optimization is not enabled.
.TP
\fBDescription:\fR 
.PP
This option enables interprocedural optimization between files. This is also called multifile interprocedural optimization (multifile IPO) or Whole Program Optimization (WPO).
.NL
.PP
When you specify this option, the compiler performs inline function expansion for calls to functions defined in separate files.
.NL
.PP
You cannot specify the names for the files that are created.
.NL
.PP
If \fIn\fR is 0, the compiler decides whether to create one or more object files based on an estimate of the size of the application. It generates one object file for small applications, and two or more object files for large applications.
.NL
.PP
If \fIn\fR is greater than 0, the compiler generates \fIn\fR object files, unless \fIn\fR exceeds the number of source files (\fIm\fR), in which case the compiler generates only \fIm\fR object files.
.NL
.PP
If you do not specify \fIn\fR, the default is 0.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-ipo\-c
.RS
.TP
Tells the compiler to optimize across multiple files and generate a single object file.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler does not generate a multifile object file.
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to optimize across multiple files and generate a single object file (named ipo_out.o
on Linux and OS X systems; ipo_out.obj
on Windows systems).
.NL
.PP
It performs the same optimizations as \-ipo (Linux* OS and OS X*) or /Qipo (Windows* OS), but compilation stops before the final link stage, leaving an optimized object file that can be used in further link steps.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-ipo\-jobsn
.RS
.TP
Specifies the number of commands (jobs) to be executed simultaneously during the link phase of Interprocedural Optimization (IPO).
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.TP 18
\fIn\fR
.NL
Is the number of commands (jobs) to run simultaneously. The number must be greater than or equal to 1.
.TP
\fBDefault:\fR 
.TP 18
\-ipo\-jobs1 
.NL
One command (job) is executed in an interprocedural optimization parallel build.
.TP
\fBDescription:\fR 
.PP
This option specifies the number of commands (jobs) to be executed simultaneously during the link phase of Interprocedural Optimization (IPO). It should only be used if the link\-time compilation is generating more than one object. In this case, each object is generated by a separate compilation, which can be done in parallel.
.NL
.PP
This option can be affected by the following compiler options:
.NL
.IP \(bu 2
\-ipo (Linux* OS and OS X*) or /Qipo (Windows* OS) when applications are large enough that the compiler decides to generate multiple object files.
.IP \(bu 2
\-ipo\fIn\fR (Linux OS and OS X) or /Qipo\fIn\fR (Windows OS) when \fIn\fR is greater than 1.
.IP \(bu 2
\-ipo\-separate (Linux OS) or /Qipo\-separate (Windows OS)
.PP
.B CAUTION:
Be careful when using this option. On a multi\-processor system with lots of memory, it can speed application build time. However, if \fIn\fR is greater than the number of processors, or if there is not enough memory to avoid thrashing, this option can increase application build time.
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-ipo\-S
.RS
.TP
Tells the compiler to optimize across multiple files and generate a single assembly file.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler does not generate a multifile assembly file.
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to optimize across multiple files and generate a single assembly file (named ipo_out.s on Linux* and OS X* systems; ipo_out.asm
on Windows* systems). 
.NL
.PP
It performs the same optimizations as \-ipo (Linux* OS and OS X*) or /Qipo (Windows* OS), but compilation stops before the final link stage, leaving an optimized assembly file that can be used in further link steps.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-ipo\-separate (L*X only)
.RS
.TP
Tells the compiler to generate one object file for every source file.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler decides whether to create one or more object files.
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to generate one object file for every source file. It overrides any \-ipo (Linux* OS) or /Qipo (Windows* OS) specification.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-ipp[=lib]
.RS
.TP
Tells the compiler to link to the some or all of the Intel(R) Integrated Performance Primitives (Intel(R) IPP) libraries. 
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.TP 18
\fIlib\fR
.NL
Indicates the Intel(R) IPP libraries that the compiler should link to. Possible values are:
.RS
.TP 15
common
Tells the compiler to link using the main libraries set. This is the default if the option is specified with no \fIlib\fR. 
.TP 15
crypto
Tells the compiler to link using the main libraries set and the crypto library.
.TP 15
nonpic (Linux only)
Tells the compiler to link using the version of the libraries that do not have position\-independent code. This value is not available on Intel(R) MIC Architecture.
.TP 15
nonpic_crypto (Linux only)
Tells the compiler to link using the crypto library and the version of the libraries that do not have position\-independent code.  This value is not available on Intel(R) MIC Architecture.
.RE
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler does not link to the Intel(R) IPP libraries.
.TP
\fBDescription:\fR 
.PP
The option tells the compiler to link to the some or all of the Intel(R) Integrated Performance Primitives (Intel(R) IPP) libraries and include the Intel(R) IPP headers.
.NL
.PP
.TP 18
\fBOptimization Notice 
\fR
.NL
.NL
.TP 18
= = = = = = = = = = 
.TP 18
Intel\[aq]s compilers may or may not optimize to the same degree for non\-Intel microprocessors for optimizations that are not unique to Intel microprocessors. These optimizations include SSE2, SSE3, and SSSE3 instruction sets and other optimizations. Intel does not guarantee the availability, functionality, or effectiveness of any optimization on microprocessors not manufactured by Intel. Microprocessor\-dependent optimizations in this product are intended for use with Intel microprocessors. Certain optimizations not specific to Intel microarchitecture are reserved for Intel microprocessors. Please refer to the applicable product User and Reference Guides for more information regarding the specific instruction sets covered by this notice. 
.TP 18
Notice revision #20110804 
.TP 18
= = = = = = = = = = 
.NL
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-iprefix prefix
.RS
.TP
Option for indicating the prefix for referencing directories containing header files.
.NL
.TP
\fBArchitectures:\fR IA\-32, Intel(R) 64 architecture
.TP
\fBArguments:\fR 
.TP 18
\fIprefix\fR
.NL
Is the prefix to use.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
.TP
\fBDescription:\fR 
.PP
Options for indicating the prefix for referencing directories containing header files. Use \fIprefix\fR with option \-iwithprefix as a prefix.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-iquote dir
.RS
.TP
Add directory to the front of the include file search path for files included with quotes but not brackets.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.TP 18
\fIdir\fR
.NL
Is the name of the directory to add.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler does not add a directory to the front of the include file search path.
.TP
\fBDescription:\fR 
.PP
Add directory to the front of the include file search path for files included with quotes but not brackets.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-isystemdir
.RS
.TP
Specifies a directory to add to the start of the system include path.
.NL
.TP
\fBArchitectures:\fR IA\-32, Intel(R) 64 architecture
.TP
\fBArguments:\fR 
.TP 18
\fIdir\fR
.NL
Is the directory to add to the system include path.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The default system include path is used.
.TP
\fBDescription:\fR 
.PP
This option specifies a directory to add to the system include path. The compiler searches the specified directory for include files after it searches all directories specified by the \-I compiler option but before it searches the standard system directories. This option is provided for compatibility with gcc.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-iwithprefixdir
.RS
.TP
Appends a directory to the prefix passed in by \-iprefix and puts it on the include search path at the end of the include directories.
.NL
.TP
\fBArchitectures:\fR IA\-32, Intel(R) 64 architecture
.TP
\fBArguments:\fR 
.TP 18
\fIdir\fR
.NL
Is the include directory.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
.TP
\fBDescription:\fR 
.PP
This option appends a directory to the prefix passed in by \-iprefix and puts it on the include search path at the end of the include directories.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-iwithprefixbeforedir
.RS
.TP
Similar to \-iwithprefix except the include directory is placed in the same place as \-I command line include directories.
.NL
.TP
\fBArchitectures:\fR IA\-32, Intel(R) 64 architecture
.TP
\fBArguments:\fR 
.TP 18
\fIdir\fR
.NL
Is the include directory.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
.TP
\fBDescription:\fR 
.PP
Similar to \-iwithprefix except the include directory is placed in the same place as \-I command line include directories.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-lstring
.RS
.TP
Tells the linker to search for a specified library when linking.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.TP 18
\fIstring\fR
.NL
Specifies the library (lib\fIstring\fR) that the linker should search.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The linker searches for standard libraries in standard directories.
.TP
\fBDescription:\fR 
.PP
This option tells the linker to search for a specified library when linking.
.NL
.PP
When resolving references, the linker normally searches for libraries in several standard directories, in directories specified by the L option, then in the library specified by the l option.
.NL
.PP
The linker searches and processes libraries and object files in the order they are specified. So, you should specify this option following the last object file it applies to.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-Ldir
.RS
.TP
Tells the linker to search for libraries in a specified directory before searching the standard directories.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.TP 18
\fIdir\fR
.NL
Is the name of the directory to search for libraries.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The linker searches the standard directories for libraries.
.TP
\fBDescription:\fR 
.PP
This option tells the linker to search for libraries in a specified directory before searching for them in the standard directories.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-mcode
.RS
.TP
Tells the compiler which features it may target, including which instruction sets it may generate.
.NL
.TP
\fBArchitectures:\fR IA\-32, Intel(R) 64 architecture
.TP
\fBArguments:\fR 
.TP 18
\fIcode\fR
.NL
Indicates to the compiler a feature set that it may target, including which instruction sets it may generate. Many of the following descriptions refer to
Intel(R) Streaming SIMD Extensions (Intel(R) SSE) and Supplemental
Streaming SIMD Extensions (SSSE). Possible values are:
.RS
.TP 15
avx
May generate Intel(R) Advanced Vector Extensions (Intel(R) AVX), SSE4.2, SSE4.1, SSE3, SSE2, SSE, and SSSE3 instructions. 
.TP 15
sse4.2
May generate Intel(R) SSE4.2, SSE4.1, SSE3, SSE2, SSE, and SSSE3 instructions.
.TP 15
sse4.1
May generate Intel(R) SSE4.1, SSE3, SSE2, SSE, and SSSE3 instructions.
.TP 15
ssse3
May generate SSSE3 instructions and Intel(R) SSE3, SSE2, and SSE instructions.
.TP 15
sse3
May generate Intel(R) SSE3, SSE2, and SSE instructions.
.TP 15
sse2
May generate Intel(R) SSE2 and SSE instructions.  This value is only available on Linux systems.
.TP 15
sse
This option has been deprecated; it is now the same as specifying ia32.
.TP 15
ia32
Generates x86/x87 generic code that is compatible with IA\-32 architecture. Disables any default extended instruction settings, and any previously set extended instruction settings.  It also disables all feature\-specific optimizations and instructions. This value is only available on Linux* systems using IA\-32 architecture.
.RE
.TP
\fBDefault:\fR 
.TP 18
Linux* systems: \-msse2 OS X* systems using IA\-32 architecture: \-msse3 OS X* systems using Intel(R) 64 architecture: \-mssse3
.NL
For more information on the default values, see Arguments above.
.TP
\fBDescription:\fR 
.PP
This option tells the compiler which features it may target, including which instruction sets it may generate. 
.NL
.PP
Code generated with these options should execute on any compatible, non\-Intel processor with support for the corresponding instruction set.
.NL
.PP
Options \-x and \-m are mutually exclusive. If both are specified, the compiler uses the last one specified and generates a warning.
.NL
.PP
For compatibility with gcc, the compiler allows the following options but they have no effect. You will get a warning error, but the instructions associated with the name will not be generated. You should use the suggested replacement options.
.NL
.TP 18
gcc Compatibility Option
.NL
Suggested Replacement Option
.NL
.TP 18
\-mfma
.NL
\-march=core\-avx2
.NL
.TP 18
\-mbmi, \-mavx2, \-mlzcnt
.NL
\-march=core\-avx2
.NL
.TP 18
\-mmovbe
.NL
\-march=atom \-minstruction=movbe
.NL
.TP 18
\-mcrc32, \-maes, \-mpclmul, \-mpopcnt
.NL
\-march=corei7
.NL
.TP 18
\-mvzeroupper
.NL
\-march=corei7\-avx
.NL
.TP 18
\-mfsgsbase, \-mrdrnd, \-mf16c
.NL
\-march=core\-avx\-i
.NL
.PP
Many of the above gcc options are not available on Intel(R) MIC Architecture.
.NL
.TP
\fBAlternate Options:\fR 
.PP
Linux and OS X: None
.NL
.RE
.TP
.B
\-M
.RS
.TP
Tells the compiler to generate makefile dependency lines for each source file.
.NL
.TP
\fBArchitectures:\fR IA\-32, Intel(R) 64 architecture
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler does not generate makefile dependency lines for each source file.
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to generate makefile dependency lines for each source file, based on the #include lines found in the source file. 
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-m32
.TP
.B
\-m64
.RS
.TP
Tells the compiler to generate code for a specific architecture.
.NL
.TP
\fBArchitectures:\fR IA\-32, Intel(R) 64 architecture
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler\[aq]s behavior depends on the host system.
.TP
\fBDescription:\fR 
.PP
These options tell the compiler to generate code for a specific architecture.
.NL
.TP 18
\fBOption\fR
.NL
.NL
\fBDescription\fR
.NL
.NL
.TP 18
\-m32
.NL
Tells the compiler to generate code for IA\-32 architecture.
.NL
.TP 18
\-m64
.NL
Tells the compiler to generate code for Intel(R) 64 architecture.
.NL
.PP
The \-m32 and \-m64 options are the same as OS X* options \-arch i386 and \-arch x86_64, respectively. Note that these options are provided for compatibility with gcc. They are not related to the Intel(R) C++  Compiler option arch.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-malign\-double
.RS
.TP
Aligns double, long double, and long long types for better performance for systems based on IA\-32 architecture.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
.TP
\fBDescription:\fR 
.PP
Aligns double, long double, and long long types for better performance for systems based on IA\-32 architecture.
.NL
.TP
\fBAlternate Options:\fR 
.PP
\-align
.NL
.RE
.TP
.B
\-map\-opts (L*X only)
.RS
.TP
Maps one or more compiler options to their equivalent on a different operating system.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
No platform mappings are performed.
.TP
\fBDescription:\fR 
.PP
This option maps one or more compiler options to their equivalent on a different operating system. The result is output to stdout. 
.NL
.PP
On Windows systems, the options you provide are presumed to be Windows options, so the options that are output to stdout will be Linux equivalents.
.NL
.PP
On Linux systems, the options you provide are presumed to be Linux options, so the options that are output to stdout will be Windows equivalents.
.NL
.PP
The tool can be invoked from the compiler command line or it can be used directly. 
.NL
.PP
No compilation is performed when the option mapping tool is used.
.NL
.PP
This option is useful if you have both compilers and want to convert scripts or makefiles.
.NL
.PP
.B NOTE:
Compiler options are mapped to their equivalent on the architecture you are using. For example, if you are using a processor with IA\-32 architecture, you will only see equivalent options that are available on processors with IA\-32 architecture.
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-march=processor
.RS
.TP
Tells the compiler to generate code for processors that support certain features. 
.NL
.TP
\fBArchitectures:\fR IA\-32, Intel(R) 64 architecture
.TP
\fBArguments:\fR 
.TP 18
\fIprocessor\fR
.NL
Indicates to the compiler the code it may generate. Possible values are:
.RS
.TP 15
core\-avx2
Generates code for processors that support Intel(R) Advanced Vector Extensions 2 (Intel(R) AVX2), Intel(R) AVX, SSE4.2, SSE4.1, SSE3, SSE2, SSE, and SSSE3 instructions.
.TP 15
core\-avx\-i
Generates code for processors that support Float\-16 conversion instructions and the RDRND instruction, Intel(R) Advanced Vector Extensions (Intel(R) AVX), Intel(R) SSE4.2, SSE4.1, SSE3, SSE2, SSE, and SSSE3 instructions.
.TP 15
corei7\-avx
Generates code for processors that support Intel(R) Advanced Vector Extensions (Intel(R) AVX), Intel(R) SSE4.2, SSE4.1, SSE3, SSE2, SSE, and SSSE3 instructions.
.TP 15
corei7
Generates code for processors that support Intel(R) SSE4 Efficient Accelerated String and Text Processing instructions. May also generate code for Intel(R) SSE4 Vectorizing Compiler and Media Accelerator, Intel(R) SSE3, SSE2, SSE, and SSSE3 instructions.
.TP 15
atom
Generates code for processors that support MOVBE instructions, depending on the setting of option \-minstruction (Linux* OS and OS X*) or /Qinstruction (Windows* OS). May also generate code for SSSE3 instructions and  Intel(R) SSE3, SSE2, and SSE instructions.
.TP 15
core2
Generates code for the Intel(R) Core(TM) 2 processor family.
.TP 15
pentium\-m pentium4 pentium3
Generates code for Intel(R) Pentium(R) processors. Value pentium3 is only available on Linux* OS.
.RE
.TP
\fBDefault:\fR 
.TP 18
pentium4
.NL
If no architecture option is specified, value pentium4 is used by the compiler to generate code.
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to generate code for processors that support certain features.
.NL
.PP
Specifying \-march=pentium4 sets \-mtune=pentium4.
.NL
.PP
For compatibility, a number of historical \fIprocessor\fR values are also supported, but the generated code will not differ from the default.
.NL
.PP
.TP 18
\fBOptimization Notice 
\fR
.NL
.NL
.TP 18
= = = = = = = = = = 
.TP 18
Intel\[aq]s compilers may or may not optimize to the same degree for non\-Intel microprocessors for optimizations that are not unique to Intel microprocessors. These optimizations include SSE2, SSE3, and SSSE3 instruction sets and other optimizations. Intel does not guarantee the availability, functionality, or effectiveness of any optimization on microprocessors not manufactured by Intel. Microprocessor\-dependent optimizations in this product are intended for use with Intel microprocessors. Certain optimizations not specific to Intel microarchitecture are reserved for Intel microprocessors. Please refer to the applicable product User and Reference Guides for more information regarding the specific instruction sets covered by this notice. 
.TP 18
Notice revision #20110804 
.TP 18
= = = = = = = = = = 
.NL
.NL
.TP
\fBAlternate Options:\fR 
.TP 18
\-march=pentium3
.NL
Linux: \-xSSE
.IP
OS X: None
.TP 18
\-march=pentium4 \-march=pentium\-m
.NL
Linux: \-xSSE2
.IP
OS X: None
.TP 18
\-march=core2
.NL
Linux: \-xSSSE3
.IP
OS X: None
.RE
.TP
.B
\-masm=dialect (L*X only)
.RS
.TP
Tells the compiler to generate the assembler output file using a selected dialect. 
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.TP 18
\fIdialect\fR
.NL
Is the dialect to use for the assembler output file.  Possible values are:
.RS
.TP 15
att
Tells the compiler to generate the assembler output file using AT&T* syntax.
.TP 15
intel
Tells the compiler to generate the assembler output file using Intel syntax.
.RE
.TP
\fBDefault:\fR 
.TP 18
\-masm=att
.NL
The compiler generates the assembler output file using AT&T* syntax.
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to generate the assembler output file using a selected dialect.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-mcmodel=mem_model (L*X only)
.RS
.TP
Tells the compiler to use a specific memory model to generate code and store data.
.NL
.TP
\fBArchitectures:\fR Intel(R) 64 architecture
.TP
\fBArguments:\fR 
.TP 18
\fImem_model\fR
.NL
Is the memory model to use. Possible values are:
.RS
.TP 15
small
Tells the compiler to restrict code and data to the first 2GB of address space. All accesses of code and data can be done with Instruction Pointer (IP)\-relative addressing.
.TP 15
medium
Tells the compiler to restrict code to the first 2GB; it places no memory restriction on data. Accesses of code can be done with IP\-relative addressing, but accesses of data must be done with absolute addressing.
.TP 15
large
Places no memory restriction on code or data. All accesses of code and data must be done with absolute addressing.
.RE
.TP
\fBDefault:\fR 
.TP 18
\-mcmodel=small
.NL
On systems using Intel(R) 64 architecture, the compiler restricts code and data to the first 2GB of address space. Instruction Pointer (IP)\-relative addressing can be used to access code and data.
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to use a specific memory model to generate code and store data. It can affect code size and performance. If your program has global and static data with a total size smaller than 2GB, \-mcmodel=small is sufficient. Global and static data larger than 2GB requires\-mcmodel=medium or \-mcmodel=large. Allocation of memory larger than 2GB can be done with any setting of \-mcmodel.
.NL
.PP
IP\-relative addressing requires only 32 bits, whereas absolute addressing requires 64\-bits. IP\-relative addressing is somewhat faster. So, the small memory model has the least impact on performance.
.NL
.PP
.B NOTE:
When you specify \-mcmodel=medium or \-mcmodel=large, you must also specify compiler option \-shared\-intel to ensure that the correct dynamic versions of the Intel run\-time libraries are used.
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-MD
.RS
.TP
Preprocess and compile, generating output file containing dependency information ending with extension .d. 
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler does not generate dependency information.
.TP
\fBDescription:\fR 
.PP
Preprocess and compile, generating output file containing dependency information ending with extension .d. 
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.RS
.TP
Tells the linker to search for unresolved references in a multithreaded, dynamic\-link run\-time library.  
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The linker searches for unresolved references in a single\-threaded, static run\-time library.
.TP
\fBDescription:\fR 
.PP
This option tells the linker to search for unresolved references in a multithreaded, dynamic\-link (DLL) run\-time library.  You can also specify /MDd, where d indicates a debug version.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-mdynamic\-no\-pic (M*X only)
.RS
.TP
Generates code that is not position\-independent but has position\-independent external references. 
.NL
.TP
\fBArchitectures:\fR IA\-32 architecture
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
All references are generated as position independent.
.TP
\fBDescription:\fR 
.PP
This option generates code that is not position\-independent but has position\-independent external references.
.NL
.PP
The generated code is suitable for building executables, but it is not suitable for building shared libraries.
.NL
.PP
This option may reduce code size and produce more efficient code. It overrides the \-fpic compiler option.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-MFfilename
.RS
.TP
Tells the compiler to generate makefile dependency information in a file.
.NL
.TP
\fBArchitectures:\fR IA\-32, Intel(R) 64 architecture
.TP
\fBArguments:\fR 
.TP 18
\fIfilename\fR
.NL
Is the name of the file where the makefile dependency information should be placed.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler does not generate makefile dependency information in files.
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to generate makefile dependency information in a file. To use this option, you must also specify /QM or /QMM. 
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-MG
.RS
.TP
Tells the compiler to generate makefile dependency lines for each source file.
.NL
.TP
\fBArchitectures:\fR IA\-32, Intel(R) 64 architecture
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler does not generate makefile dependency information in files.
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to generate makefile dependency lines for each source file. It is similar to /QM, but it treats missing header files as generated files. 
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-minstruction=[no]movbe
.RS
.TP
Determines whether MOVBE instructions are generated for Intel processors.
.NL
.TP
\fBArchitectures:\fR IA\-32, Intel(R) 64 architecture
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
–minstruction=nomovbe 
.NL
The compiler does not generate MOVBE instructions for Intel(R) Atom(TM) processors.
.TP
\fBDescription:\fR 
.PP
This option determines whether MOVBE instructions are generated for Intel processors. To use this option, you must also specify \-xSSSE3_ATOM (Linux* OS and OS X*) or /QxSSSE3_ATOM (Windows* OS).
.NL
.PP
If \-minstruction=movbe or /Qinstruction:movbe is specified, the following occurs:
.NL
.IP \(bu 2
MOVBE instructions are generated that are specific to the Intel(R) Atom(TM) processor.
.IP \(bu 2
The options are ON by default when \-xSSSE3_ATOM or /QxSSSE3_ATOM is specified.
.IP \(bu 2
Generated executables can only be run on Intel(R) Atom(TM) processors or processors that support Supplemental Streaming SIMD Extensions 3 (SSSE3) and MOVBE.
.PP
If \-minstruction=nomovbe or /Qinstruction:nomovbe is specified, the following occurs:
.NL
.IP \(bu 2
The compiler optimizes code for the Intel(R) Atom(TM) processor, but it does not generate MOVBE instructions.
.IP \(bu 2
Generated executables can be run on non\-Intel(R) Atom(TM) processors that support Intel(R)
SSE3.
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-mkl[=lib]
.RS
.TP
Tells the compiler to link to certain parts of the Intel(R) Math Kernel Library (Intel(R) MKL).
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.TP 18
\fIlib\fR
.NL
Indicates the part of the library that the compiler should link to. Possible values are:
.RS
.TP 15
parallel
Tells the compiler to link using the threaded part of the Intel(R) MKL. This is the default if the option is specified with no \fIlib\fR.
.TP 15
sequential
Tells the compiler to link using the non\-threaded part of the Intel(R) MKL.
.TP 15
cluster
Tells the compiler to link using the cluster part and the sequential part of the Intel(R) MKL.
.RE
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler does not link to the Intel(R) MKL.
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to link to certain parts of the Intel(R) Math Kernel Library (Intel(R) MKL).
.NL
.PP
.TP 18
\fBOptimization Notice 
\fR
.NL
.NL
.TP 18
= = = = = = = = = = 
.TP 18
Intel\[aq]s compilers may or may not optimize to the same degree for non\-Intel microprocessors for optimizations that are not unique to Intel microprocessors. These optimizations include SSE2, SSE3, and SSSE3 instruction sets and other optimizations. Intel does not guarantee the availability, functionality, or effectiveness of any optimization on microprocessors not manufactured by Intel. Microprocessor\-dependent optimizations in this product are intended for use with Intel microprocessors. Certain optimizations not specific to Intel microarchitecture are reserved for Intel microprocessors. Please refer to the applicable product User and Reference Guides for more information regarding the specific instruction sets covered by this notice. 
.TP 18
Notice revision #20110804 
.TP 18
= = = = = = = = = = 
.NL
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-MM
.RS
.TP
Tells the compiler to generate makefile dependency lines for each source file.
.NL
.TP
\fBArchitectures:\fR IA\-32, Intel(R) 64 architecture
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler does not generate makefile dependency information in files.
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to generate makefile dependency lines for each source file. It is similar to /QM, but it does not include system header files. 
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-MMD
.RS
.TP
Tells the compiler to generate an output file containing dependency information.
.NL
.TP
\fBArchitectures:\fR IA\-32, Intel(R) 64 architecture
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler does not generate an output file containing dependency information.
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to preprocess and compile a file, then generate an output file (with extension .d) containing dependency information. 
.NL
.PP
It is similar to /QMD, but it does not include system header files. 
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-mmic
(L*X only)
.RS
.TP
Builds an application that runs natively on Intel(R) MIC Architecture. This option only applies to Intel(R) MIC Architecture.
.NL
.TP
\fBArchitectures:\fR Intel(R) 64 architecture, targeting Intel(R) MIC Architecture
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler builds a heterogeneous application. You must specify this option to build an application that runs natively on Intel(R) MIC Architecture.
.TP
\fBDescription:\fR 
.PP
This option enables the cross compiler to build	an application that runs natively on Intel(R) MIC Architecture. It is only available on the command line.
.NL
.PP
When you use this option, the compiler defines the macro __MIC__.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-MP
.RS
.TP
Tells the compiler to add a phony target for each dependency. 
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler does not generate dependency information unless it is told to do so.
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to add a phony target for each dependency.
.NL
.PP
Note that this option is not related to Windows* option \fI/MP\fR.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-mp1
.RS
.TP
Improves floating\-point precision and consistency.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler provides good accuracy and run\-time performance at the expense of less consistent floating\-point results.
.TP
\fBDescription:\fR 
.PP
This option improves floating\-point consistency. It ensures the out\-of\-range check of operands of transcendental functions and improves the accuracy of floating\-point compares.
.NL
.PP
This option prevents the compiler from performing optimizations that change NaN comparison semantics and causes all values to be truncated to declared precision before they are used in comparisons. It also causes the compiler to use library routines that give better precision results compared to the X87 transcendental instructions.
.NL
.PP
This option disables fewer optimizations and has less impact on performance than option \-fp\-model precise (Linux* OS and OS X*) or option /fp:precise (Windows* OS).
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-MQtarget
.RS
.TP
Changes the default target rule for dependency generation. 
.NL
.TP
\fBArchitectures:\fR IA\-32, Intel(R) 64 architecture
.TP
\fBArguments:\fR 
.TP 18
\fItarget\fR
.NL
Is the target rule to use.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The default target rule applies to dependency generation.
.TP
\fBDescription:\fR 
.PP
This option changes the default target rule for dependency generation. It is similar to \-MT, but quotes special Make characters. 
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-mregparm=value
.RS
.TP
Control the number registers used to pass integer arguments.
.NL
.TP
\fBArchitectures:\fR IA\-32 architecture
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler does not use registers to pass arguments.
.TP
\fBDescription:\fR 
.PP
Control the number registers used to pass integer arguments.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-MTtarget
.RS
.TP
Changes the default target rule for dependency generation. 
.NL
.TP
\fBArchitectures:\fR IA\-32, Intel(R) 64 architecture
.TP
\fBArguments:\fR 
.TP 18
\fItarget\fR
.NL
Is the target rule to use.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The default target rule applies to dependency generation.
.TP
\fBDescription:\fR 
.PP
This option changes the default target rule for dependency generation.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-mtune=processor
.RS
.TP
Performs optimizations for specific processors.
.NL
.TP
\fBArchitectures:\fR IA\-32, Intel(R) 64 architecture
.TP
\fBArguments:\fR 
.TP 18
\fIprocessor\fR
.NL
Is the processor for which the compiler should perform optimizations.    Possible values are: 
.RS
.TP 15
generic
Generates code for the compiler\[aq]s default behavior.
.TP 15
core2
Optimizes for the Intel(R) Core(TM) 2 processor family, including support for MMX(TM), Intel(R) SSE, SSE2, SSE3 and SSSE3 instruction sets.
.TP 15
pentium
Optimizes for Intel(R) Pentium(R) processors.
.TP 15
pentium\-mmx
Optimizes for Intel(R) Pentium(R) with MMX technology.
.TP 15
pentiumpro
Optimizes for Intel(R) Pentium(R) Pro, Intel Pentium II, and Intel Pentium III processors.
.TP 15
pentium4
Optimizes for Intel(R) Pentium(R) 4 processors.
.TP 15
pentium4m
Optimizes for Intel(R) Pentium(R) 4 processors with MMX technology.
.RE
.TP
\fBDefault:\fR 
.TP 18
generic
.NL
Code is generated for the compiler\[aq]s default behavior.
.TP
\fBDescription:\fR 
.PP
This option performs optimizations for specific processors.
.NL
.PP
The resulting executable is backwards compatible and generated code is optimized for specific processors. For example, code generated with \-mtune=pentium4 will run correctly on Core2 processors, but it might not run as fast as if it had been generated using \-mtune=core2.
.NL
.PP
The following table shows on which architecture you can use each value.
.NL
.PP
.TP 18
\fBOptimization Notice 
\fR
.NL
.NL
.TP 18
= = = = = = = = = = 
.TP 18
Intel\[aq]s compilers may or may not optimize to the same degree for non\-Intel microprocessors for optimizations that are not unique to Intel microprocessors. These optimizations include SSE2, SSE3, and SSSE3 instruction sets and other optimizations. Intel does not guarantee the availability, functionality, or effectiveness of any optimization on microprocessors not manufactured by Intel. Microprocessor\-dependent optimizations in this product are intended for use with Intel microprocessors. Certain optimizations not specific to Intel microarchitecture are reserved for Intel microprocessors. Please refer to the applicable product User and Reference Guides for more information regarding the specific instruction sets covered by this notice. 
.TP 18
Notice revision #20110804 
.TP 18
= = = = = = = = = = 
.NL
.NL
.TP
\fBAlternate Options:\fR 
.TP 18
\-mtune
.NL
Linux: \-mcpu (this is a deprecated option)
.IP
OS X: None
.RE
.TP
.B
\-multibyte\-chars
.TP
.B
\-no\-multibyte\-chars
.RS
.TP
Determines whether multi\-byte characters are supported.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-multibyte\-chars
.NL
Multi\-byte characters are supported.
.TP
\fBDescription:\fR 
.PP
This option determines whether multi\-byte characters are supported.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-multiple\-processes[=n]
.RS
.TP
Creates multiple processes that can be used to compile large numbers of source files at the same time. 
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.TP 18
\fIn\fR
.NL
Is the maximum number of processes that the compiler should create. 
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
A single process is used to compile source files.  
.TP
\fBDescription:\fR 
.PP
This option creates multiple processes that can be used to compile large numbers of source files at the same time. It can improve performance by reducing the time it takes to compile source files on the command line.
.NL
.PP
This option causes the compiler to create one or more copies of itself, each in a separate process. These copies simultaneously compile the source files.
.NL
.PP
If \fIn\fR is not specified for this option, the default value is as follows:
.NL
.IP \(bu 2
On Windows* OS, the value is based on the setting of the NUMBER_OF_PROCESSORS environment variable. 
.IP \(bu 2
On Linux* OS and OS X*, the value is 2. 
.PP
This option applies to compilations, but not to linking or link\-time code generation.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-no\-bss\-init
.RS
.TP
Tells the compiler to place in the DATA section any uninitialized variables and explicitly zero\-initialized variables.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
Uninitialized variables and explicitly zero\-initialized variables are placed in the BSS section.
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to place in the DATA section any uninitialized variables and explicitly zero\-initialized variables.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-no\-libgcc
.RS
.TP
Prevents the linking of  certain gcc\-specific libraries.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
.TP
\fBDescription:\fR 
.PP
This option prevents the linking of  certain gcc\-specific libraries.
.NL
.PP
This option is not recommended for general use.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-no\-offload (L*X only)
.RS
.TP
Causes the compiler to ignore language constructs for offloading. This option only applies to Intel(R) MIC Architecture.
.NL
.TP
\fBArchitectures:\fR Intel(R) 64 architecture, targeting Intel(R) MIC Architecture
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler recognizes language constructs for offloading if they are specified.
.TP
\fBDescription:\fR 
.PP
This option causes the compiler to ignore language constructs for offloading.
.NL
.PP
If this option is not specified, the compiler does the following by default:
.NL
.IP \(bu 2
It recognizes language constructs for offloading that appear  in the source program and builds a heterogeneous binary that runs on both the target and host.
.IP \(bu 2
It causes two compilations or links to occur:
.RS
.IP \(bu 2
The host compiler generates code that sends input data to the target and receives results from the target. 
.IP \(bu 2
The target compiler generates code that receives input data from the host, performs the computation and then returns results to the host.
.RE
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-nodefaultlibs
.RS
.TP
Prevents the compiler from using standard libraries when linking.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The standard libraries are linked.
.TP
\fBDescription:\fR 
.PP
This option prevents the compiler from using standard libraries when linking. It is provided for GNU compatibility.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-nolib\-inline
.RS
.TP
Disables inline expansion of standard library or intrinsic functions.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler inlines many standard library and intrinsic functions.
.TP
\fBDescription:\fR 
.PP
This option disables inline expansion of standard library or intrinsic functions. It prevents the unexpected results that can arise from inline expansion of these functions.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-nostartfiles
.RS
.TP
Prevents the compiler from using standard startup files when linking.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler uses standard startup files when linking.
.TP
\fBDescription:\fR 
.PP
This option prevents the compiler from using standard startup files when linking.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-nostdinc++
.RS
.TP
Do not search for header files in the standard directories for C++, but search the other standard directories.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
.TP
\fBDescription:\fR 
.PP
Do not search for header files in the standard directories for C++, but search the other standard directories.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-nostdlib
.RS
.TP
Prevents the compiler from using standard libraries and startup files when linking.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler uses standard startup files and standard libraries when linking.
.TP
\fBDescription:\fR 
.PP
This option prevents the compiler from using standard libraries and startup files when linking. It is provided for GNU compatibility.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-o filename
.RS
.TP
Specifies the name for an output file.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.TP 18
\fIfilename\fR
.NL
Is the name for the output file. The space before \fIfilename\fR is optional.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler uses the default file name for an output file.
.TP
\fBDescription:\fR 
.PP
This option specifies the name for an output file as follows:
.NL
.IP \(bu 2
If \-c is specified, it specifies the name of the generated object file.
.IP \(bu 2
If \-S is specified, it specifies the name of the generated assembly listing file.
.IP \(bu 2
If \-P is specified, it specifies the name of the generated preprocessor file.
.PP
Otherwise, it specifies the name of the executable file.
.NL
.PP
.B NOTE:
If you misspell a compiler option beginning with "o", such as \-openmp, \-opt\-report, etc., the compiler interprets the misspelled option as an \-o\fIfilename\fR option. For example, say you misspell "\-opt\-report" as " \-opt\-reprt"; in this case, the compiler interprets the misspelled option as "\-o pt\-reprt", where pt\-reprt is the output file name.
.TP
\fBAlternate Options:\fR 
.PP
Linux and OS X: None
.NL
.PP
Windows: /Fe
.NL
.RE
.TP
.B
\-O[n]
.RS
.TP
Specifies the code optimization for applications.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.TP 18
\fIn\fR
.NL
Is the optimization level. Possible values are 1, 2, or 3. On Linux* and OS X* systems, you can also specify 0.
.TP
\fBDefault:\fR 
.TP 18
O2
.NL
Optimizes for code speed. This default may change depending on which other compiler options are specified. For details, see below.
.TP
\fBDescription:\fR 
.PP
This option specifies the code optimization for applications.
.NL
.TP 18
\fBOption\fR
.NL
.NL
\fBDescription\fR
.NL
.NL
.TP 18
O (Linux* OS and OS X*)
.NL
This is the same as specifying O2.
.NL
.TP 18
O0 (Linux OS and OS X)
.NL
Disables all optimizations. 
.TP 18
This option may set other options. This is determined by the compiler, depending on which operating system and architecture you are using. The options that are set may change from release to release.
.NL
.TP 18
O1
.NL
Enables optimizations for speed and disables some optimizations that increase code size and affect speed. To limit code size, this option:
.RS
.IP \(bu 2
Enables global optimization; this includes data\-flow analysis, code motion, strength reduction and test replacement, split\-lifetime analysis, and instruction scheduling.
.IP \(bu 2
Disables inlining of some intrinsics.
.RE
.TP 18
This option may set other options. This is determined by the compiler, depending on which operating system and architecture you are using. The options that are set may change from release to release.
.TP 18
The O1 option may improve performance for applications with very large code size, many branches, and execution time not dominated by code within loops.
.NL
.TP 18
O2
.NL
Enables optimizations for speed. This is the generally recommended optimization level.  Vectorization is enabled at O2 and higher levels.
.TP 18
On systems using IA\-32 architecture: Some basic loop optimizations such as Distribution, Predicate Opt, Interchange, multi\-versioning, and scalar replacements are performed.
.TP 18
This option also enables:
.RS
.IP \(bu 2
Inlining of intrinsics
.IP \(bu 2
Intra\-file interprocedural optimization, which includes:
.RS
.IP \(bu 2
inlining
.IP \(bu 2
constant propagation
.IP \(bu 2
forward substitution
.IP \(bu 2
routine attribute propagation
.IP \(bu 2
variable address\-taken analysis
.IP \(bu 2
dead static function elimination
.IP \(bu 2
removal of unreferenced variables
.RE
.IP \(bu 2
The following capabilities for performance gain:
.RS
.IP \(bu 2
constant propagation
.IP \(bu 2
copy propagation
.IP \(bu 2
dead\-code elimination
.IP \(bu 2
global register allocation
.IP \(bu 2
global instruction scheduling and control speculation
.IP \(bu 2
loop unrolling
.IP \(bu 2
optimized code selection
.IP \(bu 2
partial redundancy elimination
.IP \(bu 2
strength reduction/induction variable simplification
.IP \(bu 2
variable renaming
.IP \(bu 2
exception handling optimizations
.IP \(bu 2
tail recursions
.IP \(bu 2
peephole optimizations
.IP \(bu 2
structure assignment lowering and optimizations
.IP \(bu 2
dead store elimination
.RE
.RE
.TP 18
This option may set other options,  especially options that optimize for code speed. This is determined by the compiler, depending on which operating system and architecture you are using. The options that are set may change from release to release.
.TP 18
On Linux systems, the \-debug inline\-debug\-info option will be enabled by default if you compile with optimizations (option \-O2 or higher) and debugging is enabled (option \-g).
.TP 18
Many routines in the shared libraries are more highly optimized for Intel(R) microprocessors than for non\-Intel microprocessors.
.NL
.TP 18
O3
.NL
Performs O2 optimizations and enables more aggressive loop transformations such as Fusion, Block\-Unroll\-and\-Jam, and collapsing IF statements.
.TP 18
This option may set other options. This is determined by the compiler, depending on which operating system and architecture you are using. The options that are set may change from release to release.
.TP 18
When O3 is used with options \-ax or \-x (Linux OS) or with options /Qax or /Qx (Windows OS), the compiler performs more aggressive data dependency analysis than for O2, which may result in longer compilation times.
.TP 18
The O3 optimizations may not cause higher performance unless loop and memory access transformations take place. The optimizations may slow down code in some cases compared to O2 optimizations.
.TP 18
The O3 option is recommended for applications that have loops that heavily use floating\-point calculations and process large data sets. 
.TP 18
Many routines in the shared libraries are more highly optimized for Intel(R) microprocessors than for non\-Intel microprocessors.
.NL
.PP
The last O option specified on the command line takes precedence over any others.
.NL
.RE
.TP
.B
\-offload\-attribute\-target=target\-name (L*X only)
.RS
.TP
Causes the compiler to flag file\-scope functions and  data objects in the source file with the offload attribute "target(mic)".  
.NL
.TP
\fBArchitectures:\fR Intel(R) 64 architecture, targeting Intel(R) MIC Architecture
.TP
\fBArguments:\fR 
.TP 18
\fItarget\-name\fR
.NL
Is a specific target. The only supported value for this argument is mic. 
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler does not flag file\-scope functions and data objects in the source file with the offload attribute target(mic).
.TP
\fBDescription:\fR 
.PP
This option causes the compiler to flag file\-scope functions and data objects in the source file with the offload attribute target(mic).
.NL
.PP
This option is similar to using the  pragma offload_attribute target(mic) to set the attribute target(mic)   for all functions and data objects in the file scope. 
.NL
.PP
Target declspecs/attributes on individual declarations take precedence over any offload_attribute pragma in effect, and declspecs, attributes, and pragmas all  take precedence over this option.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-offload\-option,target,tool,"option\-list" (L*X only)
.RS
.TP
Lets you explicitly specify options to be used for the specified target and tool. This option only applies to Intel(R) MIC Architecture.
.NL
.TP
\fBArchitectures:\fR Intel(R) 64 architecture, targeting Intel(R) MIC Architecture
.TP
\fBArguments:\fR 
.TP 18
\fItarget\fR
.NL
Is the target architecture. The only supported value for this argument is mic.
.TP 18
\fItool\fR
.NL
Is the tool that the option\-list is associated with.  It can be one of the following values: ld, as, or compiler.
.TP 18
\fIoption\-list\fR
.NL
Is one or more options that are specific to the tool.  The quotation mark delimiters are required. Each  option in the \fIoption\-list\fR must be separated by a space. 
.IP
For tool compiler, use compiler\-specific options; for tool ld, use linker\-specific options;  for tool as, use assembler\-specific options. 
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler does not pass additional options to the separate tools on the target architecture.
.TP
\fBDescription:\fR 
.PP
This option lets you explicitly specify options to be used for the specified target and tool. It can be specified multiple times on the command line.
.NL
.PP
When building a heterogeneous application, the driver passes all compiler options specified on the command\-line to the host compilation and only certain options to the offload compilation. To see a list of options passed to the offload compilation, specify option –watch=mic\-cmd.
.NL
.PP
If you want to pass additional options to the offload compilation, or you would like to override the command line options passed to offload compilation, you must use option \-offload\-option to specify the additional or overriding options.
.NL
.PP
.B NOTE:
If you specify the options I, L, D, or U with the \-offload\-option option, they override any other I, L, D, and U options that are automatically passed from host to offload compilation.
.PP
To achieve the overriding effect, the I, L, D, and U options specified using \-offload\-option are placed ahead of the I, L, D, and U options automatically copied over from the host compilation. All other options specified using \-offload\-option are placed after the options copied over from host to offload compilation.
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-openmp
.RS
.TP
Enables the parallelizer to generate multi\-threaded code based on OpenMP* directives.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
No OpenMP* multi\-threaded code is generated by the compiler.
.TP
\fBDescription:\fR 
.PP
This option enables the parallelizer to generate multi\-threaded code based on OpenMP* directives. The code can be executed in parallel on both uniprocessor and multiprocessor systems. 
.NL
.PP
This option works with any optimization level. Specifying no optimization (\-O0 on Linux* OS or /Od on Windows* OS) helps to debug OpenMP applications.
.NL
.PP
.B NOTE:
On OS X* systems, when you enable OpenMP*, you must also set the DYLD_LIBRARY_PATH environment variable within Xcode* or an error will be displayed.
.PP
.B NOTE:
Options that use OpenMP* are available for both Intel(R) microprocessors and non\-Intel microprocessors, but these options may perform additional optimizations on Intel(R) microprocessors than they perform on non\-Intel microprocessors.  The list of major, user\-visible OpenMP constructs and features that may perform differently on Intel(R) microprocessors versus non\-Intel microprocessors include: locks (internal and user visible), the SINGLE construct, barriers (explicit and implicit), parallel loop scheduling, reductions, memory allocation, thread affinity, and binding.
.PP
.TP 18
\fBOptimization Notice 
\fR
.NL
.NL
.TP 18
= = = = = = = = = = 
.TP 18
Intel\[aq]s compilers may or may not optimize to the same degree for non\-Intel microprocessors for optimizations that are not unique to Intel microprocessors. These optimizations include SSE2, SSE3, and SSSE3 instruction sets and other optimizations. Intel does not guarantee the availability, functionality, or effectiveness of any optimization on microprocessors not manufactured by Intel. Microprocessor\-dependent optimizations in this product are intended for use with Intel microprocessors. Certain optimizations not specific to Intel microarchitecture are reserved for Intel microprocessors. Please refer to the applicable product User and Reference Guides for more information regarding the specific instruction sets covered by this notice. 
.TP 18
Notice revision #20110804 
.TP 18
= = = = = = = = = = 
.NL
.NL
.TP
\fBAlternate Options:\fR 
.PP
Linux and OS X: \-fopenmp
.NL
.RE
.TP
.B
\-openmp\-lib=type
.RS
.TP
Lets you specify an OpenMP* run\-time library to use for linking.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.TP 18
\fItype\fR
.NL
Specifies the type of library to use; it implies compatibility levels. Currently, the only possible value is:
.RS
.TP 15
compat
Tells the compiler to use the compatibility OpenMP* run\-time library (libiomp). This setting provides compatibility with object files created using Microsoft* and GNU* compilers.
.RE
.TP
\fBDefault:\fR 
.TP 18
\-openmp\-lib=compat 
.NL
The compiler uses the compatibility OpenMP* run\-time library (libiomp).
.TP
\fBDescription:\fR 
.PP
This option lets you specify an OpenMP* run\-time library to use for linking.
.NL
.PP
The compatibility OpenMP run\-time libraries are compatible with object files created using the Microsoft* OpenMP run\-time library (vcomp) or the GNU OpenMP run\-time library (libgomp).
.NL
.PP
To use the compatibility OpenMP run\-time library, compile and link your application using the \-openmp\-lib=compat  (Linux* OS) or /Qopenmp\-lib:compat (Windows* OS) option. To use this option, you must also specify one of the following compiler options:
.NL
.IP \(bu 2
Linux* OS: \-openmp  or \-openmp\-stubs
.IP \(bu 2
Windows* OS: /Qopenmp or /Qopenmp\-stubs
.PP
On Windows* systems, the compatibility OpenMP* run\-time library lets you combine OpenMP* object files compiled with the Microsoft* C/C++ compiler with OpenMP* object files compiled with the Intel(R) C, Intel(R) C++, or Intel(R) Fortran compilers. The linking phase results in a single, coherent copy of the run\-time library.
.NL
.PP
On Linux* systems, the compatibility Intel OpenMP* run\-time library lets you combine OpenMP* object files compiled with the GNU* gcc or gfortran compilers with similar OpenMP* object files compiled with the Intel(R) C, Intel(R) C++, or Intel(R) Fortran compilers. The linking phase results in a single, coherent copy of the run\-time library.
.NL
.PP
.B NOTE:
The compatibility OpenMP run\-time library is not compatible with object files created using versions of the Intel compilers earlier than 10.0.
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-openmp\-link=library
.RS
.TP
Controls whether the compiler links to static or dynamic OpenMP* run\-time libraries. This is a deprecated option.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.TP 18
\fIlibrary\fR
.NL
Specifies the OpenMP library to use. Possible values are:
.RS
.TP 15
static
Tells the compiler to link to static OpenMP run\-time libraries. Note that static OpenMP libraries are deprecated.
.TP 15
dynamic
Tells the compiler to link to dynamic OpenMP run\-time libraries.
.RE
.TP
\fBDefault:\fR 
.TP 18
\-openmp\-link=dynamic
.NL
The compiler links to dynamic OpenMP* run\-time libraries. However, if Linux* OS option \-static is specified, the compiler links to static OpenMP run\-time libraries.
.TP
\fBDescription:\fR 
.PP
This option controls whether the compiler links to static or dynamic OpenMP* run\-time libraries.
.NL
.PP
To link to the static OpenMP run\-time library (RTL) and create a purely static executable, you must specify \-openmp\-link=static. However, we strongly recommend you use the default setting, \-openmp\-link=dynamic.
.NL
.PP
.B NOTE:
Compiler options \-static\-intel and \-shared\-intel (Linux* OS and OS X*) have no effect on which OpenMP run\-time library is linked. 
.PP
.B NOTE:
On Linux* systems, \-openmp\-link=dynamic
cannot be used in conjunction with option \-static. If you try to specify both options together, an error will be displayed.
.PP
.B NOTE:
On Linux systems, the OpenMP runtime library depends on using libpthread and libc (libgcc when compiled with gcc). Libpthread and libc (libgcc) must both be static or both be dynamic. If both libpthread and libc (libgcc) are static, then the static version of the OpenMP runtime should be used. If both libpthread and libc (libgcc) are dynamic, then either the static or dynamic version of the OpenMP runtime may be used.
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-openmp\-report[=n]
.RS
.TP
Controls the OpenMP* parallelizer\[aq]s level of diagnostic messages.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.TP 18
\fIn\fR
.NL
Is the level of diagnostic messages to display. Possible values are:
.RS
.TP 15
0
No diagnostic messages are displayed.
.TP 15
1
Diagnostic messages are displayed indicating loops, regions, and sections successfully parallelized.
.TP 15
2
The same diagnostic messages are displayed that are specified by 1.  In addition, the following are displayed: diagnostic messages indicating successful handling of MASTER constructs, SINGLE constructs, CRITICAL constructs, ORDERED constructs, ATOMIC directives, and so forth.
.RE
.TP
\fBDefault:\fR 
.TP 18
\-openmp\-report=1 
.NL
If you do not specify \fIn\fR, the compiler displays 
diagnostic messages indicating loops, regions, and sections successfully parallelized. If you do not specify the option on the command line, the default is to display no messages.
.TP
\fBDescription:\fR 
.PP
This option controls the OpenMP* parallelizer\[aq]s level of diagnostic messages. To use this option, you must also specify \-openmp (Linux* OS and OS X*) or /Qopenmp (Windows* OS).
.NL
.PP
If this option is specified on the command line, the report is sent to stdout. 
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-openmp\-stubs
.RS
.TP
Enables compilation of OpenMP* programs in sequential mode.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The library of OpenMP* function stubs is not linked.
.TP
\fBDescription:\fR 
.PP
This option enables compilation of OpenMP* programs in sequential mode. The OpenMP directives are ignored and a stub OpenMP library is linked. 
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-openmp\-task=model
.RS
.TP
Lets you choose an OpenMP* tasking model.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.TP 18
\fImodel\fR
.NL
Is an OpenMP tasking model. Possible values are:
.RS
.TP 15
intel
Tells the compiler to accept Intel taskqueuing pragmas (#pragma intel_omp_taskq and #pragma intel_omp_task). When this value is specified, OpenMP 3.0 tasking pragmas are ignored; if they are specified, warnings are issued.
.TP 15
omp
Tells the compiler to accept OpenMP* 3.0 tasking pragmas (#pragma omp_task). When this value is specified, Intel taskqueuing pragmas are ignored; if they are specified, warnings are issued.
.RE
.TP
\fBDefault:\fR 
.TP 18
\-openmp\-task=omp
.NL
The compiler accepts OpenMP 3.0 tasking pragmas.
.TP
\fBDescription:\fR 
.PP
The option lets you choose an OpenMP tasking model.
.NL
.PP
To use this option, you must also specify option \-openmp (Linux OS and OS X) or /Qopenmp (Windows OS).
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-openmp\-threadprivate=type (L*X only)
.RS
.TP
Lets you specify an OpenMP* threadprivate implementation.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.TP 18
\fItype\fR
.NL
Specifies the type of threadprivate implementation. Possible values are:
.RS
.TP 15
legacy
Tells the compiler to use the legacy OpenMP* threadprivate implementation used in the previous releases of the Intel(R) compiler. This setting does not provide compatibility with the implementation used by other compilers.  
.TP 15
compat
Tells the compiler to use the compatibility OpenMP* threadprivate implementation  based on applying the __declspec(thread) attribute to each threadprivate variable. The limitations of the attribute on a given platform also apply to the threadprivate implementation. This setting provides compatibility with the implementation provided by the Microsoft* and GNU* compilers.  
.RE
.TP
\fBDefault:\fR 
.TP 18
\-openmp\-threadprivate=legacy 
.NL
The compiler uses the legacy OpenMP* threadprivate implementation used in the previous releases of the Intel compiler. 
.TP
\fBDescription:\fR 
.PP
This option lets you specify an OpenMP* threadprivate implementation.
.NL
.PP
The threadprivate implementation of the legacy OpenMP run\-time library may not be compatible with object files created using OpenMP run\-time libraries supported in other compilers.
.NL
.PP
To use this option, you must also specify one of the following compiler options: 
.NL
.IP \(bu 2
Linux* OS: \-openmp or \-openmp\-stubs
.IP \(bu 2
Windows* OS: /Qopenmp or /Qopenmp\-stubs
.PP
The value specified for this option is independent of the value used for option \-openmp\-lib (Linux OS) or /Qopenmp\-lib (Windows OS).
.NL
.PP
.B NOTE:
On OS X* systems, legacy is the only type of threadprivate supported.  Option \-openmp\-threadprivate
is not recognized by the compiler.
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-opt\-args\-in\-reg[=keyword]
.RS
.TP
Determines whether calls to routines are optimized by passing parameters  in registers instead of on the stack.
.NL
.TP
\fBArchitectures:\fR IA\-32 architecture
.TP
\fBArguments:\fR 
.TP 18
keyword
.NL
Specifies whether the optimization should be performed 
and under what conditions.
Possible values are:
.RS
.TP 15
none
The optimization is not performed. No parameters 
are passed in registers. They are put on the stack.
.TP 15
seen
Causes parameters 
to be passed in registers when they are passed to routines whose definition can be seen in the same compilation unit.
.TP 15
all
Causes parameters 
to be passed in registers, whether they are passed to routines whose definition can be seen in the same compilation unit, or not. This value is only available on Linux* systems.
.RE
.TP
\fBDefault:\fR 
.TP 18
\-opt\-args\-in\-regs=seen
.NL
Parameters 
are passed in registers when they are passed to routines whose
definition is seen in the same compilation unit
.TP
\fBDescription:\fR 
.PP
This option determines whether calls to
routines are optimized by passing parameters 
in registers instead of on the stack. It also indicates the conditions when the optimization
will be performed.
.NL
.PP
This option can improve performance for
Application Binary Interfaces (ABIs) that
require parameters 
to be passed in memory and compiled without
interprocedural optimization (IPO).
.NL
.PP
Note that on Linux* systems, if all is specified, a small
overhead may be paid when calling "unseen" routines that have not
been compiled with the same option. This is because the call will
need to go through a "thunk" to ensure that parameters 
are placed back on the stack where the callee
expects them.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-opt\-block\-factor=n
.RS
.TP
Lets you specify a loop blocking factor.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.TP 18
\fIn\fR
.NL
Is the blocking factor. It must be an integer. The compiler may ignore the blocking factor if the value is 0 or 1. 
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler uses default heuristics for loop blocking.
.TP
\fBDescription:\fR 
.PP
This option lets you specify a loop blocking factor.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-opt\-calloc (L*X only)
.TP
.B
\-no\-opt\-calloc (L*X only)
.RS
.TP
Tells the compiler to substitute a call to _intel_fast_calloc() for a call to calloc().
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-no\-opt\-calloc
.NL
The compiler does not substitute a call to _intel_fast_calloc() for a call to calloc().
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to substitute a call to_intel_fast_calloc() for a call to calloc().
.NL
.PP
This option may increase the performance of long\-running programs that use calloc() frequently. It is recommended for these programs over combinations of options \-inline\-calloc and \-opt\-malloc\-options=3 because this option causes less memory fragmentation.
.NL
.PP
.B NOTE:
Many routines in the LIBIRC library are more highly optimized for Intel(R) microprocessors than for non\-Intel microprocessors.
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-opt\-class\-analysis
.TP
.B
\-no\-opt\-class\-analysis
.RS
.TP
Determines whether C++ class hierarchy information is used to analyze and resolve C++ virtual function calls at compile time. 
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-no\-opt\-class\-analysis 
.NL
C++ class hierarchy information is not used to analyze and resolve C++ virtual function calls at compile time. 
.TP
\fBDescription:\fR 
.PP
This option determines whether C++ class hierarchy information is used to analyze and resolve C++ virtual function calls at compile time. The option is turned on by default with the \-ipo compiler option, enabling improved C++ optimization. If a C++ application contains non\-standard C++ constructs, such as pointer down\-casting, it may result in different behaviors.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-opt\-jump\-tables=keyword
.TP
.B
\-no\-opt\-jump\-tables
.RS
.TP
Enables or disables generation of jump tables for switch statements.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.TP 18
\fIkeyword\fR
.NL
Is the instruction for generating jump tables. Possible values are: 
.RS
.TP 15
never
Tells the compiler to never generate jump tables. All switch statements are implemented as chains of if\-then\-elses. This is the same as specifying \-no\-opt\-jump\-tables (Linux* OS and OS X*) or /Qopt\-jump\-tables\- (Windows* OS).
.TP 15
default
The compiler uses default heuristics to determine when to generate jump tables. 
.TP 15
large
Tells the compiler to generate jump tables up to a certain pre\-defined size (64K entries). 
.TP 15
n
Must be an integer. Tells the compiler to generate jump tables up to \fIn\fR entries in size. 
.RE
.TP
\fBDefault:\fR 
.TP 18
\-opt\-jump\-tables=default 
.NL
The compiler uses default heuristics to determine when to generate jump tables for switch statements.
.TP
\fBDescription:\fR 
.PP
This option enables or disables generation of jump tables for switch statements. When the option is enabled, it may improve performance for programs with large switch statements.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-opt\-malloc\-options=n
.RS
.TP
Lets you specify an alternate algorithm for malloc().
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.TP 18
\fIn\fR
.NL
Specifies the algorithm to use for malloc(). Possible values are:
.RS
.TP 15
0
Tells the compiler to use the default algorithm for malloc(). This is the default.
.TP 15
1
Causes the following adjustments to the malloc() algorithm: M_MMAP_MAX=2 and M_TRIM_THRESHOLD=0x10000000.
.TP 15
2
Causes the following adjustments to the malloc() algorithm: M_MMAP_MAX=2 and M_TRIM_THRESHOLD=0x40000000.
.TP 15
3
Causes the following adjustments to the malloc() algorithm: M_MMAP_MAX=0 and M_TRIM_THRESHOLD=\-1.
.TP 15
4
Causes the following adjustments to the malloc() algorithm: M_MMAP_MAX=0, M_TRIM_THRESHOLD=\-1, M_TOP_PAD=4096.
.RE
.TP
\fBDefault:\fR 
.TP 18
\-opt\-malloc\-options=0
.NL
The compiler uses the default algorithm when malloc() is called. No call is made to mallopt().
.TP
\fBDescription:\fR 
.PP
This option lets you specify an alternate algorithm for malloc().
.NL
.PP
If you specify a non\-zero value for \fIn\fR, it causes alternate configuration parameters to be set for how malloc() allocates and frees memory. It tells the compiler to insert calls to mallopt() to adjust these parameters to malloc() for dynamic memory allocation. This may improve speed.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-opt\-matmul (L*X only)
.TP
.B
\-no\-opt\-matmul (L*X only)
.RS
.TP
Enables or disables a compiler\-generated Matrix Multiply (matmul)
library call.
.NL
.TP
\fBArchitectures:\fR IA\-32, Intel(R) 64 architecture
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-no\-opt\-matmul 
.NL
The matmul library call optimization does not occur unless this option is enabled or certain other compiler options are specified (see below).
.TP
\fBDescription:\fR 
.PP
This option enables or disables a compiler\-generated Matrix Multiply (MATMUL)
library call.
.NL
.PP
Options \-opt\-matmul and /Qopt\-matmul tell the compiler to identify matrix multiplication loop nests (if any) and replace them with a matmul library call for improved performance.  The resulting executable may get additional performance gain on Intel(R) microprocessors than on non\-Intel microprocessors. 
.NL
.PP
This option is enabled by default if options O3
and \-parallel (Linux* OS) or /Qparallel (Windows* OS) are specified.
To disable this optimization, specify \-no\-opt\-matmul or
/Qopt\-matmul\-.
.NL
.PP
This option has no effect unless option O2 or
higher is set.
.NL
.PP
.B NOTE:
Many routines in the MATMUL library are more highly optimized for Intel(R) microprocessors than for non\-Intel microprocessors.
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-opt\-mem\-layout\-trans[=n]
.TP
.B
\-no\-opt\-mem\-layout\-trans
.RS
.TP
Controls the level of memory layout transformations performed by the compiler.
.NL
.TP
\fBArchitectures:\fR IA\-32, Intel(R) 64 architecture
.TP
\fBArguments:\fR 
.TP 18
\fIn\fR
.NL
Is the level of memory layout transformations. Possible values are:
.RS
.TP 15
0
Disables memory layout transformations. This is the same as specifying \-no\-opt\-mem\-layout\-trans (Linux* OS and OS X*) or /Qopt\-mem\-layout\-trans\- (Windows* OS).
.TP 15
1
Enables basic memory layout transformations.
.TP 15
2
Enables more memory layout transformations. This is the same as specifying \-opt\-mem\-layout\-trans (Linux* OS and OS X*) or /Qopt\-mem\-layout\-trans (Windows* OS) with no argument.
.TP 15
3
Enables aggressive memory layout transformations. You should only use this setting if your system has more than 4GB of physical memory per core.
.RE
.TP
\fBDefault:\fR 
.TP 18
\-opt\-mem\-layout\-trans=2
.NL
The compiler performs moderate memory layout transformations.
.TP
\fBDescription:\fR 
.PP
This option controls the level of memory layout transformations performed by the compiler. This option can improve cache reuse and cache locality.
.NL
.PP
.TP 18
\fBOptimization Notice 
\fR
.NL
.NL
.TP 18
= = = = = = = = = = 
.TP 18
Intel\[aq]s compilers may or may not optimize to the same degree for non\-Intel microprocessors for optimizations that are not unique to Intel microprocessors. These optimizations include SSE2, SSE3, and SSSE3 instruction sets and other optimizations. Intel does not guarantee the availability, functionality, or effectiveness of any optimization on microprocessors not manufactured by Intel. Microprocessor\-dependent optimizations in this product are intended for use with Intel microprocessors. Certain optimizations not specific to Intel microarchitecture are reserved for Intel microprocessors. Please refer to the applicable product User and Reference Guides for more information regarding the specific instruction sets covered by this notice. 
.TP 18
Notice revision #20110804 
.TP 18
= = = = = = = = = = 
.NL
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-opt\-multi\-version\-aggressive
.TP
.B
\-no\-opt\-multi\-version\-aggressive
.RS
.TP
Tells the compiler to use aggressive multi\-versioning to check for pointer aliasing and scalar replacement. 
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-no\-opt\-multi\-version\-aggressive 
.NL
The compiler uses default heuristics when checking for pointer aliasing and scalar replacement.
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to use aggressive multi\-versioning to check for pointer aliasing and scalar replacement. This option may improve performance.
.NL
.PP
The performance can be affected by certain options, such as /arch or /Qx (Windows OS) or \-m or \-x (Linux OS and OS X).
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-opt\-prefetch[=n]
.TP
.B
\-no\-opt\-prefetch
.RS
.TP
Enables or disables  prefetch insertion optimization.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.TP 18
\fIn\fR
.NL
Is the level of detail in the report. Possible values are:
.RS
.TP 15
0
Disables software prefetching. This is the same as specifying \-no\-opt\-prefetch (Linux* OS and OS X*) or /Qopt\-prefetch\- (Windows* OS).  
.TP 15
1 to 4
Enables different levels of software prefetching. If you do not specify a value for \fIn\fR, the default is 2. Use lower values to reduce the amount of prefetching.
.RE
.TP
\fBDefault:\fR 
.TP 18
\-no\-opt\-prefetch 
.NL
Prefetch insertion optimization is disabled.
.TP
\fBDescription:\fR 
.PP
This option enables or disables prefetch insertion optimization. The goal of prefetching is to reduce cache misses by providing hints to the processor about when data should be loaded into the cache.
.NL
.PP
On Intel(R) 64 architecture, targeting Intel(R) MIC Architecture, option opt\-prefetch=3 is enabled by default if option O2 or higher is set. To disable prefetching at these optimization levels, specify option \-no\-opt\-prefetch.
.NL
.PP
This option enables prefetching when higher optimization levels are specified.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-opt\-ra\-region\-strategy[=keyword]
.RS
.TP
Selects the method that the register allocator uses to partition each routine into regions.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.TP 18
\fIkeyword\fR
.NL
Is the method used for partitioning. Possible values are: 
.RS
.TP 15
routine
Creates a single region for each routine.
.TP 15
block
Partitions each routine into one region per basic block.
.TP 15
trace
Partitions each routine into one region per trace.
.TP 15
region
Partitions each routine into one region per loop.
.TP 15
default
The compiler determines which method is used for partitioning.
.RE
.TP
\fBDefault:\fR 
.TP 18
\-opt\-ra\-region\-strategy=default 
.NL
The compiler determines which method is used for partitioning. This is also the default if keyword is not specified.
.TP
\fBDescription:\fR 
.PP
This option selects the method that the register allocator uses to partition each routine into regions.
.NL
.PP
When setting default is in effect, the compiler attempts to optimize the tradeoff between compile\-time performance and generated code performance.
.NL
.PP
This option is only relevant when optimizations are enabled (option O1 or higher).
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-opt\-report [n]
.RS
.TP
Tells the compiler to generate an optimization report to stderr.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.TP 18
\fIn\fR
.NL
Is the level of detail in the report. On Linux OS and OS X systems, a space must appear before the \fIn\fR. Possible values are:
.RS
.TP 15
0
Tells the compiler to generate no optimization report.
.TP 15
1
Tells the compiler to generate a report with the minimum level of detail.
.TP 15
2
Tells the compiler to generate a report with the medium level of detail.
.TP 15
3
Tells the compiler to generate a report with the maximum level of detail.
.RE
.TP
\fBDefault:\fR 
.TP 18
\-opt\-report 2
.NL
If you do not specify \fIn\fR, the compiler generates a report with medium detail. If you do not specify the option on the command line, the compiler does not generate an optimization report.
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to generate an optimization report to stderr.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-opt\-report\-file=filename
.RS
.TP
Specifies the name for an optimization report.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.TP 18
\fIfilename\fR
.NL
Is the name for the optimization report.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
No optimization report is generated.
.TP
\fBDescription:\fR 
.PP
This option specifies the name for an optimization report. If you use this option, you do not have to specify \-opt\-report (Linux* OS and OS X*) or /Qopt\-report (Windows* OS).
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-opt\-report\-help
.RS
.TP
Displays the optimizer phases available for report generation. 
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
No optimization reports are generated.
.TP
\fBDescription:\fR 
.PP
This option displays the optimizer phases available for report generation using \-opt\-report\-phase (Linux* OS and OS X*) or /Qopt\-report\-phase (Windows* OS). No compilation is performed.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-opt\-report\-phase=phase
.RS
.TP
Specifies an optimizer phase to use when optimization reports are generated.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.TP 18
\fIphase\fR
.NL
Is the phase to generate reports for. Some of the possible values are:
.RS
.TP 15
offload
The phase for Intel(R) MIC Architecture. This phase has no effect if option \-no\-offload is specified. This phase only applies to Intel(R) MIC Architecture.
.TP 15
ipo
The Interprocedural Optimizer phase
.TP 15
hlo
The High Level Optimizer phase
.TP 15
hpo
The High Performance Optimizer phase
.TP 15
ilo
The Intermediate Language Scalar Optimizer phase
.TP 15
pgo
The Profile Guided Optimization phase
.TP 15
all
All optimizer phases
.RE
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
No optimization reports are generated.
.TP
\fBDescription:\fR 
.PP
This option specifies an optimizer phase to use when optimization reports are generated.
.NL
.PP
This option can be used multiple times on the same command line to generate reports for multiple optimizer phases.
.NL
.PP
When one of the logical names for optimizer phases is specified for phase, all reports from that optimizer phase are generated.
.NL
.PP
Note that phase offload causes the compiler to print a report of the input or output of variables that the host sends to the offload target and variables that the host receives from the target.
.NL
.PP
To find all phase possibilities, use option \-opt\-report\-help (Linux OS and OS X) or /Qopt\-report\-help (Windows OS).
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-opt\-report\-routine=string
.RS
.TP
Tells the compiler to generate reports on the routines containing specified text.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.TP 18
\fIstring\fR
.NL
Is the text (string) to look for.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
No optimization reports are generated.
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to generate reports on the routines containing specified text as part of their name.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-opt\-streaming\-stores keyword
.RS
.TP
Enables generation of streaming stores for optimization.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.TP 18
\fIkeyword\fR
.NL
Specifies whether streaming stores are generated. Possible values are:
.RS
.TP 15
always
Enables generation of streaming stores for optimization. The compiler optimizes under the assumption that the application is memory bound.
.TP 15
never
Disables generation of streaming stores for optimization. Normal stores are performed.
.TP 15
auto
Lets the compiler decide which instructions to use.
.RE
.TP
\fBDefault:\fR 
.TP 18
\-opt\-streaming\-stores auto 
.NL
The compiler decides whether to use streaming stores or normal stores.
.TP
\fBDescription:\fR 
.PP
This option enables generation of streaming stores for optimization. This method stores data with instructions that use a non\-temporal buffer, which minimizes memory hierarchy pollution.
.NL
.PP
This option may be useful for applications that can benefit from streaming stores.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-opt\-subscript\-in\-range
.TP
.B
\-no\-opt\-subscript\-in\-range
.RS
.TP
Determines whether the compiler assumes that there are no "large" integers being used or being computed inside loops.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-no\-opt\-subscript\-in\-range 
.NL
The compiler assumes  there are "large" integers being used or being computed within loops.
.TP
\fBDescription:\fR 
.PP
This option determines whether the compiler assumes that there are no "large" integers being used or being computed inside loops.
.NL
.PP
If you specify \-opt\-subscript\-in\-range (Linux* OS and OS X*) or /Qopt\-subscript\-in\-range (Windows* OS), the compiler assumes that there are no "large" integers being used or being computed inside loops. A "large" integer is typically > 231. This feature can enable more loop transformations.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-Os
.RS
.TP
Enables optimizations that do not increase code size and produces smaller code size than O2. 
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
Optimizations are made for code speed. However, if O1 is specified, Os is the default.
.TP
\fBDescription:\fR 
.PP
This option enables optimizations that do not increase code size and produces smaller code size than O2. It disables some optimizations that increase code size for a small speed benefit.
.NL
.PP
This option tells the compiler to favor transformations that reduce code size over transformations that produce maximum performance.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-p
.RS
.TP
Compiles and links for function profiling with gprof(1).
.NL
.TP
\fBArchitectures:\fR IA\-32, Intel(R) 64 architecture
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
Files are compiled and linked without profiling.
.TP
\fBDescription:\fR 
.PP
This option compiles and links for function profiling with gprof(1).
.NL
.PP
When you specify this option, inlining is disabled. However, you can override this by specifying pragma forceinline, declspec forceinline (Windows* OS), attribute always_inline (Linux* OS and OS X*), or a compiler option such as \-inline\-forceinline (Linux OS and OS X) or /Qinline\-forceinline (Windows OS).
.NL
.TP
\fBAlternate Options:\fR 
.PP
Linux and OS X: \-qp (this is a \fIdeprecated\fR option)
.NL
.RE
.TP
.B
\-P
.RS
.TP
Tells the compiler to stop the compilation process and write the results to a file. 
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
Normal compilation is performed.
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to stop the compilation process after C or C++ source files have been preprocessed and write the results to files named according to the compiler\[aq]s default file\-naming conventions.
.NL
.PP
On Linux systems, this option causes the preprocessor to expand your source module and direct the output to a .i file instead of stdout. Unlike the \-E option, the output from \-P on Linux does not include #line number directives. By default, the preprocessor creates the name of the output file using the prefix of the source file name with a .i extension. You can change this by using the \-o option. 
.NL
.TP
\fBAlternate Options:\fR 
.PP
\-F
.NL
.RE
.TP
.B
\-parallel
.RS
.TP
Tells the auto\-parallelizer to generate multithreaded code for loops that can be safely executed in parallel.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
Multithreaded code is not generated for loops that can be safely executed in parallel.
.TP
\fBDescription:\fR 
.PP
This option tells the auto\-parallelizer to generate multithreaded code for loops that can be safely executed in parallel. 
.NL
.PP
To use this option, you must also specify option O2 or O3.
.NL
.PP
On Linux* and Windows* systems, this option sets option \-opt\-matmul
(Linux* OS) or /Qopt\-matmul (Windows* OS) if option O3 is also
specified.
.NL
.PP
.B NOTE:
On OS X* systems, when you enable automatic parallelization, you must also set the DYLD_LIBRARY_PATH environment variable within Xcode* or an error will be displayed.
.PP
.B NOTE:
Using this option enables parallelization for both Intel(R) microprocessors and non\-Intel microprocessors.  The resulting executable may get additional performance gain on Intel microprocessors than on non\-Intel
microprocessors. The parallelization can also be affected by certain options, such as /arch or /Qx (Windows OS) or \-m or \-x (Linux OS and OS X).
.PP
.TP 18
\fBOptimization Notice 
\fR
.NL
.NL
.TP 18
= = = = = = = = = = 
.TP 18
Intel\[aq]s compilers may or may not optimize to the same degree for non\-Intel microprocessors for optimizations that are not unique to Intel microprocessors. These optimizations include SSE2, SSE3, and SSSE3 instruction sets and other optimizations. Intel does not guarantee the availability, functionality, or effectiveness of any optimization on microprocessors not manufactured by Intel. Microprocessor\-dependent optimizations in this product are intended for use with Intel microprocessors. Certain optimizations not specific to Intel microarchitecture are reserved for Intel microprocessors. Please refer to the applicable product User and Reference Guides for more information regarding the specific instruction sets covered by this notice. 
.TP 18
Notice revision #20110804 
.TP 18
= = = = = = = = = = 
.NL
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-parallel\-source\-info[=n]
.TP
.B
\-no\-parallel\-source\-info
.RS
.TP
Enables or disables source location emission when OpenMP* or auto\-parallelism code is generated.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.TP 18
\fIn\fR
.NL
Is the level of source location emission. Possible values are:
.RS
.TP 15
0
Disables the emission of source location information when OpenMP or auto\-parallelism code is generated. This is the same as specifying \-no\-parallel\-source\-info (Linux* OS and OS X*) or /Qparallel\-source\-info\- (Windows* OS).
.TP 15
1
Tells the compiler to emit routine name and line information. This is the same as specifying \-parallel\-source\-info (Linux* OS and OS X*) or /Qparallel\-source\-info (Windows* OS) with no keyword.
.TP 15
2
Tells the compiler to emit path, file, routine name, and line information.
.RE
.TP
\fBDefault:\fR 
.TP 18
\-parallel\-source\-info=1 
.NL
When OpenMP* or auto\-parallelism code is generated, the routine name and line information is emitted.
.TP
\fBDescription:\fR 
.PP
This option enables or disables source location emission when OpenMP or auto\-parallelism code is generated.  It also lets you set the level of emission.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-par\-affinity=[modifier,...]type[,permute][,offset] (L*X only)
.RS
.TP
Specifies thread affinity.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.TP 18
\fImodifier\fR
.NL
Is one of the following values:
granularity={fine|thread|core}, [no]respect, [no]verbose, [no]warnings, proclist=proc_list.
The default is granularity=core, respect, and noverbose. For information on value proclist, see Thread Affinity Interface in OpenMP* Support.
.TP 18
\fItype\fR
.NL
Indicates the thread affinity. This argument is required and must be one of the following values: 
compact, disabled, explicit, none, scatter, logical, physical.  The default is none.
Values logical and physical are deprecated. Use compact and scatter, respectively, with no \fIpermute\fR value.
.TP 18
\fIpermute\fR
.NL
Is a positive integer. You cannot use this argument with \fItype\fR setting explicit, none, or disabled. The default is 0.
.TP 18
\fIoffset\fR
.NL
Is a positive integer. You cannot use this argument with \fItype\fR setting explicit, none, or disabled. The default is 0.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The thread affinity is determined by the run\-time environment.
.TP
\fBDescription:\fR 
.PP
This option specifies thread affinity, which binds threads to physical processing units. It has the same effect as environment variable KMP_AFFINITY.
.NL
.PP
This option overrides the environment variable when both are specified. 
.NL
.PP
This option only has an effect if the following is true:
.NL
.IP \(bu 2
Linux* OS: You have specified option \-parallel or \-openmp (or both).
Windows* OS: You have specified option /Qparallel or /Qopenmp (or
both).
.IP \(bu 2
You are compiling the main program.
.PP
.B NOTE:
This option may behave differently on Intel(R) microprocessors than on non\-Intel microprocessors.
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-par\-num\-threads=n
.RS
.TP
Specifies the number of threads to use in a parallel region.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.TP 18
\fIn\fR
.NL
Is the number of threads to use. It must be a positive integer.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The number of threads to use is determined by the run\-time environment.
.TP
\fBDescription:\fR 
.PP
This option specifies the number of threads to
use in a parallel region. It has the same effect as environment
variable OMP_NUM_THREADS.
.NL
.PP
This option overrides the environment variable
when both are specified.
.NL
.PP
This option only has an effect if the following
is true:
.NL
.IP \(bu 2
Linux* OS and OS X*: You have specified option \-parallel or \-openmp (or both).
Windows* OS: You have specified option /Qparallel or /Qopenmp (or
both).
.IP \(bu 2
You are compiling the
main program.
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-par\-report[n]
.RS
.TP
Controls the diagnostic information reported by the auto\-parallelizer.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.TP 18
\fIn\fR
.NL
Is a value denoting which diagnostic messages to report. Possible values are:
.RS
.TP 15
0
Tells the auto\-parallelizer to report no diagnostic information.
.TP 15
1
Tells the auto\-parallelizer to report diagnostic messages for loops successfully auto\-parallelized. The compiler also issues a "LOOP AUTO\-PARALLELIZED" message for parallel loops.
.TP 15
2
Tells the auto\-parallelizer to report diagnostic messages for loops successfully and unsuccessfully auto\-parallelized.
.TP 15
3
Tells the auto\-parallelizer to report the same diagnostic messages specified by 2 plus additional information about any proven or assumed dependencies inhibiting auto\-parallelization (reasons for not parallelizing).
.RE
.TP
\fBDefault:\fR 
.TP 18
\-par\-report1 
.NL
If you do not specify \fIn\fR, the compiler displays diagnostic messages for loops successfully auto\-parallelized. If you do not specify the option on the command line, the default is to display no messages.
.TP
\fBDescription:\fR 
.PP
This option controls the diagnostic information reported by the auto\-parallelizer (parallel optimizer). To use this option, you must also specify \-parallel (Linux* OS and OS X*) or /Qparallel (Windows* OS).
.NL
.PP
If this option is specified on the command line, the report is sent to stdout.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-par\-runtime\-control[n]
.TP
.B
\-no\-par\-runtime\-control
.RS
.TP
Generates code to perform run\-time checks for loops that have symbolic loop bounds.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.TP 18
\fIn\fR
.NL
Is a  a value denoting what kind of runtime checking to perform. Possible values are:
.RS
.TP 15
0
Performs no runtime check based on auto\-parallelization. This is the same as specifying \-no\-par\-runtime\-control (Linux* OS and OS X*) or /Qpar\-runtime\-control\- (Windows* OS).
.TP 15
1
Generates runtime check code under conservative mode. This is the default if you do not specify \fIn\fR.
.TP 15
2
Generates runtime check code under heuristic mode.
.TP 15
3
Generates runtime check code under aggressive mode.
.RE
.TP
\fBDefault:\fR 
.TP 18
\-no\-par\-runtime\-control 
.NL
The compiler uses default heuristics when checking loops.
.TP
\fBDescription:\fR 
.PP
This option generates code to perform run\-time checks for loops that have symbolic loop bounds. 
.NL
.PP
If the granularity of a loop is greater than the parallelization threshold, the loop will be executed in parallel.
.NL
.PP
If you do not specify this option, the compiler may not parallelize loops with symbolic loop bounds if the compile\-time granularity estimation of a loop can not ensure it is beneficial to parallelize the loop.
.NL
.PP
.B NOTE:
This option may behave differently on Intel(R) microprocessors than on non\-Intel microprocessors.
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-par\-schedule\-keyword[=n]
.RS
.TP
Lets you specify a scheduling algorithm for loop iterations. 
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.TP 18
\fIkeyword\fR
.NL
Specifies the scheduling algorithm or tuning method. Possible values are:
.RS
.TP 15
auto
Lets the compiler or run\-time system determine the scheduling algorithm.
.TP 15
static
Divides iterations into contiguous pieces.
.TP 15
static\-balanced
Divides iterations into even\-sized chunks.
.TP 15
static\-steal
Divides iterations into even\-sized chunks, but allows threads to steal parts of chunks
from neighboring threads. 
.TP 15
dynamic
Gets a set of iterations dynamically.
.TP 15
guided
Specifies a minimum number of iterations.
.TP 15
guided\-analytical
Divides iterations by using exponential distribution or dynamic distribution. 
.TP 15
runtime
Defers the scheduling decision until run time.
.RE
.TP 18
\fIn\fR
.NL
Is the size of the chunk or the number of iterations for each chunk. This setting
can only be specified for static, dynamic, and guided. For more information, see
the descriptions of each keyword below. 
.TP
\fBDefault:\fR 
.TP 18
static\-balanced
.NL
Iterations are divided into even\-sized chunks and the chunks are assigned to the
threads in the team in a round\-robin fashion in the order of the thread number.
.TP
\fBDescription:\fR 
.PP
This option lets you specify a scheduling algorithm for loop iterations.
It specifies how iterations are to be divided among the threads of the team. 
.NL
.PP
This option is only useful when specified with option \-parallel (Linux* OS and OS X*) or /Qparallel (Windows* OS).
.NL
.PP
This option affects performance tuning and can provide better performance during
auto\-parallelization. It does nothing if it is used with option \-openmp (Linux* OS and OS X*) or option /Qopenmp (Windows* OS).
.NL
.TP 18
\fBOption\fR
.NL
.NL
\fBDescription\fR
.NL
.NL
.TP 18
\-par\-schedule\-auto or /Qpar\-schedule\-auto
.NL
Lets the compiler or run\-time system determine the scheduling algorithm. Any possible
mapping may occur for iterations to threads in the team.
.NL
.TP 18
\-par\-schedule\-static or /Qpar\-schedule\-static
.NL
Divides iterations into contiguous pieces (chunks) of size \fIn\fR. The chunks are assigned
to threads in the team in a round\-robin fashion in the order of the thread number.
Note that the last chunk to be assigned may have a smaller number of iterations.
.TP 18
If no \fIn\fR is specified, the iteration space is divided into chunks that are approximately
equal in size, and each thread is assigned at most one chunk.
.NL
.TP 18
\-par\-schedule\-static\-balanced or /Qpar\-schedule\-static\-balanced
.NL
Divides iterations into even\-sized chunks. The chunks are assigned to the threads
in the team in a round\-robin fashion in the order of the thread number. 
.NL
.TP 18
\-par\-schedule\-static\-steal or /Qpar\-schedule\-static\-steal
.NL
Divides iterations into even\-sized chunks, but when a thread completes its chunk,
it can steal parts of chunks assigned to neighboring threads. 
.TP 18
Each thread keeps track
of L and U, which represent the lower and upper bounds of its chunks respectively.
Iterations are executed starting from the lower bound, and simultaneously, L is updated
to represent the new lower bound.
.NL
.TP 18
\-par\-schedule\-dynamic or /Qpar\-schedule\-dynamic
.NL
Can be used to get a set of iterations dynamically. Assigns iterations to threads
in chunks as the threads request them. The thread executes the chunk of iterations,
then requests another chunk, until no chunks remain to be assigned.
.TP 18
As each thread finishes a piece of the iteration space, it dynamically gets the next
set of iterations. Each chunk contains \fIn\fR iterations, except for the last chunk to
be assigned, which may have fewer iterations. If no \fIn\fR is specified, the default is
1.
.NL
.TP 18
\-par\-schedule\-guided or /Qpar\-schedule\-guided
.NL
Can be used to specify a minimum number of iterations. Assigns iterations to threads
in chunks as the threads request them. The thread executes the chunk of iterations,
then requests another chunk, until no chunks remain to be assigned. 
.TP 18
For a chunk of size 1, the size of each chunk is proportional to the number of unassigned
iterations divided by the number of threads, decreasing to 1.
.TP 18
For an \fIn\fR with value
\fIk\fR (greater than 1), the size of each chunk is determined in the same way with the
restriction that the chunks do not contain fewer than \fIk\fR iterations (except for the
last chunk to be assigned, which may have fewer than \fIk\fR iterations). If no \fIn\fR is specified,
the default is 1.
.NL
.TP 18
\-par\-schedule\-guided\-analytical or /Qpar\-schedule\-guided\-analytical
.NL
Divides iterations by using exponential distribution or dynamic distribution. The
method depends on run\-time implementation. Loop bounds are calculated with faster
synchronization and chunks are dynamically dispatched at run time by threads in the
team.
.NL
.TP 18
\-par\-schedule\-runtime or /Qpar\-schedule\-runtime
.NL
Defers the scheduling decision until run time. The scheduling algorithm and chunk
size are then taken from the setting of environment variable OMP_SCHEDULE.
.NL
.PP
.B NOTE:
This option may behave differently on Intel(R) microprocessors than on non\-Intel microprocessors.
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-par\-threshold[n]
.RS
.TP
Sets a threshold for the auto\-parallelization of loops. 
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.TP 18
\fIn\fR
.NL
Is an integer whose value is the threshold for the auto\-parallelization of loops. Possible values are 0 through 100.
.IP
If \fIn\fR is 0, loops get auto\-parallelized always, regardless of computation work volume.
.IP
If \fIn\fR is 100, loops get auto\-parallelized when performance gains are predicted based on the compiler analysis data. Loops get auto\-parallelized only if profitable parallel execution is almost certain.
.IP
The intermediate 1 to 99 values represent the percentage probability for profitable speed\-up. For example, \fIn\fR=50 directs the compiler to parallelize only if there is a 50% probability of the code speeding up if executed in parallel.
.TP
\fBDefault:\fR 
.TP 18
\-par\-threshold100 
.NL
Loops get auto\-parallelized only if profitable parallel execution is almost certain. This is also the default if you do not specify \fIn\fR.
.TP
\fBDescription:\fR 
.PP
This option sets a threshold for the auto\-parallelization of loops based on the probability of profitable execution of the loop in parallel. To use this option, you must also specify \-parallel (Linux* OS and OS X*) or /Qparallel (Windows* OS).
.NL
.PP
This option is useful for loops whose computation work volume cannot be determined at compile\-time. The threshold is usually relevant when the loop trip count is unknown at compile\-time. 
.NL
.PP
The compiler applies a heuristic that tries to balance the overhead of creating multiple threads versus the amount of work available to be shared amongst the threads.
.NL
.PP
.B NOTE:
This option may behave differently on Intel(R) microprocessors than on non\-Intel microprocessors.
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-pcn
.RS
.TP
Enables control of floating\-point significand precision.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.TP 18
\fIn\fR
.NL
Is the floating\-point significand precision. Possible values are:
.RS
.TP 15
32
Rounds the significand to 24 bits (single precision).
.TP 15
64
Rounds the significand to 53 bits (double precision).
.TP 15
80
Rounds the significand to 64 bits (extended precision).
.RE
.TP
\fBDefault:\fR 
.TP 18
\-pc80 
.NL
On Linux* and OS X* systems, the floating\-point significand is rounded to 64 bits. 
.TP
\fBDescription:\fR 
.PP
This option enables control of floating\-point significand precision.
.NL
.PP
Some floating\-point algorithms are sensitive to the accuracy of the significand, or fractional part of the floating\-point value. For example, iterative operations like division and finding the square root can run faster if you lower the precision with the this option.
.NL
.PP
Note that a change of the default precision control or rounding mode, for example, by using the \-pc32 (Linux OS and OS X) or /Qpc32 (Windows OS) option or by user intervention, may affect the results returned by some of the mathematical functions.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-pch
.RS
.TP
Tells the compiler to use appropriate precompiled header files. 
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler does not create or use precompiled headers unless you tell it to do so.
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to use appropriate precompiled header (PCH) files. If none are available, they are created as sourcefile.pchi. This option is supported for multiple source files.
.NL
.PP
The \-pch option will use PCH files created from other sources if the headers files are the same. For example, if you compile source1.cpp using \-pch, then source1.pchi is created. If you then compile source2.cpp using \-pch, the compiler will use source1.pchi if it detects the same headers.
.NL
.PP
.B CAUTION:
Depending on how you organize the header files listed in your sources, this option may increase compile times. To learn how to optimize compile times using the PCH options, see "Using Precompiled Header Files" in the User\[aq]s Guide.
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-pch\-create filename
.RS
.TP
Tells the compiler to create a precompiled header file. 
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.TP 18
\fIfilename\fR
.NL
Is the name for the precompiled header file. A space must appear before the file name. It can include a path.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler does not create or use precompiled headers unless you tell it to do so.
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to create a precompiled header (PCH) file. It is supported only for single source file compilations.
.NL
.PP
Note that the .pchi extension is not automatically appended to the file name. 
.NL
.PP
This option cannot be used in the same compilation as the \-pch\-use option.
.NL
.TP
\fBAlternate Options:\fR 
.PP
Linux and OS X: None
.NL
.PP
Windows: /Yc
.NL
.RE
.TP
.B
\-pch\-dir dir
.RS
.TP
Tells the compiler the location for precompiled header files.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.TP 18
\fIdir\fR
.NL
Is the path for precompiled header files. The path must exist.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler does not create or use precompiled headers unless you tell it to do so.
.TP
\fBDescription:\fR 
.PP
This option tells the compiler the location for precompiled header files.  It denotes where to find precompiled header files, and where new PCH files should be placed.
.NL
.PP
This option can be used with the \-pch, \-pch\-create, and \-pch\-use options.
.NL
.PP
To learn how to optimize compile times using the PCH options, see "Using Precompiled Header Files" in the User\[aq]s Guide.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-pch\-use filename
.RS
.TP
Tells the compiler to use a precompiled header file. 
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.TP 18
\fIfilename\fR
.NL
Is the name of the precompiled header file to use. A space must appear before the file name. It can include a path.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler does not create or use precompiled headers unless you tell it to do so.
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to use a precompiled header (PCH) file. 
.NL
.PP
It is supported for multiple source files when all source files use the same .pchi file.
.NL
.PP
This option cannot be used in the same compilation as the \-pch\-create option.
.NL
.PP
To learn how to optimize compile times using the PCH options, see "Using Precompiled Header Files" in the User\[aq]s Guide.
.NL
.TP
\fBAlternate Options:\fR 
.PP
Linux and OS X: None
.NL
.PP
Windows: /Yu
.NL
.RE
.TP
.B
\-pie (L*X only)
.RS
.TP
Produces a position\-independent executable on processors that support it. 
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The driver does not set up special run\-time libraries and the linker does not perform the optimizations on executables.
.TP
\fBDescription:\fR 
.PP
This option produces a position\-independent executable on processors that support it. It is both a compiler option and a linker option. When used as a compiler option, this option ensures the linker sets up run\-time libraries correctly.
.NL
.PP
Normally the object linked has been compiled with option \-fpie.
.NL
.PP
When you specify \-pie, it is recommended that you specify the same options that were used during compilation of the object.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-pragma\-optimization\-level=interpretation
.RS
.TP
Specifies which interpretation of the optimization_level pragma should be used if no prefix is specified.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.TP 18
\fIinterpretation\fR
.NL
Compiler\-specific interpretation of optimization_level pragma. Possible values are:
.RS
.TP 15
Intel
Specify the Intel interpretation.
.TP 15
GCC
Specify the GCC interpretation.
.RE
.TP
\fBDefault:\fR 
.TP 18
\-pragma\-optimization\-level=Intel
.NL
Use the Intel interpretation of the optimization_level pragma.
.TP
\fBDescription:\fR 
.PP
Specifies which interpretation of the optimization_level pragma should be used if no prefix is specified.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-prec\-div
.TP
.B
\-no\-prec\-div
.RS
.TP
Improves precision of floating\-point divides.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-prec\-div 
.NL
The compiler uses this method for floating\-point divides.
.TP
\fBDescription:\fR 
.PP
This option improves precision of floating\-point divides. It has a slight impact on speed.
.NL
.PP
With some optimizations, such as \-msse2 (Linux* OS) or /arch:SSE2 (Windows* OS), the compiler may change floating\-point division computations into multiplication by the reciprocal of the denominator. For example, A/B is computed as A * (1/B) to improve the speed of the computation.
.NL
.PP
However, sometimes the value produced by this transformation is not as accurate as full IEEE division. When it is important to have fully precise IEEE division, use this option to disable the floating\-point division\-to\-multiplication optimization. The result is more accurate, with some loss of performance.
.NL
.PP
If you specify \-no\-prec\-div (Linux* OS and OS X*) or /Qprec\-div\- (Windows* OS), it enables optimizations that give slightly less precise results than full IEEE division.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-prec\-sqrt
.TP
.B
\-no\-prec\-sqrt
.RS
.TP
Improves precision of square root implementations.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-no\-prec\-sqrt 
.NL
The compiler uses a faster but less precise implementation of square root.
.IP
However, the default is \-prec\-sqrt if any of the following options are specified: \-O0  or \-mp1 on Linux* and OS X* systems. 
.TP
\fBDescription:\fR 
.PP
This option improves precision of square root implementations. It has a slight impact on speed. 
.NL
.PP
This option inhibits any optimizations that can adversely affect the precision of a square root computation. The result is fully precise square root implementations, with some loss of performance.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-print\-multi\-lib
.RS
.TP
Prints information about where system libraries should be found.
.NL
.TP
\fBArchitectures:\fR IA\-32, Intel(R) 64 architecture
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
No information is printed unless the option is specified.
.TP
\fBDescription:\fR 
.PP
This option prints information about where system libraries should be found, but no compilation occurs. It is provided for compatibility with gcc.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-prof\-data\-order (L*X only)
.TP
.B
\-no\-prof\-data\-order (L*X only)
.RS
.TP
Enables or disables data ordering if profiling information is enabled.
.NL
.TP
\fBArchitectures:\fR IA\-32, Intel(R) 64 architecture
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-no\-prof\-data\-order 
.NL
Data ordering is disabled.
.TP
\fBDescription:\fR 
.PP
This option enables or disables data ordering if profiling information is enabled. It controls the use of profiling information to order static program data items. 
.NL
.PP
For this option to be effective, you must do the following:
.NL
.IP \(bu 2
For instrumentation compilation, you must specify \-prof\-gen=globdata (Linux* OS) or /Qprof\-gen:globdata (Windows* OS). 
.IP \(bu 2
For feedback compilation, you must specify \-prof\-use (Linux OS) or /Qprof\-use (Windows OS). You must not use multi\-file optimization by specifying options such as option \-ipo (Linux OS) or /Qipo (Windows OS), or option \-ipo\-c (Linux OS) or /Qipo\-c (Windows OS). 
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-prof\-dir dir
.RS
.TP
Specifies a directory for profiling information output files.
.NL
.TP
\fBArchitectures:\fR IA\-32, Intel(R) 64 architecture
.TP
\fBArguments:\fR 
.TP 18
\fIdir\fR
.NL
Is the name of the directory.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
Profiling output files are placed in the directory where the program is compiled.
.TP
\fBDescription:\fR 
.PP
This option specifies a directory for profiling information output files (*.dyn and *.dpi). The specified directory must already exist.
.NL
.PP
You should specify this option using the same directory name for both instrumentation and feedback compilations. If you move the .dyn files, you need to specify the new path.
.NL
.PP
Option /Qprof\-dir is equivalent to option /Qcov\-dir. If you specify both options, the last option specified on the command line takes precedence.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-prof\-file filename
.RS
.TP
Specifies an alternate file name for the profiling summary files.
.NL
.TP
\fBArchitectures:\fR IA\-32, Intel(R) 64 architecture
.TP
\fBArguments:\fR 
.TP 18
\fIfilename\fR
.NL
Is the name of the profiling summary file.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The profiling summary files have the file name pgopti.*
.TP
\fBDescription:\fR 
.PP
This option specifies an alternate file name for the profiling summary files. The \fIfilename\fR is used as the base name for files created by different profiling passes.
.NL
.PP
If you add this option to profmerge, the .dpi file will be named \fIfilename\fR.dpi instead of pgopti.dpi.
.NL
.PP
If you specify this option with option \-prof\-use (Linux* OS and OS X*) or /Qprof\-use (Windows* OS), the .dpi file will be named \fIfilename\fR.dpi instead of pgopti.dpi.
.NL
.PP
Option /Qprof\-file is equivalent to option /Qcov\-file. If you specify both options, the last option specified on the command line takes precedence.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-prof\-func\-groups (L*X only)
.TP
.B
\-no\-prof\-func\-groups (L*X only)
.RS
.TP
Enables or disables function grouping if profiling information is enabled.
.NL
.TP
\fBArchitectures:\fR IA\-32, Intel(R) 64 architecture
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-no\-prof\-func\-groups
.NL
Function grouping is disabled. 
.TP
\fBDescription:\fR 
.PP
This option enables or disables function grouping if profiling information is enabled.
.NL
.PP
A "function grouping" is a profiling optimization in which entire routines are placed either in the cold code section or the hot code section.
.NL
.PP
If profiling information is enabled by option \-prof\-use, option \-prof\-func\-groups is set and function grouping is enabled. However, if you explicitly enable \-prof\-func\-order (Linux* OS) or /Qprof\-func\-order (Windows* OS), function ordering is performed instead of function grouping.
.NL
.PP
If you want to disable function grouping when profiling information is enabled, specify \-no\-prof\-func\-groups.
.NL
.PP
To set the hotness threshold for function grouping, use option \-prof\-hotness\-threshold (Linux OS) or /Qprof\-hotness\-threshold (Windows OS).
.NL
.RE
.TP
.B
\-prof\-func\-order (L*X only)
.TP
.B
\-no\-prof\-func\-order (L*X only)
.RS
.TP
Enables or disables function ordering if profiling information is enabled.
.NL
.TP
\fBArchitectures:\fR IA\-32, Intel(R) 64 architecture
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-no\-prof\-func\-order 
.NL
Function ordering is disabled.
.TP
\fBDescription:\fR 
.PP
This option enables or disables function ordering if profiling information is enabled.
.NL
.PP
For this option to be effective, you must do the following:
.NL
.IP \(bu 2
For instrumentation compilation, you must specify \-prof\-gen=srcpos (Linux* OS) or /Qprof\-gen:srcpos (Windows* OS). 
.IP \(bu 2
For feedback compilation, you must specify \-prof\-use (Linux OS) or /Qprof\-use (Windows OS). You must not use multi\-file optimization by specifying options such as option \-ipo (Linux OS) or /Qipo (Windows OS), or option \-ipo\-c (Linux OS) or /Qipo\-c (Windows OS). 
.PP
If you enable profiling information by specifying option \-prof\-use (Linux OS) or /Qprof\-use (Windows OS), \-prof\-func\-groups (Linux OS) and /Qprof\-func\-groups (Windows OS) are set and function grouping is enabled.   However, if you explicitly enable \-prof\-func\-order (Linux OS) or /Qprof\-func\-order (Windows OS), function ordering is performed instead of function grouping.
.NL
.PP
On Linux* systems, this option is only available for Linux linker 2.15.94.0.1, or later.
.NL
.PP
To set the hotness threshold for function grouping and function ordering, use option \-prof\-hotness\-threshold (Linux OS) or /Qprof\-hotness\-threshold (Windows OS).
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-prof\-gen[=keyword]
.TP
.B
\-no\-prof\-gen
.RS
.TP
Produces an instrumented object file that can be used in profile guided optimization.
.NL
.TP
\fBArchitectures:\fR IA\-32, Intel(R) 64 architecture
.TP
\fBArguments:\fR 
.TP 18
\fIkeyword\fR
.NL
Specifies details for the instrumented file. Possible values are:
.RS
.TP 15
default
Produces an instrumented object file. This is the same as specifying \-prof\-gen (Linux*OS and OS X*) or /Qprof\-gen (Windows* OS) with no keyword.
.TP 15
srcpos
Produces an instrumented object file that includes extra source position information. 
.TP 15
globdata
Produces an instrumented object file that includes information for global data layout.
.RE
.TP
\fBDefault:\fR 
.TP 18
\-no\-prof\-gen
.NL
Profile generation is disabled.
.TP
\fBDescription:\fR 
.PP
This option produces an instrumented object file that can be used in profile guided optimization. It gets the execution count of each basic block.
.NL
.PP
If you specify keyword srcpos or globdata, a static profile information file (.spi) is created. These settings may increase the time needed to do a parallel build using \-prof\-gen, because of contention writing the .spi file.
.NL
.PP
These options are used in phase 1 of the Profile Guided Optimizer (PGO) to instruct the compiler to produce instrumented code in your object files in preparation for instrumented execution.
.NL
.PP
When option \-prof\-gen (Linux* OS and OS X*)
or /Qprof\-gen (Windows* OS) is used to produce an instrumented
binary file for profile generation, some optimizations are
disabled.  Those optimizations are not disabled for any
subsequent profile\-guided compilation with option \-prof\-use (Linux*
OS and OS X*) or /Qprof\-use (Windows* OS) that makes use of the
generated profiles.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-prof\-hotness\-threshold=n (L*X only)
.RS
.TP
Lets you set the hotness threshold for function grouping and function ordering. 
.NL
.TP
\fBArchitectures:\fR IA\-32, Intel(R) 64 architecture
.TP
\fBArguments:\fR 
.TP 18
\fIn\fR
.NL
Is the hotness threshold. \fIn\fR is a percentage having a value between 0 and 100 inclusive. If you specify 0, there will be no hotness threshold setting in effect for function grouping and function ordering.  
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler\[aq]s default hotness threshold setting of 10 percent is in effect for function grouping and function ordering.  
.TP
\fBDescription:\fR 
.PP
This option lets you set the hotness threshold for function grouping and function ordering.
.NL
.PP
The "hotness threshold" is the percentage of functions in the application that should be placed in the application\[aq]s hot region.  The hot region is the most frequently executed part of the application.  By grouping these functions together into one hot region, they have a greater probability of remaining resident in the instruction cache. This can enhance the application\[aq]s performance.
.NL
.PP
For this option to take effect, you must specify option  \-prof\-use (Linux* OS) or  /Qprof\-use (Windows* OS) and one of the following:
.NL
.IP \(bu 2
On Linux systems: \-prof\-func\-groups or \-prof\-func\-order
.IP \(bu 2
On Windows systems: /Qprof\-func\-order
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-prof\-src\-dir
.TP
.B
\-no\-prof\-src\-dir
.RS
.TP
Determines whether directory information of the source file under compilation is considered when looking up profile data records.
.NL
.TP
\fBArchitectures:\fR IA\-32, Intel(R) 64 architecture
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-prof\-src\-dir 
.NL
Directory information is used when looking up profile data records in the .dpi file.
.TP
\fBDescription:\fR 
.PP
This option determines whether directory information of the source file under compilation is considered when looking up profile data records in the .dpi file. To use this option, you must also specify option \-prof\-use (Linux* OS and OS X*) or /Qprof\-use (Windows* OS). 
.NL
.PP
If the option is enabled, directory information is considered when looking up the profile data records within the .dpi file. You can specify directory information by using one of the following options:
.NL
.IP \(bu 2
Linux and OS X:  \-prof\-src\-root or  \-prof\-src\-root\-cwd
.IP \(bu 2
Windows:  /Qprof\-src\-root or /Qprof\-src\-root\-cwd
.PP
If the option is disabled, directory information is ignored and only the name of the file is used to find the profile data record.
.NL
.PP
Note that options \-prof\-src\-dir (Linux OS and OS X) and /Qprof\-src\-dir (Windows OS) control how the names of the user\[aq]s source files get represented within the .dyn or .dpi files.  Options \-prof\-dir (Linux OS and OS X) and /Qprof\-dir (Windows OS) specify the location of the .dyn or the .dpi files.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-prof\-src\-root=dir
.RS
.TP
Lets you use relative directory paths when looking up profile data and specifies a directory as the base.
.NL
.TP
\fBArchitectures:\fR IA\-32, Intel(R) 64 architecture
.TP
\fBArguments:\fR 
.TP 18
\fIdir\fR
.NL
Is the base for the relative paths.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The setting of relevant options determines the path used when looking up profile data records.
.TP
\fBDescription:\fR 
.PP
This option lets you use relative directory paths when looking up profile data in .dpi files. It lets you specify a directory as the base. The paths are relative to a base directory specified during the \-prof\-gen (Linux* OS and OS X*) or /Qprof\-gen (Windows* OS) compilation phase. 
.NL
.PP
This option is available during the following phases of compilation:
.NL
.IP \(bu 2
Linux OS and OS X: \-prof\-gen and \-prof\-use phases
.IP \(bu 2
Windows OS: /Qprof\-gen and /Qprof\-use phases
.PP
When this option is specified during the \-prof\-gen or /Qprof\-gen phase, it stores information into the .dyn or .dpi file. Then, when .dyn files are merged together or the .dpi file is loaded, only the directory information below the root directory is used for forming the lookup key. 
.NL
.PP
When this option is specified during the \-prof\-use or /Qprof\-use phase, it specifies a root directory that replaces the root directory specified at the \-prof\-gen or /Qprof\-gen phase for forming the lookup keys.
.NL
.PP
To be effective, this option or option \-prof\-src\-root\-cwd (Linux* OS and OS X*) or /Qprof\-src\-root\-cwd (Windows* OS) must be specified during the \-prof\-gen or /Qprof\-gen phase. In addition, if one of these options is not specified, absolute paths are used in the .dpi file.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-prof\-src\-root\-cwd
.RS
.TP
Lets you use relative directory paths when looking up profile data and specifies the current working directory as the base.
.NL
.TP
\fBArchitectures:\fR IA\-32, Intel(R) 64 architecture
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The setting of relevant options determines the path used when looking up profile data records.
.TP
\fBDescription:\fR 
.PP
This option lets you use relative directory paths when looking up profile data in .dpi files. It specifies the current working directory as the base. To use this option, you must also specify option \-prof\-use (Linux* OS and OS X*) or /Qprof\-use (Windows* OS). 
.NL
.PP
This option is available during the following phases of compilation:
.NL
.IP \(bu 2
Linux OS and OS X: \-prof\-gen and \-prof\-use phases
.IP \(bu 2
Windows OS: /Qprof\-gen and /Qprof\-use phases
.PP
When this option is specified during the \-prof\-gen or /Qprof\-gen phase, it stores information into the .dyn or .dpi file. Then, when .dyn files are merged together or the .dpi file is loaded, only the directory information below the root directory is used for forming the lookup key. 
.NL
.PP
When this option is specified during the \-prof\-use or /Qprof\-use phase, it specifies a root directory that replaces the root directory specified at the \-prof\-gen or /Qprof\-gen phase for forming the lookup keys.
.NL
.PP
To be effective, this option or option \-prof\-src\-root (Linux* OS and OS X*) or /Qprof\-src\-root (Windows* OS) must be specified during the \-prof\-gen or /Qprof\-gen phase. In addition, if one of these options is not specified, absolute paths are used in the .dpi file.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-prof\-use[=keyword]
.TP
.B
\-no\-prof\-use
.RS
.TP
Enables the use of profiling information during optimization.
.NL
.TP
\fBArchitectures:\fR IA\-32, Intel(R) 64 architecture
.TP
\fBArguments:\fR 
.TP 18
\fIkeyword\fR
.NL
Specifies additional instructions. Possible values are:
.RS
.TP 15
weighted
Tells the profmerge utility to apply a weighting to the .dyn file values when creating the .dpi file to normalize the data counts when the training runs have differentexecution durations.  This argument only has an effect when the compiler invokes the profmerge utility to create the .dpi file. This argument does not have an effect if the .dpi file was previously created without weighting.
.TP 15
[no]merge
Enables or disables automatic invocation of the profmerge utility. The default is merge. Note that you cannot specify both weighted and nomerge.  If you try to specify both values, a warning will be displayed and nomerge takes precedence.
.TP 15
default
Enables the use of profiling information during optimization. The profmerge utility is invoked by default. This value is the same as specifying \-prof\-use (Linux* OS and OS X*) or /Qprof\-use (Windows* OS) with no argument.
.RE
.TP
\fBDefault:\fR 
.TP 18
\-no\-prof\-use
.NL
Profiling information is not used during optimization.
.TP
\fBDescription:\fR 
.PP
This option enables the use of profiling information (including function splitting and function grouping) during optimization. It enables option /Qfnsplit (Windows* OS).
.NL
.PP
This option instructs the compiler to produce a profile\-optimized executable and it merges available profiling output files into a pgopti.dpi file.
.NL
.PP
Note that there is no way to turn off function grouping if you enable it using this option.
.NL
.PP
To set the hotness threshold for function grouping and function ordering, use option \-prof\-hotness\-threshold (Linux OS) or /Qprof\-hotness\-threshold (Windows OS).
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-prof\-value\-profiling[=keyword]
.RS
.TP
Controls which values are value profiled.
.NL
.TP
\fBArchitectures:\fR IA\-32, Intel(R) 64 architecture
.TP
\fBArguments:\fR 
.TP 18
keyword
.NL
Controls which type of value profiling is performed. Possible values are:
.RS
.TP 15
none
Prevents all types of value profiling.
.TP 15
nodivide
Prevents value profiling of non\-compile time constants used in division or remainder operations.
.TP 15
noindcall
Prevents value profiling of function addresses at indirect call sites.
.TP 15
all
Enables all types of value profiling.
.RE
.PP
You can specify more than one keyword, but they must be separated by commas.
.NL
.TP
\fBDefault:\fR 
.TP 18
\-prof\-value\-profiling=all or /Qprof\-value\-profiling:all
.NL
All value profile types are enabled and value profiling is performed.
.TP
\fBDescription:\fR 
.PP
This option controls which features are value
profiled.
.NL
.PP
If this option is specified with option
\-prof\-gen (Linux* OS and OS X*) or /Qprof\-gen (Windows* OS), it turns
off instrumentation of operations of the specified type. This also
prevents feedback of values for the operations.
.NL
.PP
If this option is specified with option
\-prof\-use (Linux OS and OS X) or /Qprof\-use (Windows OS), it turns
off feedback of values collected of the specified type.
.NL
.PP
If you specify \-opt\-report (Linux OS and OS X)
or /Qopt\-report (Windows OS) level 2 or higher, the value profiling
specialization information will be reported within the PGO
optimization report.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-profile\-functions
.RS
.TP
Inserts instrumentation calls at a function\[aq]s entry and exit points.
.NL
.TP
\fBArchitectures:\fR IA\-32, Intel(R) 64 architecture
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
No instrumentation calls are inserted at a function\[aq]s entry and exit points.
.TP
\fBDescription:\fR 
.PP
This option inserts instrumentation calls
at a function\[aq]s entry and exit points within
a single\-threaded application to collect
the cycles spent within the function to produce
reports that can help in identifying code
hotspots.
.NL
.PP
When the instrumented application is run, this
option causes the generation of a loop_prof_funcs_<name>.dump
file, where <name> is a timestamp for the
run. 
.NL
.PP
The same data values are also dumped into the file
loop_prof_<name>.xml for use with the data viewer application,
unless you turn off the output format by setting the environment
variable INTEL_LOOP_PROF_XML_DUMP to 0.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-profile\-loops=keyword
.RS
.TP
Inserts instrumentation calls at a function\[aq]s entry and exit points, and before and after instrumentable loops.
.NL
.TP
\fBArchitectures:\fR IA\-32, Intel(R) 64 architecture
.TP
\fBArguments:\fR 
.TP 18
keyword
.NL
Specifies which type of loops should have instrumentation.  Possible values are:
.RS
.TP 15
inner
Inserts instrumentation before and after inner loops.
.TP 15
outer
Inserts instrumentation before and after outer loops.
.TP 15
all
Inserts instrumentation before and after all loops.
.RE
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
No instrumentation calls are inserted at a function\[aq]s entry and exit points, or before and after instrumentable loop.
.TP
\fBDescription:\fR 
.PP
This option inserts instrumentation calls
at a function\[aq]s entry and exit points within
a single\-threaded application.  For unthreaded applications, it also inserts instrumentation before and after instrumentable loops of the type listed in \fIkeyword\fR.
.NL
.PP
When the instrumented application is run, this
option causes the generation of a loop_prof_funcs_<name>.dump
file and a loop_prof_funcs_<name>.dump file, where <name> is a timestamp for the
run. 
.NL
.PP
The same timestamp is used for the loop file and function file.  This identifies that the loop data and function data were from the same program run. 
.NL
.PP
The same data values are also dumped into the file
loop_prof_<name>.xml for use with the data viewer application,
unless you turn off the output format by setting the environment
variable INTEL_LOOP_PROF_XML_DUMP to 0.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-profile\-loops\-report[=n]
.RS
.TP
Controls the level of detail for the data collected when instrumentation occurs before and after certain loops.
.NL
.TP
\fBArchitectures:\fR IA\-32, Intel(R) 64 architecture
.TP
\fBArguments:\fR 
.TP 18
\fIn\fR
.NL
Is a value denoting the level of detail  to report. Possible values are:
.RS
.TP 15
1
Reports the cycle counts on entry and exits of loops. This is the default if \fIn\fR is not specified.
.TP 15
2
Reports the level 1 default details, but also includes the loop min/max and average loop iteration counts. 
.IP
To collect the loop iteration counts, additional instrumentation is inserted. This can increase overhead in the instrumented application and slow performance.
.RE
.TP
\fBDefault:\fR 
.TP 18
\-profile\-loops\-report=1 or /Qprofile\-loops\-report:1
.NL
The report shows the cycle counts on entry and exits of loops.
.TP
\fBDescription:\fR 
.PP
This option controls the level of detail for the data collected when instrumentation occurs before and after certain loops. To use this option, you must also specify option \-profile\-loops (Linux* OS and OS X*) or /Qprofile\-loops (Windows* OS). 
.NL
.PP
The report appears in file loop_prof_loops_<name>.dump, where <name> is a timestamp value for the run. The columns listed in the report will be based on the level of detail that was selected during instrumentation. 
.NL
.PP
It is recommended that the same report level be used for all files that are instrumented for the application. If different files of the application were instrumented with different levels, the report will contain all the columns of the highest detail level, but with default values for unavailable fields for files that were instrumented at lower levels. 
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-pthread
.RS
.TP
Tells the compiler to use pthreads library for multithreading support.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler does not use pthreads library for multithreading support.
.TP
\fBDescription:\fR 
.PP
Tells the compiler to use pthreads library for multithreading support.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-Qinstalldir
.RS
.TP
Specifies the root directory where the compiler installation was performed.
.NL
.TP
\fBArchitectures:\fR IA\-32, Intel(R) 64 architecture
.TP
\fBArguments:\fR 
.TP 18
\fIdir\fR
.NL
Is the root directory where the installation was performed.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The default root directory for compiler installation is searched for the compiler.
.TP
\fBDescription:\fR 
.PP
This option specifies the root directory where the compiler installation was performed. It is useful if you want to use a different compiler or if you did not use the iccvars shell script to set your environment variables. 
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-Qlocation,string,dir
.RS
.TP
Specifies the directory for supporting tools.
.NL
.TP
\fBArchitectures:\fR IA\-32, Intel(R) 64 architecture
.TP
\fBArguments:\fR 
.TP 18
\fIstring\fR
.NL
Is the name of the tool.
.TP 18
\fIdir\fR
.NL
Is the directory (path) where the tool is located.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler looks for tools in a default area.
.TP
\fBDescription:\fR 
.PP
This option specifies the directory for supporting tools.
.NL
.PP
\fIstring\fR can be any of the following:
.NL
.IP \(bu 2
c \- Indicates the Intel(R) C++ compiler.
.IP \(bu 2
cpp (or fpp) \- Indicates the Intel(R) C++ preprocessor.
.IP \(bu 2
cxxinc \- Indicates C++ header files.
.IP \(bu 2
cinc \- Indicates C header files.
.IP \(bu 2
asm \- Indicates the assembler.
.IP \(bu 2
link \- Indicates the linker.
.IP \(bu 2
prof \- Indicates the profiler.
.IP \(bu 2
On Windows* systems, the following is also available:
.RS
.IP \(bu 2
masm \- Indicates the Microsoft assembler.
.RE
.IP \(bu 2
On Linux* and OS X* systems, the following are also available: 
.RS
.IP \(bu 2
as \- Indicates the assembler.
.IP \(bu 2
gas \- Indicates the GNU assembler.
.IP \(bu 2
ld \- Indicates the loader.
.IP \(bu 2
gld \- Indicates the GNU loader.
.IP \(bu 2
lib \- Indicates an additional library.
.IP \(bu 2
crt \- Indicates the crt%.o files linked into executables to contain the place to start execution.
.RE
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-Qoption,string,options
.RS
.TP
Passes options to a specified tool.
.NL
.TP
\fBArchitectures:\fR IA\-32, Intel(R) 64 architecture
.TP
\fBArguments:\fR 
.TP 18
\fIstring\fR
.NL
Is the name of the tool.
.TP 18
\fIoptions\fR
.NL
Are one or more comma\-separated, valid options for the designated tool.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
No options are passed to tools.
.TP
\fBDescription:\fR 
.PP
This option passes options to a specified tool.
.NL
.PP
If an argument contains a space or tab character, you must enclose the entire argument in quotation marks (" "). You must separate multiple arguments with commas.
.NL
.PP
\fIstring\fR can be any of the following:
.NL
.IP \(bu 2
cpp \- Indicates the Intel compiler preprocessor.
.IP \(bu 2
c \- Indicates the C++ compiler.
.IP \(bu 2
asm \- Indicates the assembler.
.IP \(bu 2
link \- Indicates the linker.
.IP \(bu 2
prof \- Indicates the profiler.
.IP \(bu 2
On Windows* systems, the following is also available:
.RS
.IP \(bu 2
masm \- Indicates the Microsoft assembler.
.RE
.IP \(bu 2
On Linux* and OS X* systems, the following are also available:
.RS
.IP \(bu 2
as \- Indicates the assembler.
.IP \(bu 2
gas \- Indicates the GNU assembler.
.IP \(bu 2
ld \- Indicates the loader.
.IP \(bu 2
gld \- Indicates the GNU loader.
.IP \(bu 2
lib \- Indicates an additional library.
.IP \(bu 2
crt \- Indicates the crt%.o files linked into executables to contain the place to start execution.
.RE
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-rcd
.RS
.TP
Enables fast float\-to\-integer conversions.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
Floating\-point values are truncated when a conversion to an integer is involved. 
.TP
\fBDescription:\fR 
.PP
This option enables fast float\-to\-integer conversions. It can improve the performance of code that requires floating\-point\-to\-integer conversions.
.NL
.PP
The system default floating\-point rounding mode is round\-to\-nearest. However, the C language requires floating\-point values to be truncated when a conversion to an integer is involved. To do this, the compiler must change the rounding mode to truncation before each floating\-point\-to\-integer conversion and change it back afterwards.
.NL
.PP
This option disables the change to truncation of the rounding mode for all floating\-point calculations, including floating point\-to\-integer conversions. This option can improve performance, but floating\-point conversions to integer will not conform to C semantics.
.NL
.TP
\fBAlternate Options:\fR 
.PP
Linux and OS X: None
.NL
.RE
.TP
.B
\-regcall
.RS
.TP
Tells the compiler that the __regcall calling convention should be used for functions that do not directly specify a calling convention.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The __regcall calling convention will only be used if a function explicitly specifies it.
.TP
\fBDescription:\fR 
.PP
This option tells the compiler that the __regcall calling convention should be used for functions that do not directly specify a calling convention. This calling convention ensures that as many values as possible are passed or returned in registers.
.NL
.PP
It ensures that __regcall is the default calling convention for functions in the compilation, unless another calling convention is specified in a declaration.
.NL
.PP
This calling convention is ignored if it is specified for a function with variable arguments. 
.NL
.PP
Note that all __regcall functions must have prototypes.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-restrict
.TP
.B
\-no\-restrict
.RS
.TP
Determines whether pointer disambiguation is enabled with the restrict qualifier. 
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-no\-restrict
.NL
Pointers are not qualified with the restrict keyword.
.TP
\fBDescription:\fR 
.PP
This option determines whether pointer disambiguation is enabled with the restrict qualifier. Options \-restrict (Linux and OS X) and /Qrestrict (Windows OS) enable the recognition of the restrict keyword as defined by the ANSI standard.
.NL
.PP
By qualifying a pointer with the restrict keyword, you assert that an object accessed by the pointer is only accessed by that pointer in the given scope. You should use the restrict keyword only when this is true. When the assertion is true, the restrict option will have no effect on program correctness, but may allow better optimization.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-S
.RS
.TP
Causes the compiler to compile to an assembly file only and not link.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
Normal compilation and linking occur.
.TP
\fBDescription:\fR 
.PP
This option causes the compiler to compile to an assembly file only and not link.
.NL
.PP
On Linux and OS X systems, the assembly file name has a .s suffix. On Windows systems, the assembly file name has an .asm suffix.
.NL
.TP
\fBAlternate Options:\fR 
.PP
Linux and OS X: None
.NL
.RE
.TP
.B
\-save\-temps
.TP
.B
\-no\-save\-temps
.RS
.TP
Tells the compiler to save intermediate files created during compilation.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
Linux* OS and OS X*: \-no\-save\-temps 
.NL
On Linux and OS X systems, the compiler deletes intermediate files after compilation is completed. 
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to save intermediate files created during compilation. The names of the files saved are based on the name of the source file; the files are saved in the current working directory.
.NL
.PP
If \-save\-temps or /Qsave\-temps is specified, the following occurs:
.NL
.IP \(bu 2
The object .o file (Linux OS and OS X) or .obj file (Windows OS) is saved.
.IP \(bu 2
The assembler .s file (Linux OS and OS X) or .asm file (Windows OS) is saved if you specified \-use\-asm (Linux OS and OS X) or /Quse\-asm (Windows OS).
.PP
If \-no\-save\-temps is specified on Linux  or OS X systems, the following occurs:
.NL
.IP \(bu 2
The .o file is put into /tmp and deleted after calling ld.
.IP \(bu 2
The preprocessed file is not saved after it has been used by the compiler.
.PP
If /Qsave\-temps\- is specified on Windows systems, the following occurs:
.NL
.IP \(bu 2
The .obj file is not saved after the linker step.
.IP \(bu 2
The preprocessed file is not saved after it has been used by the compiler.
.PP
.B NOTE:
This option only saves intermediate files that are normally created during compilation.
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-scalar\-rep
.TP
.B
\-no\-scalar\-rep
.RS
.TP
Enables scalar replacement performed during loop transformation.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-no\-scalar\-rep 
.NL
Scalar replacement is not performed during loop transformation.
.TP
\fBDescription:\fR 
.PP
This option enables scalar replacement performed during loop transformation. To use this option, you must also specify O3.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-shared (L*X only)
.RS
.TP
Tells the compiler to produce a dynamic shared object instead of an executable.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler produces an executable.
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to produce a dynamic shared object (DSO) instead of an executable. This includes linking in all libraries dynamically and passing \-shared to the linker.
.NL
.PP
You must specify option fpic for the compilation of each object file you want to include in the shared library.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-shared\-intel
.RS
.TP
Causes Intel\-provided libraries to be linked in dynamically.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
Intel(R)
libraries are linked in statically, with the exception of Intel\[aq]s OpenMP* runtime support library, which is linked in dynamically.
.TP
\fBDescription:\fR 
.PP
This option causes Intel\-provided libraries to be linked in dynamically. It is the opposite of \-static\-intel.
.NL
.PP
.B NOTE:
On OS X* systems, when you set "Intel Runtime Libraries" to "Dynamic", you must also set the DYLD_LIBRARY_PATH environment variable within Xcode* or an error will be displayed.
.TP
\fBAlternate Options:\fR 
.PP
Linux and OS X: \-i\-dynamic (this is a deprecated option)
.NL
.RE
.TP
.B
\-shared\-libgcc (L*X only)
.RS
.TP
Links the GNU libgcc library dynamically.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-shared\-libgcc
.NL
The compiler links the libgcc library dynamically.
.TP
\fBDescription:\fR 
.PP
This option links the GNU libgcc library dynamically. It is the opposite of option static\-libgcc.
.NL
.PP
This option is useful when you want to override the default behavior of the static option, which causes all libraries to be linked statically.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-simd
.TP
.B
\-no\-simd
.RS
.TP
Enables or disables the SIMD vectorization feature of the compiler.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-simd 
.NL
The SIMD vectorization feature is enabled.
.TP
\fBDescription:\fR 
.PP
This option enables or disables the SIMD vectorization feature of the compiler.
.NL
.PP
To disable the SIMD transformations for vectorization, specify \-no\-simd (Linux* OS and OS X*) or /Qsimd\- (Windows* OS).
.NL
.PP
To disable vectorization, specify options \-no\-vec (Linux OS and OS X) or /Qvec\- (Windows OS).
.NL
.PP
.B NOTE:
The SIMD vectorization feature is available for both Intel(R) microprocessors and non\-Intel microprocessors. Vectorization may call library routines that can result in additional performance gain on Intel microprocessors than on non\-Intel microprocessors. The vectorization can also be affected by certain options, such as /arch or /Qx (Windows OS) or \-m or \-x (Linux OS and OS X).
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-sox[=keyword[,keyword]] (L*X only)
.TP
.B
\-no\-sox (L*X only)
.RS
.TP
Tells the compiler to save the compilation options and version number in the Linux* OS executable or the Windows* OS object file.  It also lets you choose whether to include lists of certain functions.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.TP 18
\fIkeyword\fR
.NL
Is the function information to include. Possible values are:
.RS
.TP 15
inline
Includes a list of the functions that were compiled with \-prof\-use (Linux* OS) or /Qprof\-use (Windows* OS) and for which the .dpi file had profile information, and an indication for each as to whether the profile information was USED (matched) or IGNORED (mismatched).
.TP 15
profile
Includes a list of the functions that were inlined in each object.
.RE
.TP
\fBDefault:\fR 
.TP 18
\-no\-sox 
.NL
The compiler does not save these informational strings in the executable or object file.
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to save the compilation options and version number in the Linux* OS executable or the Windows* OS object file.  It also lets you choose whether to include lists of certain functions.  The information is embedded as a string in each object file or assembly output.
.NL
.PP
If you specify \-sox  with no argument,
the compiler saves the compiler options and version number used in
the compilation of the objects that make up the
executable.
.NL
.PP
If you specify this option on Linux systems, the size of the executable on disk is
increased slightly. Each \fIkeyword\fR  you specify
increases the size of the executable.
When you link the object files into an executable file, the linker
places each of the information strings into the header of the
executable. It is then possible to use a tool, such as a strings
utility, to determine what options were used to build the
executable file.
.NL
.PP
If you specify this option on Windows systems, the information stays in the object
file.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-static (L*X only)
.RS
.TP
Prevents linking with shared libraries.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler links with shared libraries.
.TP
\fBDescription:\fR 
.PP
This option prevents linking with shared libraries. It causes the executable to link all libraries statically.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-static\-intel
.RS
.TP
Causes Intel\-provided libraries to be linked in statically.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
ON
.NL
Intel
libraries are linked in statically, with the exception of Intel\[aq]s OpenMP runtime support library, which is linked in dynamically.
.TP
\fBDescription:\fR 
.PP
This option causes Intel\-provided libraries to be linked in statically. It is the opposite of \-shared\-intel.
.NL
.PP
If you specify option static\-intel and any of the Intel\-provided libraries have no static version, a diagnostic will be displayed.
.NL
.TP
\fBAlternate Options:\fR 
.PP
Linux and OS X: i\-static (this is a \fIdeprecated\fR option)
.NL
.RE
.TP
.B
\-staticlib (M*X only)
.RS
.TP
Invokes the libtool command to generate static libraries.
.NL
.TP
\fBArchitectures:\fR IA\-32, Intel(R) 64 architecture
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler produces an executable.
.TP
\fBDescription:\fR 
.PP
This option invokes the libtool command to generate static libraries. 
.NL
.PP
When passed this option, the compiler uses the libtool command to produce a static library instead of an executable when linking. 
.NL
.PP
To build dynamic libraries, you should specify option \-dynamiclib or libtool \-dynamic <objects>.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-static\-libgcc (L*X only)
.RS
.TP
Links the GNU libgcc library statically.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
DEFAULT_DESC
.TP
\fBDescription:\fR 
.PP
This option links the GNU libgcc library statically. It is the opposite of option libgcc.
.NL
.PP
This option is useful when you want to override the default behavior of the libgcc option, which causes all libraries to be linked statically.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-std=val
.RS
.TP
Tells the compiler to conform to a specific language standard.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.TP 18
\fIval\fR
.NL
Specifies the specific language standard to conform to. Possible values are:
.RS
.TP 15
c89
Conforms to the ISO/IEC 9899:1990 International Standard. This value is only available on Linux* OS and OS X*.
.TP 15
c99
Conforms to The ISO/IEC 9899:1999 International Standard.
.TP 15
c9x
This value is equivalent to specifying value c99. This value is only available on Linux* OS and OS X*.
.TP 15
gnu89
Conforms to ISO C90 plus GNU* extensions. This value is only available on Linux* OS and OS X*.
.TP 15
gnu99
Conforms to ISO C99 plus GNU* extensions. This value is only available on Linux* OS and OS X*.
.TP 15
gnu++98
Conforms to the 1998 ISO C++ standard plus GNU extensions. This value is only available on Linux* OS and OS X*.
.TP 15
c++0x
Enables support for the following C++11 (formerly known as C++0x) features:
.RS
.IP \(bu 2
Atomic types and operations
.IP \(bu 2
Scoped enumeration types
.IP \(bu 2
Defaulted and deleted functions
.IP \(bu 2
Rvalue references
.IP \(bu 2
Empty macro arguments
.IP \(bu 2
Variadic macros
.IP \(bu 2
Type long long
.IP \(bu 2
Trailing comma in enum definition
.IP \(bu 2
Concatenation of mixed\-width string literals
.IP \(bu 2
Extended friend declarations
.IP \(bu 2
Use of ">>" to close two template argument lists
.IP \(bu 2
Relaxed rules for use of "typename"
.IP \(bu 2
Relaxed rules for disambiguation using the "template" keyword
.IP \(bu 2
"extern template" to suppress instantiation of an entity
.IP \(bu 2
"auto" type specifier
.IP \(bu 2
decltype operator
.IP \(bu 2
static_assert
.IP \(bu 2
compliant __func__
.IP \(bu 2
lambda expressions
.IP \(bu 2
character types char16_t and char32_t to store UTF\-16 and UTF\-32 encoding values, respectively
.IP \(bu 2
template aliases
.IP \(bu 2
variadic templates
.IP \(bu 2
nullptr
.IP \(bu 2
late\-specified return types as defined in gcc proposal N2541
.IP \(bu 2
default template arguments for function templates
.IP \(bu 2
standard attributes as defined in gcc proposal N2761
.IP \(bu 2
new style SFINAE as defined in gcc proposal N2634
.IP \(bu 2
noexcept
.IP \(bu 2
explicit conversion functions (N2437)
.IP \(bu 2
general initializer lists (partial)
.IP \(bu 2
generalized constant expressions (partial)
.IP \(bu 2
use of "this" in late\-specified return types (N3282)
.IP \(bu 2
range based for loops
.RE
.TP 15
gnu++0x
This value is equivalent to specifying value c++0x. This value is only available on Linux* OS and OS X*.
.RE
.TP
\fBDefault:\fR 
.TP 18
\-std=gnu89 (default for C)
.NL
Conforms to ISO C90 plus GNU extensions.
.TP 18
\-std=gnu++98 (default for C++)
.NL
Conforms to the 1998 ISO C++ standard plus GNU* extensions.
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to conform to a specific language standard.
.NL
.PP
On Windows* OS, you can only specify values c99 and c++0x.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-strict\-ansi
.RS
.TP
Tells the compiler to implement strict ANSI conformance dialect. 
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler conforms to default standards.
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to implement strict ANSI conformance dialect. If you need to be compatible with gcc, use the \-ansi option.
.NL
.PP
This option sets option fmath\-errno, which tells the compiler to assume that the program tests errno after calls to math library functions. This restricts optimization because it causes the compiler to treat most math functions as having side effects.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-Tfilename (L*X only)
.RS
.TP
Tells the linker to read link commands from a file.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.TP 18
\fIfilename\fR
.NL
Is the name of the file.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The linker does not read link commands from a file.
.TP
\fBDescription:\fR 
.PP
This option tells the linker to read link commands from a file.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-tbb
.RS
.TP
Tells the compiler to link to the Intel(R) Threading Building Blocks (Intel(R) TBB) libraries.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler does not link to the Intel(R) TBB libraries.
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to link to the Intel(R) Threading Building Blocks (Intel(R) TBB) libraries and include the Intel(R) TBB headers. 
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-tcheck (L*X only)
.RS
.TP
Enables analysis of threaded applications.
.NL
.TP
\fBArchitectures:\fR IA\-32, Intel(R) 64 architecture
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
Threaded applications are not instrumented by the compiler for analysis by Intel(R) Thread Checker.
.TP
\fBDescription:\fR 
.PP
This option enables analysis of threaded applications.
.NL
.PP
To use this option, you must have Intel(R) Thread Checker installed, which is one of the Intel(R) Threading Analysis Tools. If you do not have this tool installed, the compilation will fail. Remove the \-tcheck (Linux* OS) or /Qtcheck (Windows* OS) option from the command line and recompile. 
.NL
.PP
For more information about Intel(R) Thread Checker (including an evaluation copy), open the page associated with threading tools at \fIIntel(R) Software Development Products\fR.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-tcollect[lib] (L*X only)
.RS
.TP
Inserts instrumentation probes calling the Intel(R) Trace Collector API.
.NL
.TP
\fBArchitectures:\fR IA\-32, Intel(R) 64 architecture
.TP
\fBArguments:\fR 
.TP 18
\fIlib\fR
.NL
Is one of the Intel(R) Trace Collector libraries; for example, VT, VTcs, VTmc, or VTfs. If you do not specify \fIlib\fR, the default library is VT.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
Instrumentation probes are not inserted into compiled applications.
.TP
\fBDescription:\fR 
.PP
This option inserts instrumentation probes calling the Intel(R) Trace Collector API. To use this option, you must have the Intel(R) Trace Collector installed and set up through one of its set\-up scripts. This tool is a component of the Intel(R) Trace Analyzer and Collector.
.NL
.PP
This option provides a flexible and convenient way of instrumenting functions of a compiled application. For every function, the entry and exit points are instrumented at compile time to let the Intel(R) Trace Collector record functions beyond the default MPI calls. For non\-MPI applications (for example, threaded or serial), you must ensure that the Intel(R) Trace Collector is properly initialized (VT_initialize/VT_init).
.NL
.PP
.B CAUTION:
Be careful with full instrumentation because this feature can produce very large trace files.
.PP
For more details, see the Intel(R) Trace Collector User Guide.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-tcollect\-filter filename (L*X only)
.RS
.TP
Lets you enable or disable the instrumentation of specified functions.
.NL
.TP
\fBArchitectures:\fR IA\-32, Intel(R) 64 architecture
.TP
\fBArguments:\fR 
.TP 18
\fIfilename\fR
.NL
Is a configuration file that lists filters, one per line. Each filter consists of a regular expression string and a switch. Strings with leading or trailing white spaces must be quoted. Other strings do not have to be quoted. The switch value can be ON, on, OFF, or off.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
Functions are not instrumented. However, if option \-tcollect (Linux) is specified, the filter setting is ".* ON" and all functions get instrumented. 
.TP
\fBDescription:\fR 
.PP
This option lets you enable or disable the instrumentation of specified functions. 
.NL
.PP
During instrumentation, the regular expressions in the file are matched against the function names. The switch specifies whether matching functions are to be instrumented or not. Multiple filters are evaluated from top to bottom with increasing precedence. 
.NL
.PP
The names of the functions to match against are formatted as follows:
.NL
.IP \(bu 2
C++ function names are demangled and the C++ class hierarchy is used. Function parameters are stripped to keep the function names shorter. 
.IP \(bu 2
The source file name is followed by a colon\-separated function name. Source file names should contain the full path, if available. For example: 
.IP
/home/joe/src/foo.c:FOO_bar
.IP \(bu 2
Classes and function names are separated by double colons. For example:
.IP
/home/joe/src/foo.cpp:app::foo::bar
.PP
You can use option \-opt\-report (Linux* OS) or /Qopt\-report (Windows* OS) to get a full list of file and function names that the compiler recognizes from the compilation unit. This list can be used as the basis for filtering in the configuration file.
.NL
.PP
To use this option, you must have the Intel(R) Trace Collector installed and set up through one of its set\-up scripts. This tool is a component of the Intel(R) Trace Analyzer and Collector. 
.NL
.PP
For more details, see the Intel(R) Trace Collector User Guide.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-traceback
.TP
.B
\-notraceback
.RS
.TP
Tells the compiler to generate extra information in the object file to provide source file traceback information when a severe error occurs at run time.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
notraceback
.NL
No extra information is generated in the object file to produce traceback information.
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to generate extra information in the object file to provide source file traceback information when a severe error occurs at run time. This is intended for use with C code that is to be linked into a Fortran program.
.NL
.PP
When the severe error occurs, source file, routine name, and line number correlation information is displayed along with call stack hexadecimal addresses (program counter trace).
.NL
.PP
Note that when a severe error occurs, advanced users can also locate the cause of the error using a map file and the hexadecimal addresses of the stack displayed when the error occurs.
.NL
.PP
This option increases the size of the executable program, but has no impact on run\-time execution speeds.
.NL
.PP
It functions independently of the debug option.
.NL
.PP
On Windows* systems, traceback sets the /Oy\- option, which forces the compiler to use EBP as the stack frame pointer.
.NL
.PP
On Windows* systems, the linker places the traceback information in the executable image, in a section named ".trace". To see which sections are in an image, use the command:
.NL
.PP
link \-dump \-summary your_app_name.exe
.PP
.PP
To see more detailed information, use the command:
.NL
.PP
link \-dump \-headers your_app_name.exe
.PP
.PP
On Linux* systems, to display the section headers in the image (including the header for the .trace section, if any), use the command:
.NL
.PP
objdump \-h your_app_name.exe
.PP
.PP
On OS X* systems, to display the section headers in the image, use the command:
.NL
.PP
otool \-l your_app_name.exe
.PP
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-Wtrigraphs
.TP
.B
\-Wno\-trigraphs
.RS
.TP
Determines whether warnings are issued if any trigraphs are encountered that might change the meaning of the program.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-Wno\-trigraphs
.NL
No warnings are issued if any trigraphs are encountered that might change the meaning of the program.
.TP
\fBDescription:\fR 
.PP
This option determines whether warnings are issued if any trigraphs are encountered that might change the meaning of the program.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-u symbol
.RS
.TP
Tells the compiler the specified symbol is undefined.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
Standard rules are in effect for variables.
.TP
\fBDescription:\fR 
.PP
This option tells the compiler the specified \fIsymbol\fR is undefined.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-Uname
.RS
.TP
Undefines any definition currently in effect for the specified macro.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.TP 18
\fIname\fR
.NL
Is the name of the macro to be undefined.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
Macro definitions are in effect until they are undefined.
.TP
\fBDescription:\fR 
.PP
This option undefines any definition currently in effect for the specified macro. It is equivalent to an #undef preprocessing directive.
.NL
.PP
On Windows systems, use the /u option to undefine all previously defined preprocessor values.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-unroll[=n]
.RS
.TP
Tells the compiler the maximum number of times to unroll loops.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.TP 18
\fIn\fR
.NL
Is the maximum number of times a loop can be unrolled. To disable loop enrolling, specify 0.
.TP
\fBDefault:\fR 
.TP 18
\-unroll 
.NL
The compiler uses default heuristics when unrolling loops.
.TP
\fBDescription:\fR 
.PP
This option tells the compiler the maximum number of times to unroll loops.
.NL
.PP
If you do not specify \fIn\fR, the optimizer determines how many times loops can be unrolled.
.NL
.TP
\fBAlternate Options:\fR 
.PP
Linux and OS X: \-funroll\-loops
.NL
.RE
.TP
.B
\-unroll\-aggressive
.TP
.B
\-no\-unroll\-aggressive
.RS
.TP
Determines whether the compiler uses more aggressive unrolling for certain loops.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-no\-unroll\-aggressive 
.NL
The compiler uses default heuristics when unrolling loops.
.TP
\fBDescription:\fR 
.PP
This option determines whether the compiler uses more aggressive unrolling for certain loops. The positive form of the option may improve performance.
.NL
.PP
This option enables aggressive, complete unrolling for loops with small constant trip counts.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-use\-clang\-env (M*X only)
.TP
.B
\-no\-use\-clang\-env (M*X only)
.RS
.TP
Enables the use of the Clang environment.
.NL
.TP
\fBArchitectures:\fR IA\-32, Intel(R) 64 architecture
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-no\-use\-clang\-env
.NL
The gcc environment is used.
.TP
\fBDescription:\fR 
.PP
This option enables the use of the Clang environment. This environment uses the Clang headers and libraries.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-use\-intel\-optimized\-headers
.RS
.TP
Determines whether the performance headers directory is added to the include path search list. 
.NL
.TP
\fBArchitectures:\fR IA\-32, Intel(R) 64 architecture
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-no\-use\-intel\-optimized\-headers
.NL
The performance headers directory is not added to the include path search list.
.TP
\fBDescription:\fR 
.PP
This option determines whether the performance headers directory is added to the include path search list.
.NL
.PP
The performance headers directory is added if you specify \-use\-intel\-optimized\-headers (Linux and OS X) or /Quse\-intel\-optimized\-headers (Windows OS). Appropriate libraries are also linked in, as needed, for proper functionality.
.NL
.PP
.TP 18
\fBOptimization Notice 
\fR
.NL
.NL
.TP 18
= = = = = = = = = = 
.TP 18
Intel\[aq]s compilers may or may not optimize to the same degree for non\-Intel microprocessors for optimizations that are not unique to Intel microprocessors. These optimizations include SSE2, SSE3, and SSSE3 instruction sets and other optimizations. Intel does not guarantee the availability, functionality, or effectiveness of any optimization on microprocessors not manufactured by Intel. Microprocessor\-dependent optimizations in this product are intended for use with Intel microprocessors. Certain optimizations not specific to Intel microarchitecture are reserved for Intel microprocessors. Please refer to the applicable product User and Reference Guides for more information regarding the specific instruction sets covered by this notice. 
.TP 18
Notice revision #20110804 
.TP 18
= = = = = = = = = = 
.NL
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-use\-msasm
.RS
.TP
Enables the use of blocks and entire functions of assembly code within a C or C++ file.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler allows a GNU*\-style inline assembly format.
.TP
\fBDescription:\fR 
.PP
This option enables the use of blocks and entire functions of assembly code within a C or C++ file.
.NL
.PP
It allows a Microsoft* MASM\-style inline assembly block not a GNU*\-style inline assembly block.
.NL
.TP
\fBAlternate Options:\fR 
.PP
\-fasm\-blocks
.NL
.RE
.TP
.B
\-V
.RS
.TP
Displays the compiler version information.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler version information is not displayed.
.TP
\fBDescription:\fR 
.PP
This option displays the startup banner, which contains the following compiler information:
.NL
.IP \(bu 2
The name of the compiler and its applicable architecture
.IP \(bu 2
The major and minor version of the compiler, the update number, and the package number(for example, Version 12.1.0.047)
.IP \(bu 2
The specific build and build date (for example, Build <builddate>)
.IP \(bu 2
The copyright date of the software
.PP
This option can be placed anywhere on the command line.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-v[filename]
.RS
.TP
Specifies that driver tool commands should be displayed and executed.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.TP 18
\fIfilename\fR
.NL
Is the name of a file.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
No tool commands are shown.
.TP
\fBDescription:\fR 
.PP
This option specifies that driver tool commands should be displayed and executed. 
.NL
.PP
If you use this option without specifying a file name, the compiler displays only the version of the compiler.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-vec
.TP
.B
\-no\-vec
.RS
.TP
Enables or disables vectorization.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-vec 
.NL
Vectorization is enabled.
.TP
\fBDescription:\fR 
.PP
This option enables or disables vectorization.
.NL
.PP
To disable vectorization, specify \-no\-vec (Linux* OS and OS X*) or /Qvec\- (Windows* OS). 
.NL
.PP
To disable the SIMD transformations, specify option \-no\-simd (Linux
OS and OS X) or /Qsimd\- (Windows OS).
.NL
.PP
.B NOTE:
Using this option enables vectorization at default optimization levels for both Intel(R) microprocessors and non\-Intel microprocessors.  Vectorization may call library routines that
can result in additional performance gain on Intel microprocessors than on non\-Intel
microprocessors. The vectorization can also be affected by certain options, such as /arch or /Qx (Windows OS) or \-m or \-x (Linux
OS and OS X).
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-vec\-guard\-write
.TP
.B
\-no\-vec\-guard\-write
.RS
.TP
Tells the compiler to perform a conditional check in a vectorized loop.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-vec\-guard\-write 
.NL
The  compiler  performs a conditional check in a vectorized loop.
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to perform a conditional check in a vectorized loop. This checking avoids unnecessary stores and may improve performance.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-vec\-report[n]
.RS
.TP
Controls the diagnostic information reported by the vectorizer.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.TP 18
\fIn\fR
.NL
Is a value denoting which diagnostic messages to report. Possible values are:
.RS
.TP 15
0
Tells the vectorizer to report no diagnostic information.
.TP 15
1
Tells the vectorizer to report on vectorized loops.
.TP 15
2
Tells the vectorizer to report on vectorized and non\-vectorized loops.
.TP 15
3
Tells the vectorizer to report on vectorized and non\-vectorized loops and any proven or assumed data dependences.
.TP 15
4
Tells the vectorizer to report on non\-vectorized loops.
.TP 15
5
Tells the vectorizer to report on non\-vectorized loops and the reason why they were not vectorized.
.TP 15
6
Tells the vectorizer to use greater detail when reporting on vectorized
and non\-vectorized loops and any
proven or assumed data dependences.
.RE
.TP
\fBDefault:\fR 
.TP 18
\-vec\-report0 
.NL
If you do not specify the option on the command line, the default is to display no messages. However, if vectorization diagnostics reporting has been enabled and you do not specify \fIn\fR, the compiler reports diagnostics on vectorized loops. 
.TP
\fBDescription:\fR 
.PP
This option controls the diagnostic information reported by the vectorizer. The vectorizer report is sent to stdout.
.NL
.PP
If you do not specify \fIn\fR, it is the same as specifying \-vec\-report1 (Linux* OS and OS X*) or /Qvec\-report1 (Windows* OS).
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-vec\-threshold[n]
.RS
.TP
Sets a threshold for the vectorization of loops. 
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.TP 18
\fIn\fR
.NL
Is an integer whose value is the
threshold for the vectorization of loops. Possible values are 0 through 100.
.IP
If \fIn\fR is 0, loops get vectorized always, regardless of computation work volume.
.IP
If \fIn\fR is 100, loops get vectorized when performance gains are predicted based on
the compiler analysis data. Loops get vectorized only if profitable vector\-level
parallel execution is almost certain.
.IP
The intermediate 1 to 99 values represent the percentage probability for profitable speed\-up. For example, \fIn\fR=50 directs the compiler to vectorize
only if there is a 50% probability of the code speeding up if executed in vector form.
.TP
\fBDefault:\fR 
.TP 18
\-vec\-threshold100 
.NL
Loops get vectorized only
if profitable vector\-level parallel execution is almost certain. This is also the default if you do not specify  \fIn\fR.
.TP
\fBDescription:\fR 
.PP
This option sets a threshold for the vectorization of loops based on the probability of profitable execution of the vectorized loop in parallel. 
.NL
.PP
This option is useful for loops whose computation work volume cannot be determined at compile\-time. The threshold is usually relevant when the loop trip count is unknown at compile\-time.  
.NL
.PP
The compiler applies a heuristic that tries to balance the overhead of creating multiple threads versus the amount of work available to be shared amongst the threads.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-\-version
.RS
.TP
Tells the compiler to display GCC\-style version information.
.NL
.TP
\fBArchitectures:\fR IA\-32, Intel(R) 64 architecture
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
.TP
\fBDescription:\fR 
.PP
Tells the compiler to display GCC\-style version information.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-w
.RS
.TP
Disables all warning messages.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
Default warning messages are enabled.
.TP
\fBDescription:\fR 
.PP
This option disables all warning messages.
.NL
.TP
\fBAlternate Options:\fR 
.PP
Linux and OS X: \-w0
.NL
.PP
Windows: /W0
.NL
.RE
.TP
.B
\-wn
.RS
.TP
Specifies the level of diagnostic messages to be generated by the compiler.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.TP 18
\fIn\fR
.NL
Is the level of diagnostic messages to be generated. Possible values are:
.RS
.TP 15
0
Enables diagnostics for errors. Disables diagnostics
for warnings.
.TP 15
1
Enables diagnostics for warnings and errors. 
.TP 15
2
Enables diagnostics for warnings and errors. On Linux* and OS X* systems, additional warnings are
enabled. On
Windows* systems, this setting is equivalent to level 1 (\fIn  \fR= 1). 
.TP 15
3
Enables diagnostics for remarks, warnings, and errors. Additional warnings are also enabled above level 2 (\fIn\fR = 2). This level is recommended for production
purposes.
.TP 15
4
Enables diagnostics for all level 3 (\fIn\fR = 3) warnings plus informational warnings  and remarks, which in most cases can be safely ignored. This value is only available on Windows* systems.
.TP 15
5
Enables diagnostics for all remarks, warnings, and errors. This setting produces the most diagnostic messages. This value is only available on Windows* systems.
.RE
.TP
\fBDefault:\fR 
.TP 18
n=1
.NL
The compiler displays  diagnostics for warnings and errors.
.TP
\fBDescription:\fR 
.PP
This option specifies the level of diagnostic messages to be generated by the compiler.
.NL
.PP
On Windows systems, option /W4 is equivalent to option /Wall.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-Wa,option1[,option2,...]
.RS
.TP
Passes options to the assembler for processing.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.TP 18
\fIoption\fR
.NL
Is an assembler option. This option is not processed by the driver and is directly passed to the assembler.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
No options are passed to the assembler.
.TP
\fBDescription:\fR 
.PP
This option passes one or more options to the assembler for processing. If the assembler is not invoked, these options are ignored.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-Wabi
.TP
.B
\-Wno\-abi
.RS
.TP
Determines whether a warning is issued if generated code is not C++ ABI compliant.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-Wno\-abi
.NL
No warning is issued when generated code is not C++ ABI compliant.
.TP
\fBDescription:\fR 
.PP
This option determines whether a warning is issued if generated code is not C++ ABI compliant.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-Wall
.RS
.TP
Enables warning and error diagnostics.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
Only default warning diagnostics are enabled.
.TP
\fBDescription:\fR 
.PP
This option enables warning and error diagnostics.
.NL
.PP
On Windows* systems, this option is equivalent to the /W4 option. It enables diagnostics for all level 3 warnings plus informational warnings and remarks.
.NL
.PP
However, on Linux* and OS X* systems, this
option is similar to gcc option Wall. On these systems,
if you want to display remarks and
comments, specify option \-Wremarks.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-watch[=keyword[, keyword...]]
.TP
.B
\-nowatch
.RS
.TP
Tells the compiler to display certain information to the console output window.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.TP 18
keyword
.NL
Determines what information is displayed. Possible values are:
.RS
.TP 15
none
Disables cmd and source.
.TP 15
[no]cmd
Determines whether driver tool commands are displayed and executed.
.TP 15
[no]source
Determines whether the name of the file being compiled is displayed.
.TP 15
mic\-cmd
Enables display of compiler options that are copied over from the host compilation and passed to the offload compilation. This keyword is only available on Intel(R) MIC Architecture.
.TP 15
all
Enables cmd and source.
.RE
.TP
\fBDefault:\fR 
.TP 18
nowatch
.NL
Pass information and source file names are not displayed to the console output window.
.TP
\fBDescription:\fR 
.PP
Tells the compiler to display processing information (pass information and source file names) to the console output window.
.NL
.TP 18
\fBOption watchkeyword\fR
.NL
.NL
\fBDescription\fR
.NL
.NL
.TP 18
none
.NL
Tells the compiler to not display pass information and source file names to the console output window. This is the same as specifying nowatch.
.NL
.TP 18
cmd
.NL
Tells the compiler to display and execute driver tool commands.
.NL
.TP 18
source
.NL
Tells the compiler to display the name of the file being compiled.
.NL
.TP 18
mic\-cmd
.NL
Tells the compiler to display the compiler options that are passed to the offload compilation after they are specified on the host compilation command line.  Only the options that are automatically passed are displayed. If this keyword is specified on an architecture other than Intel(R) MIC Architecture, results vary. It may be ignored, have no effect, or produce an error.
.NL
.TP 18
all
.NL
Tells the compiler to display pass information and source file names to the console output window. This is the same as specifying watch with no \fIkeyword\fR.  For heterogeneous compilation, the tool commands for the host and the offload compilations will be displayed.
.NL
.TP
\fBAlternate Options:\fR 
.TP 18
watch cmd
.NL
Linux and OS X: \-v
.RE
.TP
.B
\-Wbrief
.RS
.TP
Tells the compiler to display a shorter form of diagnostic output. 
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler displays its normal diagnostic output.
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to display a shorter form of diagnostic output. In this form, the original source line is not displayed and the error message text is not wrapped when too long to fit on a single line.
.NL
.TP
\fBAlternate Options:\fR 
.PP
Linux and OS X: None
.NL
.RE
.TP
.B
\-Wcheck
.RS
.TP
Tells the compiler to perform compile\-time code checking for certain code. 
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
No compile\-time code checking is performed.
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to perform compile\-time code checking for certain code. It specifies to check for code that exhibits non\-portable behavior, represents a possible unintended code sequence, or possibly affects operation of the program because of a quiet change in the ANSI C Standard. 
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-Wcomment
.TP
.B
\-Wno\-comment
.RS
.TP
Determines whether a warning is issued when /* appears in the middle of a /* */ comment.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-Wno\-comment
.NL
No warning is issued when /* appears in the middle of a /* */ comment.
.TP
\fBDescription:\fR 
.PP
This option determines whether a warning is issued when /* appears in the middle of a /* */ comment.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-Wcontext\-limit=n
.RS
.TP
Set the maximum number of template instantiation contexts shown in diagnostic.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.TP 18
\fIn\fR
.NL
Number of template instantiation contexts.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
.TP
\fBDescription:\fR 
.PP
Set maximum number of template instantiation contexts shown in diagnostic.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-Wdeprecated
.TP
.B
\-Wno\-deprecated
.RS
.TP
Determines whether warnings are issued for deprecated features.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
C++: \-Wdeprecated C: \-Wno\-deprecated
.NL
For C++ compilations, the compiler issues warnings for deprecated features.  For C compilations, no warnings are issued for deprecated features.
.TP
\fBDescription:\fR 
.PP
This option determines whether warnings are issued for deprecated features.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-Weffc++
.RS
.TP
Enables warnings based on certain C++ programming guidelines.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
Diagnostics are not enabled.
.TP
\fBDescription:\fR 
.PP
This option enables warnings based on certain programming guidelines developed by Scott Meyers in his books on effective C++ programming. With this option, the compiler emits warnings for these guidelines:
.NL
.IP \(bu 2
Use const and inline rather than #define. Note that you will only get this in user code, not system header code.
.IP \(bu 2
Use <iostream> rather than <stdio.h>.
.IP \(bu 2
Use new and delete rather than malloc and free.
.IP \(bu 2
Use C++ style comments in preference to C style comments. C comments in system headers are not diagnosed.
.IP \(bu 2
Use delete on pointer members in destructors. The compiler diagnoses any pointer that does not have a delete.
.IP \(bu 2
Make sure you have a user copy constructor and assignment operator in classes containing pointers.
.IP \(bu 2
Use initialization rather than assignment to members in constructors.
.IP \(bu 2
Make sure the initialization list ordering matches the declartion list ordering in constructors.
.IP \(bu 2
Make sure base classes have virtual destructors.
.IP \(bu 2
Make sure operator= returns *this.
.IP \(bu 2
Make sure prefix forms of increment and decrement return a const object.
.IP \(bu 2
Never overload operators &&, ||, and ,.
.PP
.B NOTE:
The warnings generated by this compiler option are based on the following books from Scott Meyers:
.IP \(bu 2
Effective C++ Second Edition \- 50 Specific Ways to Improve Your Programs and Designs
.IP \(bu 2
More Effective C++ \- 35 New Ways to Improve Your Programs and Designs
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-Werror
.RS
.TP
Changes all warnings to errors.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler returns diagnostics as usual.
.TP
\fBDescription:\fR 
.PP
This option changes all warnings to errors.
.NL
.TP
\fBAlternate Options:\fR 
.PP
Linux and OS X: \-diag\-error warn
.NL
.RE
.TP
.B
\-Wextra\-tokens
.TP
.B
\-Wno\-extra\-tokens
.RS
.TP
Determines whether warnings are issued about extra tokens at the end of preprocessor directives. 
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-Wno\-extra\-tokens
.NL
The compiler does not warn about extra tokens at the end of preprocessor directives.
.TP
\fBDescription:\fR 
.PP
This option determines whether warnings are issued about extra tokens at the end of preprocessor directives.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-Wformat
.TP
.B
\-Wno\-format
.RS
.TP
Determines whether argument checking is enabled for calls to printf, scanf, and so forth.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-Wno\-format
.NL
Argument checking is not enabled for calls to printf, scanf, and so forth.
.TP
\fBDescription:\fR 
.PP
This option determines whether argument checking is enabled for calls to printf, scanf, and so forth.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-Wformat\-security
.TP
.B
\-Wno\-format\-security
.RS
.TP
Determines whether the compiler issues a warning when the use of format functions may cause security problems. 
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-Wno\-format\-security
.NL
No warning is issued when the use of format functions may cause security problems.
.TP
\fBDescription:\fR 
.PP
This option determines whether the compiler issues a warning when the use of format functions may cause security problems. 
.NL
.PP
When \-Wformat\-security is specified, it warns about uses of format functions where the format string is not a string literal and there are no format arguments.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-Winline
.RS
.TP
Enables diagnostics about what is inlined and what is not inlined.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
No diagnostics are produced about what is inlined and what is not inlined.
.TP
\fBDescription:\fR 
.PP
This option enables diagnostics about what is inlined and what is not inlined. The diagnostics depend on what interprocedural functionality is available.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-Wl,option1[,option2,...]
.RS
.TP
Passes options to the linker for processing.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.TP 18
\fIoption\fR
.NL
Is a linker option. This option is not processed by the driver and is directly passed to the linker.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
No options are passed to the linker.
.TP
\fBDescription:\fR 
.PP
This option passes one or more options to the linker for processing. If the linker is not invoked, these options are ignored.
.NL
.PP
This option is equivalent to specifying option \-Qoption,link,\fIoptions\fR.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-Wmain
.TP
.B
\-Wno\-main
.RS
.TP
Determines whether a warning is issued if the return type of main is not expected.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-Wno\-main
.NL
No warning is issued if the return type of main is not expected.
.TP
\fBDescription:\fR 
.PP
This option determines whether a warning is issued if the return type of main is not expected.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-Wmissing\-declarations
.TP
.B
\-Wno\-missing\-declarations
.RS
.TP
Determines whether warnings are issued for global functions and variables without prior declaration.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-Wno\-missing\-declarations
.NL
No warnings are issued for global functions and variables without prior declaration.
.TP
\fBDescription:\fR 
.PP
This option determines whether warnings are issued for global functions and variables without prior declaration.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-Wmissing\-prototypes
.TP
.B
\-Wno\-missing\-prototypes
.RS
.TP
Determines whether warnings are issued for missing prototypes.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-Wno\-missing\-prototypes
.NL
No warnings are issued for missing prototypes.
.TP
\fBDescription:\fR 
.PP
Determines whether warnings are issued for missing prototypes.
.NL
.PP
If \-Wmissing\-prototypes is specified, it tells the compiler to detect global functions that are defined without a previous prototype declaration.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-Wnon\-virtual\-dtor
.RS
.TP
Tells the compiler to issue a warning when a class appears to be polymorphic, yet it declares a non\-virtual one. 
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler does not issue a warning.
.TP
\fBDescription:\fR 
.PP
Tells the compiler to issue a warning when a class appears to be polymorphic, yet it declares a non\-virtual one. This option is supported in C++ only.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-Wp,option1[,option2,...]
.RS
.TP
Passes options to the preprocessor.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.TP 18
\fIoption\fR
.NL
Is a preprocessor option. This option is not processed by the driver and is directly passed to the preprocessor.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
No options are passed to the preprocessor.
.TP
\fBDescription:\fR 
.PP
This option passes one or more options to the preprocessor. If the preprocessor is not invoked, these options are ignored.
.NL
.PP
This option is equivalent to specifying option \-Qoption,\fIcpp\fR\fI, options\fR.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-Wp64
.RS
.TP
Tells the compiler to display diagnostics for 64\-bit porting. 
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler does not display diagnostics for 64\-bit porting.
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to display diagnostics for 64\-bit porting.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-Wpointer\-arith
.TP
.B
\-Wno\-pointer\-arith
.RS
.TP
Determines whether warnings are issued for questionable pointer arithmetic.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-Wno\-pointer\-arith
.NL
No warnings are issued for questionable pointer arithmetic.
.TP
\fBDescription:\fR 
.PP
Determines whether warnings are issued for questionable pointer arithmetic.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-Wpragma\-once
.TP
.B
\-Wno\-pragma\-once
.RS
.TP
Determines whether a warning is issued about the use of #pragma once. 
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-Wno\-pragma\-once
.NL
No warning is issued about the use of #pragma once.
.TP
\fBDescription:\fR 
.PP
This option determines whether a warning is issued about the use of #pragma once.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-Wremarks
.RS
.TP
Tells the compiler to display remarks and comments.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
Default warning messages are enabled.
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to display remarks and comments.
.NL
.PP
If you want to display warnings and errors, specify option \-Wall.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-Wreorder
.RS
.TP
Tells the compiler to issue a warning when the order of member initializers does not match the order in which they must be executed. 
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
The compiler does not issue a warning.
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to issue a warning when the order of member initializers does not match the order in which they must be executed. This option is supported for C++ only.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-Wreturn\-type
.TP
.B
\-Wno\-return\-type
.RS
.TP
Determines whether warnings are issued when a function uses the default int return type or when a return statement is used in a void function.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-Wno\-return\-type
.NL
No warnings are issued when a function uses the default int return type or when a return statement is used in a void function.
.TP
\fBDescription:\fR 
.PP
This option determines whether warnings are issued when a function uses the default int return type or when a return statement is used in a void function.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-Wshadow
.TP
.B
\-Wno\-shadow
.RS
.TP
Determines whether a warning is issued when a variable declaration hides a previous declaration.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-Wno\-shadow
.NL
No warning is issued when a variable declaration hides a previous declaration.
.TP
\fBDescription:\fR 
.PP
This option determines whether a warning is issued when a variable declaration hides a previous declaration. Same as \-ww1599.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-Wsign\-compare
.TP
.B
\-Wno\-sign\-compare
.RS
.TP
Determines whether warnings are issued when a comparison between signed and unsigned values could produce an incorrect result when the signed value is converted to unsigned.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-Wno\-sign\-compare
.NL
The compiler does not issue these warnings
.TP
\fBDescription:\fR 
.PP
This option determines whether warnings are
issued when a comparison between signed and unsigned values could
produce an incorrect result when the signed value is converted to
unsigned.
.NL
.PP
This option is provided for compatibility with
gcc.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-Wstrict\-aliasing
.TP
.B
\-Wno\-strict\-aliasing
.RS
.TP
Determines whether warnings are issued for code that might violate the optimizer\[aq]s strict aliasing rules.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-Wno\-strict\-aliasing
.NL
No warnings are issued for code that might violate the optimizer\[aq]s strict aliasing rules.
.TP
\fBDescription:\fR 
.PP
This option determines whether warnings are issued for code that might violate the optimizer\[aq]s strict 
aliasing rules. These warnings will only be issued if you also specify option –ansi\-alias or 
option –fstrict\-aliasing.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-Wstrict\-prototypes
.TP
.B
\-Wno\-strict\-prototypes
.RS
.TP
Determines whether warnings are issued for functions declared or defined without specified argument types.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-Wno\-strict\-prototypes
.NL
No warnings are issued for functions declared or defined without specified argument types.
.TP
\fBDescription:\fR 
.PP
This option determines whether warnings are issued for functions declared or defined without specified argument types.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-Wtrigraphs
.TP
.B
\-Wno\-trigraphs
.RS
.TP
Determines whether warnings are issued if any trigraphs are encountered that might change the meaning of the program.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-Wno\-trigraphs
.NL
No warnings are issued if any trigraphs are encountered that might change the meaning of the program.
.TP
\fBDescription:\fR 
.PP
This option determines whether warnings are issued if any trigraphs are encountered that might change the meaning of the program.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-Wuninitialized
.TP
.B
\-Wno\-uninitialized
.RS
.TP
Determines whether a warning is issued if a variable is used before being initialized.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-Wno\-uninitialized
.NL
No warning is issued if a variable is used before being initialized. 
.TP
\fBDescription:\fR 
.PP
This option determines whether a warning is issued if a variable is used before being initialized. Equivalent to \-ww592 and \-wd592.
.NL
.TP
\fBAlternate Options:\fR 
.PP
\-ww592 and \-wd592
.NL
.RE
.TP
.B
\-Wunknown\-pragmas
.TP
.B
\-Wno\-unknown\-pragmas
.RS
.TP
Determines whether a warning is issued if an unknown #pragma directive is used.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-Wunknown\-pragmas
.NL
No warning is issued if an unknown #pragma directive is used.
.TP
\fBDescription:\fR 
.PP
This option determines whether a warning is issued if an unknown #pragma directive is used.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-Wunused\-function
.TP
.B
\-Wno\-unused\-function
.RS
.TP
Determines whether a warning is issued if a declared function is not used.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-Wno\-unused\-function
.NL
No warning is issued if a declared function is not used.
.TP
\fBDescription:\fR 
.PP
This option determines whether a warning is issued if a declared function is not used.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-Wunused\-variable
.TP
.B
\-Wno\-unused\-variable
.RS
.TP
Determines whether a warning is issued if a local or non\-constant static variable is unused after being declared.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
\-Wno\-unused\-variable
.NL
No warning is issued if a local or non\-constant static variable is unused after being declared.
.TP
\fBDescription:\fR 
.PP
This option determines whether a warning is issued if a local or non\-constant static variable is unused after being declared.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-Wwrite\-strings
.RS
.TP
Issues a diagnostic message if const char * is converted to (non\-const) char *.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
No diagnostic message is issued if const char * is converted to (non\-const) char*.
.TP
\fBDescription:\fR 
.PP
This option issues a diagnostic message if const char* is converted to (non\-const) char *.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-x type
.RS
.TP
All source files found subsequent to \-x type will be recognized as a particular type.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.TP 18
\fItype\fR
.NL
is the type of source file. Possible values are:
.RS
.TP 15
c++
C++ source file
.TP 15
c++\-header
C++ header file
.TP 15
c++\-cpp\-output
C++ pre\-processed file
.TP 15
c
C source file
.TP 15
c\-header
C header file
.TP 15
cpp\-output
C pre\-processed file
.TP 15
assembler
Assembly file
.TP 15
assembler\-with\-cpp
Assembly file that needs to be preprocessed
.TP 15
none
Disable recognition, and revert to file extension
.RE
.TP
\fBDefault:\fR 
.TP 18
none
.NL
Disable recognition and revert to file extension.
.TP
\fBDescription:\fR 
.PP
All source files found subsequent to \-x \fI\fR will be recognized as a particular type.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-xcode
.RS
.TP
Tells the compiler which processor features it may target, including which instruction sets and optimizations it may generate.
.NL
.TP
\fBArchitectures:\fR IA\-32, Intel(R) 64 architecture
.TP
\fBArguments:\fR 
.TP 18
\fIcode\fR
.NL
Indicates to the compiler a feature set that it may target, including which instruction sets and optimizations it may generate. Many of the following descriptions refer to Intel(R) Streaming SIMD Extensions (Intel(R) SSE) and Supplemental Streaming SIMD Extensions (Intel(R) SSSE). Possible values are:
.RS
.TP 15
CORE\-AVX2
May generate Intel(R) Advanced Vector Extensions 2 (Intel(R) AVX2), Intel(R) AVX, SSE4.2, SSE4.1, SSE3, SSE2, SSE, and SSSE3 instructions for Intel(R) processors.  Optimizes for Intel(R) processors that support Intel(R) AVX2 instructions.
.TP 15
CORE\-AVX\-I
May generate Float\-16 conversion instructions and the RDRND instruction, Intel(R) Advanced Vector Extensions (Intel(R) AVX), Intel(R) SSE4.2, SSE4.1, SSE3, SSE2, SSE, and SSSE3 instructions for Intel(R) processors. Optimizes for Intel(R) processors that support Float\-16 conversion instructions and the RDRND instruction.
.TP 15
AVX
May generate Intel(R) Advanced Vector Extensions (Intel(R) AVX), Intel(R) SSE4.2, SSE4.1, SSE3, SSE2, SSE, and SSSE3 instructions for Intel(R) processors. Optimizes for Intel processors that support Intel(R) AVX instructions. 
.TP 15
SSE4.2
May generate Intel(R) SSE4 Efficient Accelerated String and Text Processing instructions, Intel(R) SSE4 Vectorizing Compiler and Media Accelerator, and Intel(R) SSE3, SSE2, SSE, and SSSE3 instructions for Intel(R) processors. Optimizes for Intel processors that support Intel(R) SSE4.2 instructions.
.TP 15
SSE4.1
May generate Intel(R) SSE4 Vectorizing Compiler and Media Accelerator instructions for Intel(R) processors. May generate Intel(R), SSE3, SSE2, SSE, and SSSE3 instructions for Intel processors that support Intel(R) SSE4.1 instructions.
.TP 15
SSE3_ATOM
This option setting is deprecated. It has the same effect as specifying SSSE3_ATOM.
.TP 15
SSSE3_ATOM
May generate MOVBE instructions for Intel(R) processors, depending on the setting of option \-minstruction (Linux* OS and OS X*) or /Qinstruction (Windows* OS). May also generate SSSE3, Intel(R) SSE3, SSE2, and SSE instructions for Intel processors. Optimizes for Intel processors that support MOVBE instructions.
.TP 15
SSSE3
May generate SSSE3 and Intel(R) SSE3, SSE2, and SSE instructions for Intel(R) processors. Optimizes for Intel processors that support SSSE3 instructions. For OS X* systems, this value is only supported on Intel(R) 64 architecture. This replaces value T, which is deprecated.
.TP 15
SSE3
May generate Intel(R) SSE3, SSE2, and SSE instructions for Intel(R) processors. Optimizes for Intel processors that support  Intel(R) SSE3 instructions. For OS X* systems, this value is only supported on IA\-32 architecture. This replaces value P, which is deprecated.
.TP 15
SSE2
May generate Intel(R) SSE2 and SSE instructions for Intel(R) processors. Optimizes for Intel processors that support Intel(R) SSE2 instructions.  This value is not available on OS X*  systems.
This replaces value N, which is deprecated.
.RE
.IP
You can also specify
Host. For more information, see option \-xHost (Linux* OS and OS X*) or /QxHost (Windows* OS).
.TP
\fBDefault:\fR 
.TP 18
Windows* systems: None Linux* systems: None OS X* systems using IA\-32 architecture: SSE3 OS X* systems using Intel(R) 64 architecture: SSSE3
.NL
On Windows systems, if neither /Qx nor /arch is specified, the
default is /arch:SSE2.
.IP
On Linux systems, if neither \-x nor \-m is specified, the default
is \-msse2.
.TP
\fBDescription:\fR 
.PP
This option tells the compiler which processor features it may target, including which instruction sets and optimizations it may generate. It also enables optimizations in addition to Intel feature\-specific optimizations. 
.NL
.PP
The specialized code generated by this option may only run on a subset of Intel(R) processors.
.NL
.PP
The resulting executables created from these option \fIcode\fR values can only be run on
Intel(R) processors  that support the
indicated instruction set.
.NL
.PP
The binaries produced by these \fIcode\fR values will run on
Intel(R) processors that support the  specified
features.
.NL
.PP
Do not use \fIcode\fR values to create binaries that will execute on a processor that is not compatible with the targeted processor. The resulting program may fail with an illegal instruction exception or display other unexpected behavior. 
.NL
.PP
Compiling the function main() with any of the \fIcode\fR values produces binaries that display a fatal run\-time error if they are executed on unsupported processors, including all non\-Intel processors. 
.NL
.PP
Compiler options m and arch produce binaries that should run on processors not made by Intel that implement the same capabilities as the corresponding Intel(R) processors.
.NL
.PP
Previous value O is deprecated and has been replaced by option \-msse3 (Linux* OS and OS X*) and option /arch:SSE3 (Windows* OS).
.NL
.PP
Previous values W and K are deprecated.  The details on replacements are as follows:
.NL
.IP \(bu 2
OS X systems: On these systems, there is no exact replacement for W or K. You can upgrade to the default option \-msse3 (IA\-32 architecture) or option \-mssse3 (Intel(R) 64 architecture).
.IP \(bu 2
Windows and Linux systems: The replacement for W is \-msse2 (Linux OS) or /arch:SSE2 (Windows OS). There is no exact replacement for K. However, on Windows systems, /QxK is interpreted as /arch:IA32; on Linux systems,
\-xK is interpreted as \-mia32. You can also do one of the following:  
.RS
.IP \(bu 2
Upgrade to option \-msse2 (Linux OS) or option /arch:SSE2 (Windows OS). This will produce one code path that is specialized for Intel(R) SSE2. It will not run on earlier processors.
.IP \(bu 2
Specify the two option combination \-mia32 \-axSSE2 (Linux OS) or /arch:IA32 /QaxSSE2 (Windows OS). This combination will produce an executable that runs on any processor with IA\-32 architecture but with an additional specialized Intel(R) SSE2 code path.
.RE
.PP
The \-x and /Qx options enable additional optimizations not enabled with options \-m or /arch (nor with options –ax and /Qax). 
.NL
.PP
On Windows* systems, options /Qx
and /arch are mutually exclusive.
If both are specified, the compiler uses the last one specified and
generates a warning. Similarly, on Linux* and OS X* systems, options \-x
and \-m
are mutually
exclusive. If both are specified, the compiler uses the last one
specified and generates a warning.
.NL
.PP
.TP 18
\fBOptimization Notice 
\fR
.NL
.NL
.TP 18
= = = = = = = = = = 
.TP 18
Intel\[aq]s compilers may or may not optimize to the same degree for non\-Intel microprocessors for optimizations that are not unique to Intel microprocessors. These optimizations include SSE2, SSE3, and SSSE3 instruction sets and other optimizations. Intel does not guarantee the availability, functionality, or effectiveness of any optimization on microprocessors not manufactured by Intel. Microprocessor\-dependent optimizations in this product are intended for use with Intel microprocessors. Certain optimizations not specific to Intel microarchitecture are reserved for Intel microprocessors. Please refer to the applicable product User and Reference Guides for more information regarding the specific instruction sets covered by this notice. 
.TP 18
Notice revision #20110804 
.TP 18
= = = = = = = = = = 
.NL
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-X
.RS
.TP
Removes standard directories from the include file search path.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
Standard directories are in the include file search path.
.TP
\fBDescription:\fR 
.PP
This option removes standard directories from the include file search path. It prevents the compiler from searching the default path specified by the INCLUDE environment variable.
.NL
.PP
On Linux* and OS X* systems, specifying \-X (or \-noinclude) prevents the compiler from searching in /usr/include for files specified in an INCLUDE statement. 
.NL
.PP
You can use this option with the I option to prevent the compiler from searching the default path for include files and direct it to use an alternate path.
.NL
.TP
\fBAlternate Options:\fR 
.PP
Linux and OS X: \-nostdinc
.NL
.RE
.TP
.B
\-xHost
.RS
.TP
Tells the compiler to generate instructions for the highest instruction set
available on the compilation host processor.
.NL
.TP
\fBArchitectures:\fR IA\-32, Intel(R) 64 architecture
.TP
\fBArguments:\fR 
.PP
None
.NL
.TP
\fBDefault:\fR 
.TP 18
Windows* systems: None Linux* systems: None OS X* systems using IA\-32 architecture: \-xSSE3 OS X* systems using Intel(R) 64 architecture: \-xSSSE3
.NL
On Windows systems, if neither /Qx nor /arch is specified, the
default is /arch:SSE2.
.IP
On Linux systems, if neither \-x nor \-m is specified, the default
is \-msse2.
.TP
\fBDescription:\fR 
.PP
This option tells the compiler to generate instructions for the highest instruction set
available on the compilation host processor.
.NL
.PP
The instructions generated by this compiler option differ
depending on the compilation host processor. 
.NL
.PP
The following table
describes the effects of specifying  the \-xHost (Linux* OS and OS X*) or /QxHost (Windows* OS) option and it tells whether the
resulting executable will run on processors different from the host
processor.
.NL
.PP
Descriptions in the table refer to Intel(R) Advanced Vector Extensions 2 (Intel(R) AVX2), Intel(R)
Advanced Vector Extensions (Intel(R) AVX), Intel(R) Streaming SIMD
Extensions (Intel(R) SSE), and Supplemental Streaming SIMD
Extensions (SSSE).
.NL
.TP 18
\fBInstruction Set of Host Processor\fR
.NL
.NL
\fBEffects When the \-xHost or /QxHost Compiler Option is Specified\fR
.NL
.NL
.TP 18
Intel(R) AVX2
.NL
When compiling on Intel(R) processors:
.TP 18
Corresponds to option \-xCORE\-AVX2 (Linux* OS and OS X*) or /QxCORE\-AVX2 (Windows* OS). The generated executable will not run on non\-Intel processors and it will not run on Intel(R) processors that do not support Intel(R) AVX2 instructions.
.TP 18
When compiling on non\-Intel processors:
.TP 18
Corresponds to option \-march=core\-avx2 (Linux OS and OS X) or /arch:CORE\-AVX2 (Windows OS). The 
generated executable will run on Intel(R) processors and non\-Intel processors that 
support at least Intel(R) AVX2 instructions..  You may see a run\-time error if the run\-time processor does not 
support Intel(R) AVX2 instructions.
.NL
.TP 18
Intel(R) AVX
.NL
When compiling on Intel(R) processors:
.TP 18
Corresponds to option \-xAVX (Linux* OS and OS X*) or /QxAVX (Windows* OS). The generated executable will not run on non\-Intel processors and it will not run on Intel(R) processors that do not support Intel(R) AVX instructions.
.TP 18
When compiling on non\-Intel processors:
.TP 18
Corresponds to option \-mavx (Linux OS and OS X) or /arch:AVX (Windows OS). The 
generated executable will run on Intel(R) processors and non\-Intel processors that 
support at least Intel(R) AVX instructions.  You may see a run\-time error if the run\-time processor does not 
support Intel(R) AVX instructions.
.NL
.TP 18
Intel(R) SSE4.2
.NL
When compiling on Intel(R) processors:
.TP 18
Corresponds to option \-xSSE4.2 (Linux* OS and OS X*) or /QxSSE4.2
(Windows* OS). The generated executable will not run on non\-Intel processors and
it will not run on Intel(R) processors that do not support Intel(R)
SSE4.2 instructions.
.TP 18
When compiling on non\-Intel processors:
.TP 18
Corresponds to option \-msse4.2 (Linux OS and OS X) or /arch:SSE4.2
(Windows OS). The generated executable will run on Intel(R) processors and
non\-Intel processors that support at least Intel(R)
SSE4.2 instructions. You may see a run\-time
error if the run\-time processor does not support Intel(R) SSE4.2 instructions.
.NL
.TP 18
Intel(R) SSE4.1
.NL
When compiling on Intel(R) processors:
.TP 18
Corresponds to option \-xSSE4.1 (Linux* OS and OS X*) or /QxSSE4.1
(Windows* OS). The generated executable will not run on non\-Intel processors and
it will not run on Intel(R) processors that do not support Intel(R)
SSE4.1 instructions.
.TP 18
When compiling on non\-Intel processors:
.TP 18
Corresponds to option \-msse4.1 (Linux OS and OS X) or /arch:SSE4.1
(Windows OS). The generated executable will run on Intel(R) processors and
non\-Intel processors that support at least Intel(R)
SSE4.1 instructions. You may see a run\-time
error if the run\-time processor does not support Intel(R) SSE4.1
instructions.
.NL
.TP 18
SSSE3
.NL
When compiling on Intel(R) processors:
.TP 18
Corresponds to option \-xSSSE3 (Linux* OS and OS X*) or /QxSSSE3
(Windows* OS). The generated executable will not run on non\-Intel processors and
it will not run on Intel(R) processors that do not support SSSE3 instructions.
.TP 18
When compiling on non\-Intel processors:
.TP 18
Corresponds to option \-mssse3 (Linux OS and OS X) or /arch:SSSE3
(Windows OS). The generated  executable will run on Intel(R) processors and
non\-Intel processors that support at least SSSE3 instructions. You may see a run\-time
error if the run\-time processor does not support SSSE3
instructions.
.NL
.TP 18
Intel(R) SSE3
.NL
When compiling on Intel(R) processors:
.TP 18
Corresponds to option \-xSSE3 (Linux* OS and OS X*) or /QxSSE3
(Windows* OS). The generated executable will not run on non\-Intel processors and
it will not run on Intel(R) processors that do not support Intel(R)
SSE3 instructions.
.TP 18
When compiling on non\-Intel processors:
.TP 18
Corresponds to option \-msse3 (Linux OS and OS X) or /arch:SSE3
(Windows OS). The generated executable will run on Intel(R) processors and
non\-Intel processors that support at least Intel(R)
SSE3 instructions. You may see a warning run\-time error if the run\-time processor does not
support Intel(R) SSE3 instructions.
.NL
.TP 18
Intel(R) SSE2
.NL
When compiling on Intel(R) processors or non\-Intel processors:
.TP 18
Corresponds to option \-msse2 (Linux* OS and OS X*) or /arch:SSE2
(Windows* OS). The generated executable will run on Intel(R) processors and
non\-Intel processors that support at least Intel(R)
SSE2 instructions. You may see a run\-time
error if the run\-time processor does not support Intel(R) SSE2
instructions.
.NL
.PP
For more information on other settings for option \-x (Linux* OS and OS X*) and /Qx (Windows* OS), see that option description.
.NL
.PP
.TP 18
\fBOptimization Notice 
\fR
.NL
.NL
.TP 18
= = = = = = = = = = 
.TP 18
Intel\[aq]s compilers may or may not optimize to the same degree for non\-Intel microprocessors for optimizations that are not unique to Intel microprocessors. These optimizations include SSE2, SSE3, and SSSE3 instruction sets and other optimizations. Intel does not guarantee the availability, functionality, or effectiveness of any optimization on microprocessors not manufactured by Intel. Microprocessor\-dependent optimizations in this product are intended for use with Intel microprocessors. Certain optimizations not specific to Intel microarchitecture are reserved for Intel microprocessors. Please refer to the applicable product User and Reference Guides for more information regarding the specific instruction sets covered by this notice. 
.TP 18
Notice revision #20110804 
.TP 18
= = = = = = = = = = 
.NL
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-Xlinker option
.RS
.TP
Passes a linker option directly to the linker.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.TP 18
\fIoption\fR
.NL
Is a linker option.
.TP
\fBDefault:\fR 
.TP 18
OFF
.NL
No options are passed directly to the linker.
.TP
\fBDescription:\fR 
.PP
This option passes a linker option directly to the linker.
If \-Xlinker \-shared is specified, only \-shared is passed to the linker and no special work is done to ensure proper linkage for generating a shared object. \-Xlinker just takes whatever arguments are supplied and passes them directly to the linker.
.NL
.PP
If you want to pass compound options to the linker, for example "\-L $HOME/lib", you must use the following method:
.NL
.PP
\-Xlinker \-L \-Xlinker $HOME/lib
.PP
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.TP
.B
\-Zp[n]
.RS
.TP
Specifies alignment for structures on byte boundaries.
.NL
.TP
\fBArchitectures:\fR All
.TP
\fBArguments:\fR 
.TP 18
\fIn\fR
.NL
Is the byte size boundary. Possible values are 1, 2, 4, 8, or 16.
.TP
\fBDefault:\fR 
.TP 18
Zp16
.NL
Structures are aligned on either size boundary 16 or the boundary that will naturally align them.
.TP
\fBDescription:\fR 
.PP
This option specifies alignment for structures on byte boundaries. 
.NL
.PP
If you do not specify \fIn\fR, you get Zp16.
.NL
.TP
\fBAlternate Options:\fR 
.PP
None
.NL
.RE
.SH PREDEFINED MACROS 
.PP
The Intel(R) C++ Compiler documentation describes the predefined macros in detail. This section provides a brief summary of the supported macros. 
.PP
The ANSI/ISO standard for C language requires that certain predefined macros be supplied with conforming compilers. The GNU* gcc predefined macros are all set depending on what version of gcc is found on the user\[aq]s system. (This is overridden if the 
\-gcc\-version compiler option is passed on the command line.) 
.PP
You can specify the 
\-no\-gcc option if you do not want these macros defined. If you need gcc interoperability (\-cxxlib), do not use the 
\-no\-gcc compiler option. 
.PP
You can use the 
\-U option to suppress an automatic definition of a predefined macro. This option suppresses any macro definition currently in effect for the specified name. This option performs the same function as an 
#undef preprocessor directive. 
.PP
The following table lists the predefined macros on Linux* OS systems based on either the IA\-32 or Intel(R) 64 architecture. 
.NL
.PP
.TP 18
\fBMacro 
\fR
.NL
.NL
\fBValue 
\fR
.NL
.NL
.TP 18
__ARRAY_OPERATORS
.NL
1 
.NL
.TP 18
__BASE_FILE__
.NL
Name of source file 
.NL
.TP 18
_BOOL
.NL
1 
.NL
.TP 18
__cilk
.NL
200; however, if 
\-cilk\-serialize or 
\-no\-intel\-extensions is specified, the value is undefined. 
.NL
.TP 18
__cplusplus
.NL
1 (with C++ compiler) 
.NL
.TP 18
__DEPRECATED
.NL
1 
.NL
.TP 18
__EDG__
.NL
1 
.NL
.TP 18
__EDG_VERSION__
.NL
EDG version 
.NL
.TP 18
__ELF__
.NL
1 
.NL
.TP 18
__extension__
.NL
  
.NL
.TP 18
__EXCEPTIONS
.NL
Defined as 1 when 
\-fno\-exceptions is not used. 
.NL
.TP 18
__GNUC__
.NL
The major version number of gcc installed on the system. 
.NL
.TP 18
__GNUG__
.NL
The major version number of g++ installed on the system. 
.NL
.TP 18
__gnu_linux__
.NL
1 
.NL
.TP 18
__GNUC_MINOR__
.NL
The minor version number of gcc or g++ installed on the system. 
.NL
.TP 18
__GNUC_PATCHLEVEL__
.NL
The patch level version number of gcc or g++ installed on the system. 
.NL
.TP 18
__GXX_ABI_VERSION
.NL
102 
.NL
.TP 18
__HONOR_STD
.NL
1 
.NL
.TP 18
__i386
.TP 18
Available only on systems based on IA\-32 architecture. 
.NL
1 
.NL
.TP 18
__i386__
.TP 18
Available only on systems based on IA\-32 architecture. 
.NL
1 
.NL
.TP 18
i386
.TP 18
Available only on systems based on IA\-32 architecture. 
.NL
1 
.NL
.TP 18
__ICC
.NL
Intel(R) C++ compiler version 
.NL
.TP 18
__INTEL_COMPILER
.NL
Intel(R) C++ compiler version 
.NL
.TP 18
__INTEL_COMPILER_BUILD_DATE
.NL
YYYYMMDD 
.NL
.TP 18
__INTEL_RTTI__
.NL
Defined as 1 when 
\-fno\-rtti is not specified. 
.NL
.TP 18
__INTEL_STRICT_ANSI__
.NL
Defined as 1 when 
\-strict\-ansi is specified. 
.NL
.TP 18
__linux
.NL
1 
.NL
.TP 18
__linux__
.NL
1 
.NL
.TP 18
linux
.NL
1 
.NL
.TP 18
__LONG_DOUBLE_SIZE__
.NL
80 
.NL
.TP 18
__LONG_MAX__
.TP 18
Available only on systems based on Intel(R) 64 architecture. 
.NL
9223372036854775807L 
.NL
.TP 18
__LP64__
.TP 18
Available only on systems based on Intel(R) 64 architecture. 
.NL
1 
.NL
.TP 18
_LP64
.TP 18
Available only on systems based on Intel(R) 64 architecture. 
.NL
1 
.NL
.TP 18
_MT
.TP 18
Available only on systems based on Intel(R) 64 architecture. 
.NL
1 
.NL
.TP 18
__MMX__
.TP 18
Available only on systems based on Intel(R) 64 architecture. 
.NL
1 
.NL
.TP 18
__NO_INLINE__
.NL
1 
.NL
.TP 18
__NO_MATH_INLINES
.NL
1 
.NL
.TP 18
__NO_STRING_INLINES
.NL
1 
.NL
.TP 18
_OPENMP
.NL
Defined as 200805 when 
\-openmp is specified. 
.NL
.TP 18
__OPTIMIZE__
.NL
1 
.NL
.TP 18
__pentium4
.NL
1 
.NL
.TP 18
__pentium4__
.NL
1 
.NL
.TP 18
__PIC__
.NL
Defined as 1 when 
\-fPIC is specified. 
.NL
.TP 18
__pic__
.NL
Defined as 1 when 
\-fPIC is specified. 
.NL
.TP 18
_PGO_INSTRUMENT
.NL
Defined as 1 when 
\-prof\-gen[x] is specified. 
.NL
.TP 18
_PLACEMENT_DELETE
.NL
1 
.NL
.TP 18
__PTRDIFF_TYPE__
.NL
int on IA\-32 architecture; 
long on Intel(R) 64 architecture 
.NL
.TP 18
__REGISTER_PREFIX__
.NL
  
.NL
.TP 18
__SIGNED_CHARS__
.NL
1 
.NL
.TP 18
__SIZE_TYPE__
.NL
unsigned on IA\-32 architecture ; unsigned long on Intel(R) 64 architecture 
.NL
.TP 18
__SSE__
.NL
Defined as 1 for processors that support Intel(R) SSE instructions. 
.NL
.TP 18
__SSE2__
.NL
Defined as 1 for processors that support Intel(R) SSE2 instructions. 
.NL
.TP 18
__SSE3__
.NL
Defined as 1 for processors that support Intel(R) SSE3 instructions. 
.NL
.TP 18
__SSSE3__
.NL
Defined as 1 for processors that support SSSE3 instructions. 
.NL
.TP 18
__SSE4_1__
.NL
Defined as 1 for processors that support Intel(R) SSE4 instructions. 
.NL
.TP 18
__ SSE4_2__
.NL
Defined as 1 for processors that support SSSE4 instructions. 
.NL
.TP 18
__unix
.NL
1 
.NL
.TP 18
__unix__
.NL
1 
.NL
.TP 18
unix
.NL
1 
.NL
.TP 18
__USER_LABEL_PREFIX__
.NL
  
.NL
.TP 18
__VERSION__
.NL
Intel version string 
.NL
.TP 18
__WCHAR_T
.NL
1 
.NL
.TP 18
__WCHAR_TYPE__
.NL
long int on IA\-32 architecture ; int on Intel(R) 64 architecture 
.NL
.TP 18
__WINT_TYPE__
.NL
unsigned int
.NL
.TP 18
__x86_64
.TP 18
Available only on systems based on Intel(R) 64 architecture. 
.NL
1 
.NL
.TP 18
__x86_64__
.TP 18
Available only on systems based on Intel(R) 64 architecture. 
.NL
1 
.NL
.NL
.PP
The following table lists the predefined macros on OS X* systems based on either the IA\-32 or Intel(R) 64 architecture: 
.NL
.PP
.TP 18
\fBMacro Name (IA\-32 and Intel(R) 64 architecture) 
\fR
.NL
.NL
\fBValue 
\fR
.NL
.NL
.TP 18
__APPLE__
.NL
1 
.NL
.TP 18
__APPLE_CC__
.NL
gcc build number 
.NL
.TP 18
__DYNAMIC__
.NL
1 
.NL
.TP 18
__EDG__
.NL
1 
.NL
.TP 18
__EDG_VERSION__
.NL
Version of EDG 
.NL
.TP 18
__GNUC__
.NL
The major version number of gcc installed on the system. 
.NL
.TP 18
__GNUG__
.NL
The major version number of g++ installed on the system. 
.NL
.TP 18
__GNUC_MINOR__
.NL
The minor version number of gcc installed on the system. 
.NL
.TP 18
__GNUC_PATCHLEVEL__
.NL
The patch level version number of gcc installed on the system. 
.NL
.TP 18
__GXX_ABI_VERSION
.NL
ABI version 
.NL
.TP 18
__HONOR_STD
.NL
1 
.NL
.TP 18
i386
.TP 18
Available only on systems based on IA\-32 architecture. 
.NL
1 
.NL
.TP 18
__i386
.TP 18
Available only on systems based on IA\-32 architecture. 
.NL
1 
.NL
.TP 18
__i386__
.TP 18
Available only on systems based on IA\-32 architecture. 
.NL
1 
.NL
.TP 18
__ICC
.NL
Intel compiler version 
.NL
.TP 18
__INTEL_COMPILER
.NL
Intel compiler version 
.NL
.TP 18
__INTEL_COMPILER_BUILD_DATE
.NL
YYYYMMDD 
.NL
.TP 18
__INTEL_RTTI__
.NL
Defined as 1 when 
\-fno\-rtti is not specified. 
.NL
.TP 18
__INTEL_STRICT_ANSI__
.NL
Defined as 1 when 
\-strict\-ansi is specified. 
.NL
.TP 18
__LITTLE_ENDIAN__
.NL
1 
.NL
.TP 18
__LONG_DOUBLE_SIZE__
.NL
80 
.NL
.TP 18
__ LP64__ 
.TP 18
This macro tests in an architecture\-independent way if the LP64 data model is being used. 
.NL
Defined if 
ints are 32\-bits in size and 
long, 
long long, and pointers are 64\-bits in size. 
.NL
.TP 18
__MACH__
.NL
1 
.NL
.TP 18
__MMX__
.NL
1 
.NL
.TP 18
__NO_INLINE__
.NL
1 
.NL
.TP 18
__NO_MATH_INLINES
.NL
1 
.NL
.TP 18
__NO_STRING_INLINES
.NL
1 
.NL
.TP 18
_OPENMP 
.NL
Defined as 200805 when \-openmp is specified. 
.NL
.TP 18
__OPTIMIZE__
.NL
1 
.NL
.TP 18
__pentium4
.NL
1 
.NL
.TP 18
__pentium4__
.NL
1 
.NL
.TP 18
__PIC__
.NL
1 
.NL
.TP 18
__PTRDIFF_TYPE__
.NL
int / long
.NL
.TP 18
__QMSSP_
.NL
1 
.NL
.TP 18
__REGISTER_PREFIX__
.NL
  
.NL
.TP 18
__SIGNED_CHARS__
.NL
1 
.NL
.TP 18
__SIZE_TYPE__
.NL
unsigned long
.NL
.TP 18
__SSE__
.NL
Defined as 1 for processors that support SSE instructions. 
.NL
.TP 18
__SSE2__
.NL
Defined as 1 for processors that support SSE2 instructions. 
.NL
.TP 18
__SSE3__
.NL
Defined as 1 for processors that support SSE3 instructions. 
.NL
.TP 18
__SSSE3__
.NL
Defined as 1 for processors that support SSSE3 instructions. 
.NL
.TP 18
__STDC__
.NL
1 
.NL
.TP 18
__STDC_HOSTED__
.NL
1 
.NL
.TP 18
__USER_LABEL_PREFIX__
.NL
_ 
.NL
.TP 18
__VERSION__
.NL
Intel version string 
.NL
.TP 18
__WCHAR_MAX__
.NL
2147483647 
.NL
.TP 18
__WCHAR_TYPE__
.NL
long int
.NL
.TP 18
__WINT_TYPE__
.NL
unsigned int
.NL
.TP 18
__x86_64
.TP 18
Available only on systems based on Intel(R) 64 architecture. 
.NL
1 
.NL
.TP 18
__x86_64__
.TP 18
Available only on systems based on Intel(R) 64 architecture. 
.NL
1 
.NL
.NL
.SH ENVIRONMENT VARIABLES
.PP
You can customize your environment by setting environment variables.
.PP
The Intel(R) C++ Compiler installation includes shell scripts that you can use to set environment variables. For more information, see the Intel(R) C++ Compiler XE Documentation.
.PP
.TP 18
\fBEnvironment Variable 
\fR
.NL
.NL
\fBDescription 
\fR
.NL
.NL
.TP 18
CILK_NWORKERS (Linux* OS) 
.NL
Specifies the number of worker threads to use in an Intel(R) Cilk(TM) Plus program. 
.TP 18
See 
\fISet Worker Count\fR. 
.NL
.TP 18
DYLD_LIBRARY_PATH (OS X*) 
.NL
Specifies the location for shared objects. 
.NL
.TP 18
GCCROOT
.NL
Specifies the location of the gcc binaries. Set this variable only when the compiler cannot locate the gcc binaries when using the 
\-gcc\-name option. 
.NL
.TP 18
GXX_INCLUDE
.NL
Specifies the location of the gcc headers. Set this variable to specify the locations of the GCC installed files when the compiler does not find the needed values as specified by the use of the 
\-gcc\-name=\fI<directory\-name>\fR/gcc option. 
.NL
.TP 18
GXX_ROOT
.NL
Specifies the location of the gcc binaries. Set this variable to specify the locations of the GCC installed files when the compiler does not find the needed values as specified by the use of the 
\-gcc\-name=\fI<directory\-name>\fR/gcc option. 
.NL
.TP 18
IA32ROOT (IA\-32 architecture and Intel(R) 64 architecture) 
.NL
Points to the directories containing the include and library files for a non\-standard installation structure. 
.NL
.TP 18
ICCCFG
.NL
Specifies the configuration file for customizing compilations when invoking the compiler using 
icc. 
.NL
.TP 18
ICPCCFG
.NL
Specifies the configuration file for customizing compilations when invoking the compiler using 
icpc. 
.NL
.TP 18
INTEL_CHKP_REPORT_MODE 
(Linux* OS) 
.NL
Changes the pointer checker reporting mode at runtime. 
.TP 18
See 
\fIFinding and Reporting Out\-of\-Bounds Errors\fR. 
.NL
.TP 18
INTEL_LICENSE_FILE
.NL
Specifies the location for the Intel license file. 
.NL
.TP 18
LD_LIBRARY_PATH (Linux* OS)
.NL
Specifies the location for shared objects. 
.NL
.TP 18
PATH
.NL
Specifies the directories the system searches for binary executable files. 
.NL
.TP 18
PROF_DIR
.NL
Specifies the directory where profiling files (files with extensions .dyn, .dpi, .spi and so forth) are stored. The default is to store the .dyn files in the source directory of the file containing the first executed instrumented routine in the binary compiled with 
\-prof\-gen 
. 
.NL
.TP 18
PROF_DPI
.NL
Name for the .dpi file. The default is pgopti.dpi. 
.NL
.TP 18
TMP TMPDIR TEMP
.NL
Specifies the location for temporary files. If none of these are specified, the compiler stores temporary files in 
/tmp. 
.NL
.TP 18
\fB Intel(R) MIC Architecture Environment Variables\fR
.NL
.TP 18
MIC_ENV_PREFIX
.NL
Used to control environment variables passed to the coprocessor. 
.TP 18
By default, all environment variables set on the host are passed to the coprocessor. Setting 
MIC_ENV_PREFIX passes only environment variables that have a prefix of the value of this variable. For example, setting 
setenv MIC_ENV_PREFIX=MIC passes only environment variables that have a prefix of 
MIC. 
.TP 18
.PP
.B NOTE:
The 
MIC_LD_LIBRARY_PATH variable is not stripped and passed to the coprocessor, so you cannot use 
MIC_ENV_PREFIX=MIC to change the 
LD_LIBRARY_PATH on the coprocessor. 
.TP 18
For information on passing environment variables to a particular coprocessor, and on passing multiple environment variables to one or all coprocessors, see 
\fISetting Environment Variables on the CPU to Modify the Coprocessor\[aq]s Execution Environment\fR. 
.NL
.TP 18
MIC_HOST_LOG
.NL
A string containing the file name to output traces from the host. 
.TP 18
\fB Default:\fR None 
.TP 18
\fB  Example:\fRMIC_HOST_LOG=/home/user/app/host.log
.NL
.TP 18
MIC_LD_LIBRARY_PATH
.NL
Specifies the location for target shared objects. 
LD_LIBRARY_PATH specifies the location for host objects. 
.NL
.TP 18
MIC_PROXY_IO
.NL
Enables (1) or disables (0) the proxy of stderr and stdout, and specifies whether the process wants I/O proxy support between the host and coprocessor. 
.TP 18
\fB Default:\fR1
.TP 18
\fB  Example:\fRMIC_PROXY_IO=0
.NL
.TP 18
MIC_SEP_MONITOR
.NL
Enables (1) or disables (0) SEP at offload regions. 
.TP 18
\fB Default:\fR0
.TP 18
\fB  Example:\fRMIC_SEP_MONITOR=1
.NL
.TP 18
MIC_STACKSIZE
.NL
Specifies the stack size of the main thread for the offload. This value is typically much larger than the stack size for individual threads. It corresponds to what you would set with 
.B ulimit
\-s (BASH shell) or 
.B limit stacksize
(C shell) if you were running natively on either the coprocessor or the host. 
.TP 18
Set this variable to 
\fIinteger\fRB|K|M|G|T, where: 
.RS
.IP \(bu 2
\fIB\fR = bytes 
.IP \(bu 2
\fIK\fR = kilobytes 
.IP \(bu 2
\fIM\fR = megabytes 
.IP \(bu 2
\fIG\fR = gigabytes 
.IP \(bu 2
\fIT\fR = terabytes 
.RE
.TP 18
\fB Default: 
\fR12M
.TP 18
\fB  Example:\fRMIC_STACKSIZE=16M
.NL
.TP 18
MIC_USE_2MB_BUFFERS
.NL
Use 2M pages for (size > MIC_USE_2MB_BUFFERS). Pointer\-based variables whose runtime length exceeds the value of this variable will be allocated in large pages. 
.TP 18
Set this variable to 
\fIinteger\fRB|K|M|G|T, where: 
.RS
.IP \(bu 2
\fIB\fR = bytes 
.IP \(bu 2
\fIK\fR = kilobytes 
.IP \(bu 2
\fIM\fR = megabytes 
.IP \(bu 2
\fIG\fR = gigabytes 
.IP \(bu 2
\fIT\fR = terabytes 
.RE
.TP 18
\fB  Example:\fRMIC_USE_2MB_BUFFERS=64K
.NL
.TP 18
OFFLOAD_DEVICES
.NL
Restricts the offload process to use only the coprocessors specified as the value of the variable. 
.TP 18
Set this variable to a comma separated list of coprocessor device numbers in the range 0 to 
\fInumber_of_devices_in_the_system\fR\-1, where 0 is the first coprocessor in the system, and 
\fInumber_of_devices_in_the_system\fR\-1 is the last coprocessor in the system. 
.TP 18
Coprocessors available for offloading are numbered logically. The function 
_Offload_number_of_devices() 
returns the number of available coprocessors. Coprocessor indices that you use in the 
target specifier of the offload 
pragmas 
are in the range 0 to 
\fInumber_of_devices_in_the_system\fR\-1. 
.TP 18
\fB Default:\fR The offload process uses all devices.
.TP 18
\fB  Example:\fR OFFLOAD_DEVICES = 1,2 
.TP 18
On a system with more than two coprocessors installed, this setting enables the application to use only coprocessors 1 and 2. Offloads to coprocessors 0 or 1 are performed on the first and second physical coprocessors. Offloads to target numbers higher than 1 wrap\-around so that all offloads remain within coprocessors 0 and 1. The function 
_Offload_number_of_devices() 
executed on a coprocessor return 0 or 1, when the offload is running on the first or second coprocessor. 
.NL
.TP 18
OFFLOAD_INIT
.NL
Specifies a hint to the offload runtime when to initialize coprocessors. 
.TP 18
Supported values: 
.IP \(bu 2
on_start: All available coprocessors are initialized before entering main. 
.IP \(bu 2
on_offload: The coprocessor is initialized immediately before the first offload to it. Initialization is done only on the coprocessor that handles the offload. 
.IP \(bu 2
on_offload_all: All available coprocessors are initialized immediately before the first offload in an application. 
.TP 18
\fB Default:\fRon_offload_all
.TP 18
\fB  Example:\fROFFLOAD_INIT=on_start
.NL
.TP 18
OFFLOAD_REPORT
.NL
Controls printing offload execution time, in seconds, and the amount of data transferred, in bytes. This environment variable is equivalent to using the 
__Offload_report API. 
.TP 18
Supported values: 
.IP \(bu 2
1: Produces a report about time taken. 
.IP \(bu 2
2: In additon to the information produced at value 1, adds the amount of data transferred between the CPU and the coprocessor. 
.IP \(bu 2
3: In addition to the information produced at value 2, gives additional details on offload activity, including device initialization, and individual variable transfers. 
.TP 18
\fB Default:\fR None 
.TP 18
\fB  Example:\fROFFLOAD_REPORT=1
.TP 18
See also 
\fI __Offload_report\fR. 
.NL
.TP 18
\fB OpenMP* Environment Variables (OMP_) and Extensions (KMP_) 
\fR
.NL
.TP 18
KMP_AFFINITY
.NL
Enables run\-time library to bind threads to physical processing units. 
.TP 18
\fB Default: 
\fRnone 
.TP 18
This environment variable is available for both Intel and non\-Intel microprocessors but it may perform additional optimizations for Intel microprocessors than it performs for non\-Intel microprocessors. 
.NL
.TP 18
KMP_ALL_THREADS
.NL
Limits the number of simultaneously executing threads in an OpenMP* program. If this limit is reached and another native operating system thread encounters OpenMP* API calls or constructs, then the program may abort with an error message. If this limit is reached at the time an OpenMP parallel region begins, a one\-time warning message may be generated indicating that the number of threads in the team was reduced, but the program will continue execution. 
.TP 18
This environment variable is only used for programs compiled with 
\-openmp . 
.TP 18
\fB Default:\fR No enforced limit 
.NL
.TP 18
KMP_BLOCKTIME
.NL
Sets the time, in milliseconds, that a thread should wait, after completing the execution of a parallel region, before sleeping. 
.TP 18
Use the optional character suffixes: 
s (seconds), 
m (minutes), 
h (hours), or 
d (days) to specify the units. 
.TP 18
\fB Default: 
\fR200 milliseconds 
.NL
.TP 18
KMP_CPUINFO_FILE
.NL
Specifies an alternate file name for file containing machine topology description. The file must be in the same format as 
/proc/cpuinfo. 
.TP 18
This environment variable is available for both Intel and non\-Intel microprocessors but it may perform additional optimizations for Intel microprocessors than it performs for non\-Intel microprocessors. 
.TP 18
\fB Default: 
\fRNone 
.NL
.TP 18
KMP_DETERMINISTIC_REDUCTIONS
.NL
Enables (1) or disables (0) the use of a specific ordering of the reduction operations for implementing the reduction clause for an OpenMP* parallel region. This has the effect that, for a given number of threads, in a given parallel region, for a given data set and reduction operation, a floating point reduction done for an OpenMP reduction clause will have a consistent floating point result from run to run, since round\-off errors will be identical. 
.TP 18
\fB Default:\fR0
.NL
.TP 18
KMP_DYNAMIC_MODE
.NL
Selects the method used to determine the number of threads to use for a parallel region when 
OMP_DYNAMIC=true. Possible values: (asat | load_balance | thread_limit), where, 
.IP \(bu 2
asat: estimates number of threads based on parallel start time; 
.IP \(bu 2
load_balance: tries to avoid using more threads than available execution units on the machine; 
.IP \(bu 2
thread_limit: tries to avoid using more threads than total execution units on the machine. 
.TP 18
\fB Default: For IA\-32 architecture: 
\fRload_balance (on all supported OSes) 
.TP 18
\fB Default: For Intel(R) MIC architecture:\fR thread_limit 
(on supported OSes) 
.NL
.TP 18
KMP_INHERIT_FP_CONTROL
.NL
Enables (1) or disables (0) the copying of the floating point control settings of the master thread to the floating point control settings of the OpenMP* worker threads at the start of each parallel region. 
.TP 18
\fB Default:\fR1
.NL
.TP 18
KMP_LIBRARY
.NL
Selects the OpenMP run\-time library execution mode. The values for this variable are 
serial, 
turnaround, or 
throughput (default). 
.NL
.TP 18
KMP_MONITOR_STACKSIZE
.NL
Sets the number of bytes to allocate for the monitor thread, which is used for book\-keeping during program execution. 
.TP 18
Use the optional suffixes: 
b (bytes), 
k (kilobytes), 
m (megabytes), 
g (gigabytes), or 
t (terabytes) to specify the units. 
.TP 18
\fB Default: 
\fRmax (32k, system minimum thread stack size) 
.NL
.TP 18
KMP_SETTINGS
.NL
Enables (1) or disables (0) the printing of OpenMP run\-time library environment variables during program execution. Two lists of variables are printed: user\-defined environment variables settings and effective values of variables used by OpenMP run\-time library. 
.TP 18
\fB Default: 
\fR0 
.NL
.TP 18
KMP_STACKSIZE
.NL
Sets the number of bytes to allocate for each OpenMP* thread to use as its private stack. Recommended size is 16m. Use the optional suffix b, k, m, g, or t, to specify bytes, kilobytes, megabytes, gigabytes, or terabytes.This variable does not affect the native operating system threads created by the user program nor the thread executing the sequential part of an OpenMP* program or parallel programs created using 
\fI\-parallel\fR (Linux and OS X) or 
\fI/Qparallel\fR (Windows). Default: IA\-32 architecture: 2m, Intel(R) 64 architecture: 4m. 
.NL
.TP 18
KMP_VERSION
.NL
Enables (1) or disables (0) the printing of OpenMP run\-time library version information during program execution. 
.TP 18
\fB Default:\fR disabled. 
.NL
.TP 18
OMP_DYNAMIC
.NL
Enables (1) or disables (0) the dynamic adjustment of the number of threads. 
.TP 18
\fB Default: 
\fR
.TP 18
0 
.TP 18
Example syntax: 
.TP 18
export OMP_DYNAMIC=value
.NL
.TP 18
OMP_MAX_ACTIVE_LEVELS
.NL
Limits the number of simultaneously executing threads in an OpenMP program. 
.TP 18
If this limit is reached and another native operating system thread encounters OpenMP API calls or constructs, the program can abort with an error message. If this limit is reached when an OpenMP parallel region begins, a one\-time warning message might be generated indicating that the number of threads in the team was reduced, but the program will continue. 
.TP 18
This environment variable is only used for programs compiled with the following options: 
\fI\-openmp\fR or 
\fI\-parallel\fR (Linux and OS X) and 
\fI/Qopenmp\fR or 
\fI/Qparallel\fR (Windows). 
.TP 18
omp_get_thread_limit() routine returns the value of the limit. 
.TP 18
\fB Default:\fR No enforced limit 
.TP 18
\fB Related environment variable:\fRKMP_ALL_THREADS. 
OMP_THREAD_LIMIT overrides 
KMP_ALL_THREADS. 
.TP 18
\fB Example syntax:\fR
.TP 18
export OMP_MAX_ACTIVE_LEVELS=value
.NL
.TP 18
OMP_NESTED
.NL
Enables (1) or disables (0)nested parallelism. 
.TP 18
\fB Default:\fR
.TP 18
0 
.TP 18
\fB Example syntax: 
\fR
.TP 18
export OMP_NESTED=value
.NL
.TP 18
OMP_NUM_THREADS
.NL
Sets the maximum number of threads to use for OpenMP* parallel regions if no other value is specified in the application. 
.TP 18
This environment variable applies to both 
\fI\-openmp\fR and 
\fI\-parallel\fR (Linux OS and OS X) or 
\fI/Qopenmp\fR and 
\fI/Qparallel\fR (Windows OS). 
.TP 18
\fB Default:\fR Number of processors visible to the operating system. 
.TP 18
\fB Example syntax:\fR
.TP 18
export OMP_NUM_THREADS=value
.NL
.TP 18
OMP_PROC_BIND
.NL
Enables (true) or disables (false) the binding of threads to processor contexts. If enabled, this is the same as specifying 
KMP_AFFINITY=\fIscatter\fR. If disabled, this is the same as specifying 
KMP_AFFINITY=\fInone\fR. If both 
OMP_PROC_BIND and 
KMP_AFFINITY are specified, 
KMP_AFFINITY settings take precedence. 
GOMP_CPU_AFFINITY also takes precedence over 
OMP_PROC_BIND. 
.TP 18
\fB Default:\fRfalse
.TP 18
This environment variable is not supported on the OS X* operating system. 
.NL
.TP 18
OMP_SCHEDULE
.NL
Sets the run\-time schedule type and an optional chunk size. 
.TP 18
\fB Default:\fRSTATIC, no chunk size specified 
.TP 18
\fB Example syntax: 
\fR
.TP 18
export OMP_SCHEDULE="kind[,chunk_size]"
.TP 18
This environment variable is available for both Intel and non\-Intel microprocessors but it may perform additional optimizations for Intel microprocessors than it performs for non\-Intel microprocessors. 
.NL
.TP 18
OMP_STACKSIZE
.NL
Sets the number of bytes to allocate for each OpenMP thread to use as the private stack for the thread. 
.TP 18
Recommended size is 16M. 
.TP 18
Use the optional suffixes: B (bytes), K (Kilobytes), M (Megabytes), G (Gigabytes), or T (Terabytes) to specify the units. If only value is specified and B, K, M, G, or T is not specified, then size is assumed to be K (Kilobytes). 
.TP 18
This variable does not affect the native operating system threads created by the user program nor the thread executing the sequential part of an OpenMP program or parallel programs created using 
\fI\-parallel\fR (Linux OS and OS X) or 
\fI/Qparallel\fR (Windows). 
.TP 18
kmp_{set,get}_stacksize_s() routines set/retrieve the value. 
kmp_set_stacksize_s() routine must be called from sequential part, before first parallel region is created. Otherwise, calling 
kmp_set_stacksize_s() has no effect. 
.TP 18
\fB Default for IA\-32 architecture:\fR 2M Default for Intel(R) 64architecture: 4M 
.TP 18
\fB Related environment variables:\fRKMP_STACKSIZE. 
KMP_STACKSIZE overrides 
OMP_STACKSIZE. 
.TP 18
\fB Example syntax: 
\fR
.TP 18
export OMP_STACKSIZE=value
.NL
.TP 18
OMP_THREAD_LIMIT
.NL
Limits the number of simultaneously executing threads in an OpenMP* program. 
.TP 18
If this limit is reached and another native operating system thread encounters OpenMP* API calls or constructs, the program can abort with an error message. If this limit is reached when an OpenMP parallel region begins, a one\-time warning message might be generated indicating that the number of threads in the team was reduced, but the program will continue. 
.TP 18
This environment variable is only used for programs compiled with the following options: \-\fIopenmp\fR or 
.TP 18
\fI\-parallel\fR (Linux OS and OS X) and 
\fI/Qopenmp\fR or 
\fI/Qparallel\fR (Windows OS). 
.TP 18
omp_get_thread_limit() routine returns the value of the limit. 
.TP 18
\fB Default:\fR No enforced limit 
.TP 18
\fB Related environment variable:\fR KMP_ALL_THREADS. Its value overrides OMP_THREAD_LIMIT. 
.TP 18
\fB Example syntax:\fR
.TP 18
export OMP_THREAD_LIMIT=value
.NL
.TP 18
OMP_WAIT_POLICY
.NL
Decides whether threads spin (active) or sleep (passive) while they are waiting. 
\fB Default: 
\fRPassive 
.TP 18
\fB Example syntax:\fR
.TP 18
export OMP_WAIT_POLICY=value
.NL
.TP 18
\fB GNU* Environment Variables and Extensions\fR
.NL
.TP 18
CPATH
.NL
Specifies path to include directory for C/C++ compilations. 
.NL
.TP 18
C_INCLUDE_PATH
.NL
Specifies path to include directory for C compilations. 
.NL
.TP 18
CPLUS_INCLUDE_PATH
.NL
Specifies path to include directory for C++ compilations. 
.NL
.TP 18
DEPENDENCIES_OUTPUT
.NL
Specifies how to output dependencies for make based on the non\-system header files processed by the compiler. System header files are ignored in the dependency output. 
.NL
.TP 18
GCC_EXEC_PREFIX
.NL
Specifies alternative names for the linker (ld) and assembler (as). 
.NL
.TP 18
GOMP_CPU_AFFINITY
.NL
Specifies a list of OS processor IDs. 
.TP 18
\fB Default:\fR Affinity is disabled 
.NL
.TP 18
GOMP_STACKSIZE
.NL
This environment variable is a GNU extension recognized by the Intel OpenMP compatibility library. 
.TP 18
OMP_STACKSIZE overrides GOMP_STACKSIZE. KMP_STACKSIZE overrides OMP_STACKSIZE and GOMP_STACKSIZE 
.NL
.TP 18
LIBRARY_PATH
.NL
Specifies a colon\-separated list of directories, much like 
PATH. 
.NL
.TP 18
SUNPRO_DEPENDENCIES
.NL
This variable is the same as 
DEPENDENCIES_OUTPUT, except that system header files are not ignored. 
.NL
.TP 18
\fB PGO Environment Variables 
\fR
.NL
.TP 18
INTEL_PROF_DUMP_CUMULATIVE
.NL
When using interval profile dumping (initiated by 
INTEL_PROF_DUMP_INTERVAL or the function 
_PGOPTI_Set_Interval_Prof_Dump) during the execution of an instrumented user application, allows creation of a single .dyn file to contain profiling information instead of multiple .dyn files. If this environment variable is not set, executing an instrumented user application creates a new .dyn file for each interval. Setting this environment variable is useful for applications that do not terminate or those that terminate abnormally (bypass the normal exit code). 
.NL
.TP 18
INTEL_PROF_DUMP_INTERVAL
.NL
Initiates interval profile dumping in an instrumented user application. This environment variable may be used to initiate Interval Profile Dumping in an instrumented application. 
.NL
.TP 18
PROF_DIR
.NL
Specifies the directory in which dynamic information files are created. This variable applies to all three phases of the profiling process. 
.NL
.TP 18
PROF_DUMP_INTERVAL
.NL
Deprecated; use 
INTEL_PROF_DUMP_INTERVAL instead. 
.NL
.TP 18
PROF_NO_CLOBBER
.NL
Alters the feedback compilation phase slightly. By default, during the feedback compilation phase, the compiler merges data from all dynamic information files and creates a new 
pgopti.dpi file if the .dyn files are newer than an existing 
pgopti.dpi file. 
.TP 18
When this variable is set the compiler does not overwrite the existing 
pgopti.dpi file. Instead, the compiler issues a warning. You must remove the 
pgopti.dpi file if you want to use additional dynamic information files. 
.NL
.SH TECHNICAL SUPPORT
.PP
The Intel(R) Compiler product web site offers timely and comprehensive product information, including product features, white papers, and technical articles. 
.PP
For the latest information, visit 
\fIhttp://www.intel.com/software/products/\fR. 
.PP
For support information, see the Release Notes. For general support information, visit 
\fIhttp://www.intel.com/software/products/support/\fR. 
.PP
For licensing and registration information, visit 
\fIhttps://registrationcenter.intel.com/\fR. 
.SH SEE ALSO
.PP
icc(1), ld(1) 
.PP
The Intel(R) C++ Compiler Documentation has additional reference material on features of the Intel(R) C++ Compiler.
.SH Legal Information
.PP
INFORMATION IN THIS DOCUMENT IS PROVIDED IN CONNECTION WITH INTEL(R) PRODUCTS. NO LICENSE, EXPRESS OR IMPLIED, BY ESTOPPEL OR OTHERWISE, TO ANY INTELLECTUAL PROPERTY RIGHTS IS GRANTED BY THIS DOCUMENT. EXCEPT AS PROVIDED IN INTEL\[aq]S TERMS AND CONDITIONS OF SALE FOR SUCH PRODUCTS, INTEL ASSUMES NO LIABILITY WHATSOEVER, AND INTEL DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTY, RELATING TO SALE AND/OR USE OF INTEL PRODUCTS INCLUDING LIABILITY OR WARRANTIES RELATING TO FITNESS FOR A PARTICULAR PURPOSE, MERCHANTABILITY, OR INFRINGEMENT OF ANY PATENT, COPYRIGHT OR OTHER INTELLECTUAL PROPERTY RIGHT. 
A "Mission Critical Application" is any application in which failure of the Intel Product could result, directly or indirectly, in personal injury or death. SHOULD YOU PURCHASE OR USE INTEL\[aq]S PRODUCTS FOR ANY SUCH MISSION CRITICAL APPLICATION, YOU SHALL INDEMNIFY AND HOLD INTEL AND ITS SUBSIDIARIES, SUBCONTRACTORS AND AFFILIATES, AND THE DIRECTORS, OFFICERS, AND EMPLOYEES OF EACH, HARMLESS AGAINST ALL CLAIMS COSTS, DAMAGES, AND EXPENSES AND REASONABLE ATTORNEYS\[aq] FEES ARISING OUT OF, DIRECTLY OR INDIRECTLY, ANY CLAIM OF PRODUCT LIABILITY, PERSONAL INJURY, OR DEATH ARISING IN ANY WAY OUT OF SUCH MISSION CRITICAL APPLICATION, WHETHER OR NOT INTEL OR ITS SUBCONTRACTOR WAS NEGLIGENT IN THE DESIGN, MANUFACTURE, OR WARNING OF THE INTEL PRODUCT OR ANY OF ITS PARTS. 
Intel may make changes to specifications and product descriptions at any time, without notice. Designers must not rely on the absence or characteristics of any features or instructions marked "reserved" or "undefined." Intel reserves these for future definition and shall have no responsibility whatsoever for conflicts or incompatibilities arising from future changes to them. The information here is subject to change without notice. Do not finalize a design with this information. 
The products described in this document may contain design defects or errors known as errata which may cause the product to deviate from published specifications. Current characterized errata are available on request. 
Contact your local Intel sales office or your distributor to obtain the latest specifications and before placing your product order. 
Copies of documents which have an order number and are referenced in this document, or other Intel literature, may be obtained by calling 1\-800\-548\-4725, or by visiting Intel\[aq]s Web Site. 
.PP
Intel processor numbers are not a measure of performance. Processor numbers differentiate features within each processor family, not across different processor families. See http://www.intel.com/products/processor_number for details. 
.PP
Centrino, Cilk, Intel, Intel Atom, Intel Core, Intel NetBurst, Itanium, MMX, Pentium, Xeon, Intel Xeon Phi are trademarks of Intel Corporation in the U.S. and/or other countries. 
.PP
* Other names and brands may be claimed as the property of others. 
.PP
Copyright (C) 1996\-2013, Intel Corporation. All rights reserved. 
.PP
Portions Copyright (C) 2001, Hewlett\-Packard Development Company, L.P. 
